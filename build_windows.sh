#!/bin/bash

# This script builds mpv with inputstream.adaptive support on Windows using MSYS2.

set -e

# --- Dependencies ---

# Update package database
pacman -Syu --noconfirm

# Install mpv dependencies
pacman -S --noconfirm --needed     git     python     pkg-config     meson     ninja     mingw-w64-x86_64-toolchain     mingw-w64-x86_64-ffmpeg     mingw-w64-x86_64-libjpeg-turbo     mingw-w64-x86_64-libplacebo     mingw-w64-x86_64-luajit     mingw-w64-x86_64-vulkan-headers

# Install inputstream.adaptive dependencies
pacman -S --noconfirm --needed     mingw-w64-x86_64-cmake     mingw-w64-x86_64-pugixml     mingw-w64-x86_64-bento4     mingw-w64-x86_64-nlohmann-json

# TODO: Install Kodi headers and cmake files
# This is a placeholder. We need to get the Kodi headers and the FindKodi.cmake
# file and put them in the right place.

# --- Build inputstream.adaptive ---

echo "Cloning inputstream.adaptive..."
git clone https://github.com/purplescorpion1/inputstream.adaptive.git
cd inputstream.adaptive

# Create a mock KodiConfig.cmake file
mkdir -p cmake
cat <<'EOF' > cmake/KodiConfig.cmake
set(APP_NAME "Kodi")
set(APP_NAME_LC "kodi")
set(APP_NAME_UC "KODI")
set(APP_PACKAGE "kodi")
set(APP_VERSION_MAJOR "21")
set(APP_VERSION_MINOR "0")
set(APP_VERSION_CODE "2100")
set(KODI_PREFIX "/mingw64")
set(KODI_INCLUDE_DIR "/mingw64/include")
set(KODI_LIB_DIR "/mingw64/lib")
set(KODI_DATA_DIR "/mingw64/share/kodi")
set(APP_RENDER_SYSTEM "gl")
list(APPEND CMAKE_MODULE_PATH "/mingw64/lib" "/mingw64/share/kodi/cmake")
add_definitions(-DBUILD_KODI_ADDON)
set(CORE_SYSTEM_NAME "windows")
set(PLATFORM "windows")
set(PLATFORM_TAG "windows")
set(CMAKE_CXX_STANDARD "20")
set(CMAKE_CXX_STANDARD_REQUIRED "ON")
set(CMAKE_CXX_EXTENSIONS "OFF")
# TODO: We need the real AddonHelpers.cmake for this to work
include(AddonHelpers)
EOF

# Create AddonHelpers.cmake
cat <<'EOF' > cmake/AddonHelpers.cmake
# Workaround for the fact that cpack's filenames are not customizable.
# Each add-on is added as a separate component to facilitate zip/tgz packaging.
# The filenames are always of the form basename-component, which is
# incompatible with the addonid-version scheme we want. This hack renames
# the files from the file names generated by the 'package' target.
# Sadly we cannot extend the 'package' target, as it is a builtin target, see
# http://public.kitware.com/Bug/view.php?id=8438
# Thus, we have to add an 'addon-package' target.
get_property(_isMultiConfig GLOBAL PROPERTY GENERATOR_IS_MULTI_CONFIG)
if(_isMultiConfig)
  add_custom_target(addon-package DEPENDS PACKAGE)
else()
  add_custom_target(addon-package
                    COMMAND ${CMAKE_COMMAND} --build ${CMAKE_BINARY_DIR} --target package)
endif()

macro(add_cpack_workaround target version ext)
  if(NOT PACKAGE_DIR)
    set(PACKAGE_DIR "${CMAKE_INSTALL_PREFIX}/zips")
  endif()

  add_custom_command(TARGET addon-package POST_BUILD
                     COMMAND ${CMAKE_COMMAND} -E make_directory ${PACKAGE_DIR}
                     COMMAND ${CMAKE_COMMAND} -E copy ${CPACK_PACKAGE_DIRECTORY}/addon-${target}-${version}-${PLATFORM_TAG}.${ext} ${PACKAGE_DIR}/${target}+${PLATFORM_TAG}/${target}-${version}.${ext})
endmacro()

# Grab the version from a given add-on's addon.xml
macro (addon_version dir prefix)
  if(EXISTS ${PROJECT_SOURCE_DIR}/${dir}/addon.xml.in)
    file(READ ${PROJECT_SOURCE_DIR}/${dir}/addon.xml.in ADDONXML)
  else()
    file(READ ${dir}/addon.xml ADDONXML)
  endif()

  string(REGEX MATCH "<addon[^>]*version.?=.?.[0-9\.]+" VERSION_STRING ${ADDONXML})
  string(REGEX REPLACE ".*version=.([0-9\.]+).*" "\1" ${prefix}_VERSION ${VERSION_STRING})
  message(STATUS ${prefix}_VERSION=${${prefix}_VERSION})
endmacro()


# IDEs: Group source files in target in folders (file system hierarchy)
# Source: http://blog.audio-tk.com/2015/09/01/sorting-source-files-and-projects-in-folders-with-cmake-and-visual-studioxcode/
# Arguments:
#   target The target that shall be grouped by folders.
# Optional Arguments:
#   RELATIVE allows to specify a different reference folder.
function(source_group_by_folder target)
  if(NOT TARGET ${target})
    message(FATAL_ERROR "There is no target named '${target}'")
  endif()

  set(SOURCE_GROUP_DELIMITER "/")

  cmake_parse_arguments(arg "" "RELATIVE" "" ${ARGN})
  if(arg_RELATIVE)
    set(relative_dir ${arg_RELATIVE})
  else()
    set(relative_dir ${CMAKE_CURRENT_SOURCE_DIR})
  endif()

  get_property(files TARGET ${target} PROPERTY SOURCES)
  if(files)
    list(SORT files)

    if(CMAKE_GENERATOR STREQUAL Xcode)
      set_target_properties(${target} PROPERTIES SOURCES "${files}")
    endif()
  endif()
  foreach(file ${files})
    if(NOT IS_ABSOLUTE ${file})
      set(file ${CMAKE_CURRENT_SOURCE_DIR}/${file})
    endif()
    file(RELATIVE_PATH relative_file ${relative_dir} ${file})
    get_filename_component(dir "${relative_file}" DIRECTORY)
    if(NOT dir STREQUAL "${last_dir}")
      if(files)
        source_group("${last_dir}" FILES ${files})
      endif()
      set(files "")
    endif()
    set(files ${files} ${file})
    set(last_dir "${dir}")
  endforeach(file)
  if(files)
    source_group("${last_dir}" FILES ${files})
  endif()
endfunction()

# Build, link and optionally package an add-on
macro (build_addon target prefix libs)
  addon_version(${target} ${prefix})

  if(${prefix}_SOURCES)
    add_library(${target} SHARED ${${prefix}_SOURCES} ${${prefix}_HEADERS})
    source_group_by_folder(${target})
    target_link_libraries(${target} ${${libs}})
    set_target_properties(${target} PROPERTIES VERSION ${${prefix}_VERSION}
                                               SOVERSION ${APP_VERSION_MAJOR}.${APP_VERSION_MINOR}
                                               PREFIX ""
                                               POSITION_INDEPENDENT_CODE 1)
    if(OS STREQUAL "android")
      set_target_properties(${target} PROPERTIES PREFIX "lib")
    endif()
  elseif(${prefix}_CUSTOM_BINARY)
    add_custom_target(${target} ALL)
  endif()
endmacro()
EOF

echo "Building inputstream.adaptive..."
mkdir build
cd build
cmake .. -G "MinGW Makefiles" \
    -DCMAKE_MODULE_PATH=${PWD}/../cmake \
    -DADDONS_TO_BUILD=inputstream.adaptive \
    -DCMAKE_INSTALL_PREFIX=/mingw64 \
    -DCMAKE_BUILD_TYPE=Release
make
make install

cd ../..

# --- Build mpv ---

echo "Building mpv..."
meson setup build
meson compile -C build

# --- Get Widevine CDM ---

mkdir -p cdm
echo "Please download the Widevine CDM from a Chrome or ChromeOS recovery image and place it in the 'cdm' directory."
echo "The file should be named 'widevinecdm.dll'."
echo "Press enter to continue..."
read

# --- Create distribution package ---

echo "Creating distribution package..."
mkdir -p dist
cp build/mpv.exe dist/
cp /mingw64/bin/inputstream.adaptive.dll dist/

if [ -f "cdm/widevinecdm.dll" ]; then
    cp cdm/widevinecdm.dll dist/
else
    echo "WARNING: widevinecdm.dll not found. Widevine protected streams will not work."
fi

# TODO: Copy other necessary DLLs to dist/

echo "Build finished. The 'dist' directory contains the binaries."
