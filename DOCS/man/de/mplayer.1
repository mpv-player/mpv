.\" MPlayer (C) 2000-2005 MPlayer Team
.\" Diese Man-Page wurde/wird von Gabucino, Diego Biurrun, Jonas Jermann,
.\" Moritz Bunkus und Sebastian Krämer gepflegt.
.\" 
.\" Gib dies ein, um eine HTML-Version der Man-Page zu erhalten:
.\"   cat mplayer.1 | sed s/SS\ 20/SS\ 4/ | groff -man -Thtml - > manpage.html
.\" Gib dies ein, um eine Textversion der Man-Page zu erhalten:
.\"   groff -m man -Tascii mplayer.1 | col -bx > manpage.txt
.\" 
.
.\" --------------------------------------------------------------------------
.\" Macrodefinitionen
.\" --------------------------------------------------------------------------
.
.\" Standardeinrückung ist 7, nicht ändern!
.nr IN 7
.\" Einrückung für Suboptionen
.nr SS 5
.\" neue Suboption hinzufügen
.de IPs
.IP "\\$1" \n(SS
..
.\" Beginn des ersten Suboptionen-Levels, endet mit .RE
.de RSs
.RS \n(IN+3
..
.\" Beginn des zweiten Suboptionen-Levels
.de RSss
.PD 0
.RS \n(SS+3
..
.\" Ende des zweiten Levels von Suboptionen
.de REss
.RE
.PD 1
..
.
.\" --------------------------------------------------------------------------
.\" Titel
.\" --------------------------------------------------------------------------
.
.TH MPlayer 1 "2005-05-03" "Das MPlayer Projekt"
.
.SH NAME
mplayer  \- Movie Player
.br
mencoder \- Movie Encoder
.
.\" --------------------------------------------------------------------------
.\" Synopsis
.\" --------------------------------------------------------------------------
.
.SH SYNOPSIS
.na
.nh
.B mplayer
.RI [Optionen]\ [ \ Datei\  | \ URL\  | \ Playlist\  | \ \-\  ]
.
.br
.in
.B mplayer
'in +\n[.k]u
[globale Optionen]
.I Datei1
[spezielle Optionen] [Datei2] [spezielle Optionen]
.
.br
.in
.B mplayer
'in +\n[.k]u
[globale Optionen]
.RI { "Liste von Dateien und Optionen" }
[Liste von Dateien und Optionen]
.
.br
.in
.B mplayer
'in +\n[.k]u
.I dvd://[Titel | [Starttitel]\-Endtitel ]
[Optionen]
.
.br
.in
.B mplayer
'in +\n[.k]u
.I vcd://Titel[/Gerät]
.
.br
.in
.B mplayer
'in +\n[.k]u
.I tv://[Kanal]
[Optionen]
.
.br
.in
.B mplayer
'in +\n[.k]u
.I dvb://[Kartennummer@]Kanal
[Optionen]
.
.br
.in
.B mplayer
'in +\n[.k]u
.I mf://Dateimaske
[-mf Optionen] [Optionen]
.
.br
.in
.B mplayer
'in +\n[.k]u
.I [cdda|cddb]://Titel[:Geschwindigkeit][/Gerät]
[Optionen]
.
.br
.in
.B mplayer
'in +\n[.k]u
.I cue://Datei[:Titel]
[Optionen]
.
.br
.in
.B mplayer
'in +\n[.k]u
.RI [ file | mms[t] | http | http_proxy | rt[s]p | ftp | udp] ://
[Benutzer:Passwort@]\fIURL\fP[:Port] [Optionen]
.br
.in
.B mplayer
'in +\n[.k]u
.I sdp://Datei
[Optionen]
.
.br
.in
.B mplayer
'in +\n[.k]u
.I mpst://Rechnername[:Port]/URL
[Optionen]
.
.br
.in
.B mplayer
'in +\n[.k]u
.I tivo://Rechnername/list
[Optionen]
.br
.in
.B mplayer
'in +\n[.k]u
.I tivo://Rechnername/llist
[Optionen]
.br
.in
.B mplayer
'in +\n[.k]u
.I tivo://Rechnername/fsid
[Optionen]
.br
.in
.B gmplayer
'in +\n[.k]u
[Optionen]
[\-skin\ Skin]
.
.br
.in
.B mencoder
'in +\n[.k]u
[Optionen]
.RI [ \ Datei\  | \ URL\  | \ \-\  ]
[\-o\ Datei]
.
.br
.in
.B mencoder
'in +\n[.k]u
[globale Optionen]
.I Datei1
[spezielle Optionen] [Datei2] [spezielle Optionen]
.ad
.hy

.\" --------------------------------------------------------------------------
.\" Beschreibung
.\" --------------------------------------------------------------------------
.
.SH BESCHREIBUNG
.B mplayer
ist ein Movie-Player für Linux (der auch auf vielen anderen Plattformen und
CPU-Architekturen läuft, siehe Dokumentation).
Er spielt die meisten Dateien in den Formaten
MPEG/\:VOB, AVI, ASF/\:WMA/\:WMV, RM, QT/\:MOV/\:MP4, OGG/\:OGM,
VIVO, FLI, NuppelVideo, yuv4mpeg, FILM und RoQ ab, unterstützt von vielen
eingebauten und binären Codecs.
Es können VideoCDs, SuperVCDs, DVDs, 3ivx-, DivX\ 3/\:4/\:5- und sogar
WMV-Filme angeschaut werden.
.PP
MPlayer unterstützt eine große Auswahl an Video- und Audioausgabetreibern.
Er funktioniert mit X11, XV, DGA, OpenGL, SVGAlib, fbdev, AAlib, libcaca,
DirectFB, Quartz und Mac OS X CoreVideo, du kannst ihn aber auch mit GGI, SDL
(und damit alle von SDL unterstützen Treiber), VESA (mit jeder VESA-kompatiblen
Grafikkarte, auch ohne X11) sowie mit einigen kartenspezifischen
Low-Level-Treibern (für Matrox, 3Dfx und ATI) und ein paar
Hardware-MPEG-Decoderkarten wie der Siemens DVB, DXR2 und DXR3/\:Hollywood+
benutzen.
Die meisten von ihnen unterstützen Software- oder Hardwareskalierung,
so dass die Vollbildwiedergabe kein Problem ist.
.PP
MPlayer verfügt über ein On-Screen-Display (OSD) für Statusinformationen,
schöne, große, schattierte und kantengeglättete Untertitel und visuelles
Feedback bei Tastatureingaben.
Europäische/\:ISO 8859-1,2 (Ungarisch, Englisch, Tschechisch etc), Kyrillische
und Koreanische Schriftarten werden ebenso wie zwölf Untertitelformate
(MicroDVD, SubRip, OGM, SubViewer, Sami, VPlayer, RT, SSA, AQTitle, JACOsub,
PJS und unser eigenes: MPsub) unterstützt, ebenso wie DVD-Untertitel
(SPU-Streams, VOBsub und Closed Captions).
.PP
.B mencoder
(MPlayer's Movie Encoder) ist ein einfacher Movie-Encoder, der so entworfen
wurde, dass er alle von MPlayer abspielbaren Filme (siehe oben) in andere
von MPlayer abspielbare Formate (siehe unten) umwandeln kann.
Er encodiert nach MPEG-4 (DivX/XviD), jeden der libavcodec-Codecs und Audio
nach PCM/\:MP3/\:VBRMP3, das ganze in 1, 2 oder 3 Durchgängen.
Des weiteren kann er Streams kopieren und verfügt über ein mächtiges
Filtersystem (Entfernen (cropping) und Hinzufügen (expanding) von Rändern,
horizontales Spiegeln, Postprocessing (Nachbearbeitung), Rotation, Skalierung,
Rauschunterdrückung (denoising), RGB/\:YUV-Konvertierung und mehr).
.PP
.B gmplayer
ist die Bezeichnung für MPlayer mit einem graphischen Benutzerinterface.
Er verfügt über die gleichen Optionen wie MPlayer.
.PP
Beispiele zum Gebrauch, die dir zu einem schnellen Start verhelfen,
findest Du am Ende dieser Man page.
.PP
.B Siehe auch die HTML-Dokumentation!
.
.
.\" --------------------------------------------------------------------------
.\" Keyboard control
.\" --------------------------------------------------------------------------
.
.SH "TASTATURSTEUERUNG"
MPlayer besitzt eine Kontrollfunktion, die befehlsgesteuert ist und sich komplett
konfigurieren lässt.
Die Steuerung geschieht mittels Tastatur, Maus, Joystick oder Fernbedienung
(funktionierende LIRC-Unterstützung vorausgesetzt).
Bei der Option \-input findest du Beschreibungen, wie man diese Funktionen
anpassen kann.
.
.TP
.B Allgemeine Kontrolle
.PD 0
.RSs
.IPs "<\- und \->"
Springe 10 Sekunden zurück/\:vor.
.IPs "HOCH und RUNTER"
Springe 1 Minute zurück/\:vor.
.IPs "BildHoch und BildRunter (bzw.\& PGUP/\:PGDOWN)"
Springe 10 Minuten zurück/\:vor.
.IPs "[ und ]"
Verringert/erhöht die Abspielgeschwindigkeit um 10%.
.IPs "{ und }"
Halbiert/\:verdoppelt die Abspielgeschwindigkeit.
.IPs "Löschen (Backspace)"
Setzt die Abspielgeschwindigkeit zurück.
.IPs "< und >"
zurück/\:vor in der Playlist
.IPs "Pos1 und Ende"
nächster/\:voriger Eintrag des Wiedergabebaums der aktuellen Liste
.IPs "INS und DEL"
nächste/\:vorige alternative Quelle (nur bei ASX-Playlists)
.IPs "p / LEERTASTE"
Wiedergabe pausieren (jede Taste unterbricht die Pause).
.IPs .\ \ \ \ 
Einen Schritt vorwärts.
Einmaliges Drücken pausiert die Wiedergabe, jedes weitere wird einen Frame
abspielen und die Wiedergabe erneut anhalten (jede andere Taste hebt die Pause
auf).
.IPs "q / ESC"
Beendet die Wiedergabe und MPlayer.
.IPs "+ und -"
Passt die Audioverzögerung um +/\:- 0.1 Sekunde an.
.IPs "/ und *"
Erhöht/\:verringert die Lautstärke.
.IPs "9 und 0"
Erhöht/\:verringert die Lautstärke.
.IPs m\ \ \ \ 
Ändert Ton-Stummschaltung (ein/\:aus).
.IPs "#" (nur bei MPEG und Matroska)
Wechselt zwischen den verfügbaren Audiospuren.
.IPs f\ \ \ \ 
Ändert Vollbild-Wiedergabe (ein/\:aus).
.IPs T\ \ \ \ 
Ändert Stay-on-top-Eigenschaft (ein/\:aus).
.IPs "w und e"
Verringert/\:erhöht den Panscan-Bereich.
.IPs o\ \ \ \ 
Wechselt zwischen OSD-Anzeigen: keine / Suche / Suche+Zeit /
Suche+Zeit+Gesamtzeit.
.IPs d\ \ \ \ 
Wechselt zwischen verschiedenen Framedropping-Einstellungen:  keine /
überspringe
Display / überspringe Decodierung (siehe \-framedrop und \-hardframedrop).
.IPs v\ \ \ \ 
Ändert Sichtbarkeit der Untertitel (aus/\:ein).
.IPs "b / j"
Wechselt durch die verfügbaren Untertitel.
.IP F\ \ \ \ 
Ändert die Anzeige der "erzwungenen Untertitel".
.IPs a\ \ \ \ 
Ändert die Positionierung der Untertitel: oben/\:mitte/\:unten.
.IPs "z und x"
Passt die Untertitel-Anzeige um +/\:- 0.1 Sekunde an.
.IPs "r und t"
Bewegt die Untertitel nach oben/\:unten.
.IPs i\ \ \ \ 
Setze EDL-Markierung.
.RE
.PD 1
.PP
(Die folgenden Eingaben funktionieren nur in Verbindung mit hardwarebeschleunigter
Videoausgabe (xv, (x)vidix, (x)mga, etc), dem Softwareequalizer-
(\-vf eq oder \-vf eq2) oder dem Farbtonfilter (\-vf hue).
.PP
.PD 0
.RSs
.IPs "1 und 2"
Passe Kontrast an.
.IPs "3 und 4"
Passe Helligkeit an.
.IPs "5 und 6"
Passe Farbton an.
.IPs "7 und 8"
Passe Sättigung an.
.RE
.PD 1
.PP
(Die folgenden Tasten sind nur gültig bei Benutzung der Videoausgabetreiber
quartz und macosx.)
.PP
.PD 0
.RSs
.IPs "Apfel + 0"
Ändere die Größe des Abspielfensters auf die Hälfte der Originalgröße.
.IPs "Apfel + 1"
Ändere die Größe des Abspielfensters auf die Originalgröße.
.IPs "Apfel + 2"
Ändere die Größe des Abspielfensters auf das doppelte der Originalgröße.
.IPs "Apfel + f"
Aktiviere/\:deaktiviere Vollbildwiedergabe (siehe auch \-fs).
.IPs "Apfel + [ und Apfel + ]"
Setze Alphawert des Abspielfensters.
.RE
.PD 1
.
.TP
.B GUI Tastatursteuerung
.PD 0
.RSs
.IPs ENTER
Startet Wiedergabe.
.IPs s\ \ \ \ 
Beendet Wiedergabe.
.IPs l\ \ \ \ 
Datei laden.
.IPs c\ \ \ \ 
Skinbrowser.
.IPs p\ \ \ \ 
Anzeige der Playlist an/\:aus.
.RE
.PD 1
.
.TP
.B TV Input-Steuerung
.PD 0
.RSs
.IPs "h und k"
Wählt vorigen/\:nächsten Kanal.
.IPs n\ \ \ \ 
Ändert Norm (PAL/\:NTSC).
.IPs u\ \ \ \ 
Ändert die Anzeige der Liste der Kanäle.
.RE
.PD 1
.
.
.\" --------------------------------------------------------------------------
.\" Optionen
.\" --------------------------------------------------------------------------
.
.SH "ZUM UMGANG MIT MPLAYER"
Jede Option 'flag' kennt ein Gegenstück, 'noflag'.
Beispielsweise ist '\-nofs' das Gegenstück zu '\-fs'.
.PP
Wenn eine Option als (nur XXX)-markiert ist, wird diese nur in Kombination mit
der XXX-Option funktionieren oder wenn XXX einkompiliert ist.
.PP
Du kannst jede Option in einer Konfigurationsdatei speichern, die bei jedem
Start von MPlayer gelesen wird.
Die systemweite Konfigurationsdatei 'mplayer.conf' liegt in deinem
Konfigurationsverzeichnis (z.B.\& /etc/\:mplayer oder
/usr/\:local/\:etc/\:mplayer), die benutzerspezifische Datei ist
\'~/\:.mplayer/\:config'.
Benutzerspezifische Einstellungen haben Vorrang vor den systemweiten,
und Optionen auf der Kommandozeile überschreiben die beiden anderen.
Die Syntax der Konfigurationsdateien lautet 'Option=<Wert>'.
Alles, was nach einem '#' kommt, wird als Kommentar verstanden und nicht
ausgewertet.
Optionen, die keine Werte benötigen, können aktiviert werden, wenn
du ihnen den Wert 'yes' oder '1' oder 'true' zuweist, deaktiviert werden sie
mit \'no' oder '0'.
Selbst Suboptionen können in dieser Art angegeben werden.
.PP
.I BEISPIEL:
.nf
# Benutze in der Voreinstellung den Matrox-Treiber
vo=xmga
# Ich stehe darauf, beim Zusehen einen Handstand zu machen.
flip=yes
# Decodiere/\:encodiere mehrere Dateien im PNG-Format,
# beginne mit mf://Dateimaske.
mf=type=png:fps=25
# Unheimliche Negativbilder sind cool.
vf=eq2=1.0:-0.8
.fi
.PP
Du kannst auch dateispezifische Konfigurationsdateien schreiben.
Wenn du für einen Film namens 'movie.avi' eine Konfigurationsdatei schreiben
möchtest, dann nenne diese Datei 'movie.avi.conf', stecke dort alle nur für
diesen Film relevanten Optionen rein und speichere die Datei in ~/\:.mplayer
oder im gleichen Verzeichnis wie 'movie.avi'.
.
.
.
.SH "ALLGEMEINE OPTIONEN"
.
.TP
.B \-codecs-file <Dateiname> (siehe auch \-afm, \-ac, \-vfm, \-vc)
Benutze die angegebene Datei anstelle der systemweit installierten oder
der eingebauten codecs.conf.
.
.TP
.B \-include <Konfigurationsdatei>
Gib eine Konfigurationsdatei an, die nach der Standardkonfigurationsdateien
eingelesen werden soll.
.
.TP
.B \-quiet \ \ 
Konsolenausgaben werden weniger ausführlich; insbesondere wird damit die
Statuszeile (z.B.\& A:   0.7 V:   0.6 A-V:  0.068 ...) nicht angezeigt.
Besonders nützlich ist dies bei langsamen Terminals oder fehlerhaften, die 
Zeilenvorschübe nicht richtig verarbeiten (z.B.\& \\r).
.
.TP
.B \-priority <prio> (nur bei Windows)
Setzt die Prozesspriorität für MPlayer anhand der von Windows vordefinierten
Prioritäten.
Mögliche Werte für <prio>:
.RSs
idle|belownormal|normal|abovenormal|high|realtime
.RE
.sp 1
.RS
.I WARNUNG:
Echtzeitpriorität zu benutzen kann das System einfrieren.
.RE
.
.TP
.B \-v, \-verbose
macht Ausgaben ausführlicher (mehrere \-v erzeugen höhere Ausführlichkeit).
.PD 0
.RSs
.IPs 0
nur einige Informationsausgaben (Standard)
.IPs 1
einige Debug-Informationen, avi-Header, Funktionswerte (init-Debug)
.IPs 2
gibt AVI-Indizes, Dateiblock-Inputs und weitere Debug-Informationen aus
(Player-Debug)
.IPs 3
gibt alles aus, was mit dem Input-Parser zu tun hat (Parser-Debug)
.RE
.PD 1
.
.
.
.SH "PLAYER-SPEZIFISCHE OPTIONEN (NUR FÜR MPLAYER)"
.
.TP
.B \-autoq <Qualität> (zusammen mit \-vf [s]pp)
Ändert dynamisch das Qualitätslevel des Postprocessings, je nachdem, wieviel
CPU-Zeit gerade frei ist.
Das angegebene Level ist das maximal verwendete Level.
Normalerweise kannst du eine große Zahl wählen.
Um dieses Feature zu benutzen, muss \-vf [s]pp ohne Parameter aufgerufen
werden.
.
.TP
.B \-autosync <Faktor>
Ändert schrittweise die A/\:V-Synchronisation basierend auf den
Messungen der Audioverzögerung.
Mit \-autosync\ 0, dem Standardwert, wird das Bildtiming nur auf der
gemessenen Audioverzögerung basieren.
Mit \-autosync\ 1 wird der A/\:V-Synchronisationsalgorithmus leicht verändert.
Bei einem Film mit nicht gleichbleibender Framerate, der mit \-nosound
problemlos abgespielt wird, kann \-autosync mit einem Wert größer 1
helfen.
Je höher der Wert gewählt wird, desto mehr ähnelt das Verhalten dem von
\-nosound.
\-autosync\ 30 kann bei Problemen helfen, die bei Audiotreibern entstehen,
die keine perfekt funktionierende Messung der Audioverzögerung zulassen.
Falls große A/\:V-Synchronisationsunterschiede auftreten, dauert es mit mit
diesem Wert meist nur eine oder zwei Sekunden, bis die A/\:V-Synchronisation
wieder in Ordnung ist.
Diese Verzögerung bei der Reaktion auf abrupte A/\:V-Synchronisationsänderungen
sollte bei allen Sound-Treibern der einzige Nebeneffekt dieser Option sein.
.
.TP
.B \-benchmark
Gibt am Ende einige Statistiken über die CPU-Auslastung und ausgelassene
Frames aus. Zusammen mit \-nosound und \-vo null kann es benutzt werden,
um den Videocodec einem Geschwindigkeitstest zu unterziehen.
.br
.I ANMERKUNG:
Bei dieser Option ignoriert MPlayer die Abspieldauer eines Frames, wenn nur
Video abgespielt wird (das kannst Du Dir als unendlich hohe Frame-Rate (fps)
vorstellen).
.
.TP
.B \-colorkey <Nummer>
Ändert den Farbwert auf einen RGB-Wert deiner Wahl.
0x000000 ist schwarz und 0xffffff ist weiß.
Wird nur von folgenden Videoausgabetreibern unterstützt: cvidix, fbdev, 
svga, vesa, winvidix, xmga, xvidix, xover, xv (siehe \-vo xv:ck), xvmc
(siehe \-vo xv:ck) und directx.
.
.TP
.B \-nocolorkey
Schaltet die Wahl des Farbwertes ab.
Wird nur von folgenden Videoausgabetreibern unterstützt: cvidix, fbdev, 
svga, vesa, winvidix, xmga, xvidix, xover, xv (siehe \-vo xv:ck), xvmc
(siehe \-vo xv:ck) und directx.
.
.TP
.B \-crash-debug (DEBUG-CODE)
Hängt bei einem Absturz oder SIGTRAP automatisch gdb an.
Unterstützung hierfür muß einkompiliert sein durch Ausführung von 'configure'
mit --enable-crash-debug oder Vorhandensein einer .developer-Datei im
Verzeichnis der Sourcedateien.
.
.TP
.B \-edlout <Dateiname> (nur bei EDL)
Erstellt eine neue EDL-Datei und schreibt EDL-Markierungen in diese Datei.
Während der Wiedergabe kann der Benutzer 'i' drücken, und ein Eintrag,
um an der aktuellen Position zwei Sekunden des Video zu überspringen, wird
in die Datei geschrieben.
Damit erhält der Benutzer eine Ausgangsbasis, die er an seine Bedürfnisse
anpassen kann.
Siehe DOCS/\:de/\:documentation.html#edl, dort stehen Details, wie du dieses
Feature benutzen kannst.
.
.TP
.B \-enqueue (nur beim GUI)
Hänge die auf der Kommandozeile angegebenen Dateien an die Playlist an,
anstatt sie sofort abzuspielen.
.
.TP
.B \-fixed-vo (BETA-CODE!)
Erzwingt dasselbe Videosystem für mehrere Dateien (einmalige Initialisierung
für alle Dateien).
Dementsprechend wird für alle Dateien nur ein Fenster geöffnet.
Momentan funktionieren die folgenden Treiber mit \-fixed-vo: gl, gl2, mga, 
svga, x11, xmga, xv, xvidix und dfbmga.
.
.TP
.B \-framedrop (siehe auch \-hardframedrop)
Verwirft einige Frames, ohne sie anzuzeigen, um auf langsamen Systemen
die A/\:V-Synchronisation beizubehalten.
Videofilter werden auf diese Frames nicht angewendet.
B-Frames werden überhaupt nicht decodiert.
.
.TP
.B \-h, \-help, \-\-help
Zeigt eine kurze Zusammenfassung der Optionen an.
.
.TP
.B \-hardframedrop
Noch rabiateres Verwerfen von Frames (verhindert evtl. korrektes
Decodieren).
Führt zu Bildstörungen!
.
.TP
.B \-identify
Zeigt Dateiparameter in einem einfach einzulesenden Format an.
Gibt außerdem detailliertere Informationen über IDs und die Sprachen von
Untertiteln und Audiospuren.
Das Script TOOLS/\:midentify unterdrückt die anderen Ausgaben von MPlayer
und führt (hoffentlich) Shell-Escaping für die Dateinamen aus.
.
.TP
.B \-input <Kommandos>
Diese Option kann benutzt werden, um bestimmte Teile von MPlayers
Eingabesystem zu konfigurieren.
Pfadangaben sind relativ zu ~/\:.mplayer/.
.br
.I ANMERKUNG:
Automatische Wiederholung (autorepeat) wird momentan nur von Joysticks
unterstützt.
.sp 1
Die verfügbaren Kommandos lauten:
.sp 1
.PD 0
.RSs
.IPs conf=<Dateiname>
Gib eine andere Konfigurationsdatei als die Standarddatei
~/\:.mplayer/\:input.conf an.
Wenn kein Pfadname angegeben wird, dann wird ~/\:.mplayer/\:<Dateiname>
angenommen.
.IPs ar-delay
Zeit in Millisekunden, bevor ein Tastendruck automatisch wiederholt
wird (0 deaktiviert dies).
.IPs ar-rate
Anzahl der Tastendrücke pro Sekunde bei automatisch wiederholten
Tastendrücken (0 deaktiviert dies).
.IPs keylist
Zeigt alle Tastennamen an, die mit Kommandos belegt werden können.
.IPs cmdlist
Zeigt alle Kommandos an, die zugewiesen werden können.
.IPs js-dev
Gibt das zu benutzende Joystickgerät an (Standard: /dev/\:input/\:js0).
.IPs Datei
Liest Kommandos aus der angegeben Datei.
Ist mit einem FIFO am sinnvollsten.
.br
.I ANMERKUNG:
Falls die angegebene Datei ein FIFO ist, öffnet MPlayer beide Enden, so daß
mehrere 'echo "seek 10" > mp_pipe' ausgeführt werden können und die Pipe in
Ordnung bleibt.
.RE
.PD 1
.
.TP
.B \-key-fifo-size <2\-65000>
Gibt die Größe des FIFO an, der Schlüsselevents zwischenspeichert (Standard:
10).
Ein FIFO der Größe n kann (n-1) Events zwischenspeichern.
Wenn er zu klein ist, können manche Events verlorengehen (was zu
"hängenden Mausbuttons" und ähnlichen Effekten führen kann).
Ist er zu groß, kann es zu einem scheinbar aufgehängten MPlayer führen,
während die zwischengespeicherten Events abgearbeitet werden.
Um ein Verhalten wie vor der Einführung dieser Option zu erhalten, setze den
Wert auf 2 für Linux oder 1024 für Windows.
.
.TP
.B \-lircconf <Dateiname> (nur bei LIRC)
Gibt eine Konfigurationsdatei für LIRC an (Standard: ~/\:.lircrc).
.
.TP
.B \-list-options
Gibt alle verfügbaren Optionen aus.
.
.TP
.B \-loop <Anzahl>
Wiederholt die Wiedergabe <Anzahl> mal.
0 bedeutet ständige Wiederholung.
.
.TP
.B \-menu (nur bei OSD)
Aktiviert das OSD\-Menü.
.
.TP
.B \-menu-cfg <Dateiname> (nur bei OSD)
Benutzt eine andere menu.conf.
.
.TP
.B \-menu-root <Wert> (nur bei OSD)
Gibt das Hauptmenü an.
.
.TP
.B \-menu-startup (nur bei OSD)
Zeigt das Hauptmenü beim Start von MPlayer.
.
.TP
.B \-noconsolecontrols
Für Ereignisse wird von MPlayer nicht die Standardeingabe (stdin) verwendet.
Das ist nützlich beim Lesen von Daten von der Standardeingabe.
Diese Option wird automatisch aktiviert, wenn \- auf der Kommandozeile
gefunden wird.
Es gibt auch Situationen, in denen du sie manuell setzen musst, z.B.\&
wenn du /dev/\:stdin (oder das Äquivalent auf deinem System) öffnest, stdin in
einer Playlist öffnest, oder vorhast, irgendwann später von stdin via loadfile
oder loadlist Slave-Kommandos zu lesen.
.
.TP
.B \-nojoystick
Schaltet die Joystickunterstützung aus.
.
.TP
.B \-nolirc
Schaltet Unterstützung für LIRC aus.
.
.TP
.B \-nomouseinput (nur bei X11)
Sperrt die Eingabe mittels Mausbuttons (Buttonpress/\:-release) (diese Option
wird unter anderem von mozplayerxp verwendet, um ein eigenes Kontextmenü
anzuzeigen).
.
.TP
.B \-nortc (nur bei RTC)
Deaktiviert die Benutzung der Echtzeituhr (real-time clock (RTC) \- /dev/\:rtc)
für das Timing.
.
.TP
.B \-playlist <Dateiname>
Spielt die in der Datei angegebenen Dateien ab (eine Datei pro Zeile,
oder eine Datei im Winamp- oder ASX-Format).
.br
.I Anmerkung:
Diese Option wird als ein Eintrag gesehen, so daß alle Optionen danach nur auf
die Elemente dieser Playlist angewendet werden.
.br
FIXME: Dies muss noch genauer angegeben und ordentlich dokumentiert werden.
.
.TP
.B \-really-quiet (siehe auch \-quiet)
Zeigt noch weniger Statusmeldungen an als mit \-quiet.
.
.TP
.B \-rtc-device <Gerät>
Benutze das angegebene Gerät als Echtzeituhr.
.
.TP
.B \-shuffle
Spielt die Dateien in zufälliger Reihenfolge ab.
.
.TP
.B \-skin <Name> (nur beim GUI)
Lädt eine Oberfläche (skin) aus dem angegebenen Verzeichnis, das sich in einem
der beiden Standardoberflächenverzeichnisse
/usr/\:local/\:share/\:mplayer/\:Skin/\: und ~/.mplayer/\:Skin/ befindet.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-skin fittyfene"
Probiert zuerst /usr/\:local/\:share/\:mplayer/\:Skin/\:fittyfene und
anschließend ~/.mplayer/\:Skin/\:fittyfene.
.RE
.PD 1
.
.TP
.B \-slave (siehe auch \-input)
Diese Option aktiviert den Slave-Modus, der dazu gedacht ist, MPlayer von
anderen Programmen aus zu steuern.
Anstatt Tastatureingaben abzufangen, liest MPlayer durch Zeilenumbruchszeichen
(\\n) getrennte Kommandos von stdin.
.br
.I ANMERKUNG:
Siehe \-input cmdlist für eine Liste der Slave-Kommandos und
DOCS/\:tech/\:slave.txt (englisch) für deren Beschreibung.
.
.TP
.B \-softsleep
Benutzt hochqualitative Softwaretimer anstelle der Echtzeituhr.
Sie sind so präzise wir die Echtzeituhr, benötigen aber keine Root-Rechte.
Der Preis dafür ist eine höhere CPU-Auslastung.
.
.TP
.B \-sstep <Sekunden>
Überspringt <Sekunden> Sekunden nach jedem Frame.
Die normale Framerate des Films wird beibehalten, die Wiedergabe ist also
beschleunigt.
Da MPlayer nur zum nächsten Keyframe springen kann, kann diese Option ungenau
sein.
.
.
.
.SH "DEMUXER-/\:STREAM-OPTIONEN"
.
.TP
.B \-a52drc <Level>
Gibt das Level der Dynamic Range Compression für den AC3 Audiostream an.
<Level> ist ein Fließkommawert im Bereich von 0 bis 1, wobei 0 keine Kompression
und 1 volle Kompression bedeutet (laute Passagen werden leiser und umgekehrt).
Diese Option zeigt nur Wirkung, wenn im AC3 Stream die Range Compression
Information vorhanden ist (Standard: 1).
.
.TP
.B \-aid <ID> (siehe auch \-alang)
Gibt die zu verwendende Audiospur an (MPEG: 0\-31 AVI/\:OGM: 1\-99
ASF/\:RM: 0\-127 VOB(AC3): 128\-159 VOB(LPCM): 160\-191 MPEG-TS: 17\-8190).
MPlayer gibt alle verwendbaren Audio-IDs aus, wenn er im Verbose-Modus (\-v)
gestartet wird.
Beim Abspielen eines MPEG-TS-Streams wählt MPlayer/\:MEncoder das erste
Programm (falls vorhanden) mit der gewählten Audiospur.
.
.TP
.B \-alang <Sprachcode[,Sprachcode,...]> (siehe auch \-aid)
Gibt eine Prioritätenliste der abzuspielenden Audiospuren an.
Verschiedene Containerformate verwenden unterschiedliche Ländercodes.
DVDs benutzen den zweibuchstabigen ISO 639-1 Sprachcode, Matroska und NUT
benutzen den dreibuchstabigen ISO 639-2 Sprachcode, während OGM einen
formlosen Bezeichner verwendet.
MPlayer gibt alle vorhandenen Sprachen aus, wenn er im ausführlichen Modus
(\-v) gestartet wird.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "mplayer dvd://1 \-alang hu,en"
Wählt die ungarische Sprachspur einer DVD und wählt die englische, wenn
ungarisch nicht verfügbar ist.
.IPs "mplayer \-alang jpn example.mkv"
Spielt eine Matroskadatei auf japanisch ab.
.RE
.PD 1
.
.TP
.B \-audio-demuxer <Nummer> (nur bei \-audiofile)
Erzwingt den Audiodemuxertyp für \-audiofile.
Gib die Demuxer-ID an wie in libmpdemux/\:demuxer.h definiert.
\-audio-demuxer 17 erzwingt das Abspielen als MP3.
.
.TP
.B \-audiofile <Dateiname>
Spielt Audio aus einer externen Datei (WAV, MP3 oder Ogg Vorbis) zu einem
Film ab.
.
.TP
.B \-audiofile-cache <kByte>
Aktiviert das Cachen des von \-audiofile benutzten Streams; benutzt dafür die
angegebene Menge Speicher.
.
.TP
.B \-bandwidth <Wert> (nur bei Netzwerk)
Gibt die maximal zu benutzende Bandbreite für Netzwerkstreaming an (bei
Servern, die Streams in verschiedenen Bitraten senden können).
Nützlich, wenn du Live-Streams über eine langsame Verbindung ansehen
möchtest.
.
.TP
.B \-cache <kbytes>
Diese Option gibt an, wieviel Speicher (in kBytes) MPlayer zum
Precachen einer Datei oder URL benutzt.
Besonders bei langsamen Medien sinnvoll.
.
.TP
.B \-cache-min <Prozent>
Die Wiedergabe startet, wenn der Cache bis zu <Prozent> der Gesamtgröße gefüllt
ist.
.TP
.
.B \-cache-prefill <Prozent> (noch nicht implementiert)
Wenn der Cache leer ist, wird MPlayer pausieren und die Wiedergabe erst dann
fortsetzen, wenn der Wert für die Auffüllung des Caches erreicht ist, die mit
dieser Option gesetzt wird.
.
.TP
.B \-cdda <Option1:Option2> (nur bei CDDA)
Diese Option kann benutzt werden, um die CD-Audio-Auslesefeatures von
MPlayer zu verfeinern.
sp 1
Vorhandene Optionen sind folgende:
.RSs
.IPs speed=<Wert>
Setzt die CD-Umdrehungsgeschwindigkeit.
.IPs paranoia=<0\-2>
Setzt den Paranoia-Wert.
.RSss
0: deaktiviert Fehlererkennung
.br
1: nur Überlappungstest (Standard)
.br
2: komplette Datenkorrektur und -überprüfung
.REss
.IPs generic-dev=<Wert>
Benutzt das angegebene generische SCSI-Gerät.
.IPs sector-size=<Wert>
Setzt die atomare Lesegröße.
.IPs overlap=<Wert>
Erzwingt eine minimal zu durchsuchende Überlappung bei der Datenüberprüfung
von <Wert> Sektoren.
.IPs toc-bias
Nimm an, dass der Startoffset von Spur 1, wie er in der TOC steht, als
LBA\ 0 adressiert wird.
Einige Toshiba-Laufwerke benötigen diese Option, um die Spurgrenzen richtig
zu erkennen.
.IPs toc-offset=<Wert>
Addiere <Wert> Sektoren zu den ermittelten Werten bei der Adressierung
der Spuren.
Kann negativ sein.
.IPs (no)skip
Akzeptiere (niemals) nicht perfekte Datenrekonstruktion.
.RE
.
.TP
.B \-cdrom-device <Pfad\ zum\ Gerät>
Gibt das CD-ROM-Gerät an (Standard: /dev/\:cdrom).
.
.TP
.B \-channels <Anzahl>
Ändere die Anzahl der wiederzugebenden Kanäle (Standard: 2).
Wenn die Anzahl der Ausgabekanäle größer als die Anzahl der Eingangskanäle ist,
dann werden leere Kanäle unter Zuhilfenahme des Audiofilters channels erzeugt
(es sei denn, es wird von Mono zu Stereo erweitert \- dann wird der Mono-Kanal
auf beiden Kanälen wiederholt).
Das Routing wird das Standard-Routing für den Filter channels sein.
Wenn die Anzahl der Eingangskanäle größer als die Anzahl der Ausgabekanäle ist,
dann hängt das Ergebnis vom Audiodecoder (\-afm) ab.
MPlayer weist den Decoder an, den Ton in so viele Kanäle zu decodieren,
wie angegeben wurde.
Dann liegt es am Decoder, diese Anforderung zu erfüllen.
Wenn der Decoder mehr Kanäle als angefordert ausgibt, so werden die
überschüssigen Kanäle abgeschnitten.
Das ist normalerweise nur dann wichtig, wenn Videos mit AC3-Audio abgespielt
werden (wie z.B.\& bei DVDs).
In diesem Fall decodiert normalerweise die liba52 den Ton und sorgt für
einen korrekten Downmix des Audios auf die geforderte Anzahl Kanäle.
.br
.I ANMERKUNG:
.br
Diese Option wird von den Codecs (nur AC3), den Filtern (surround)
und den Audioausgabetreibern (zumindest von OSS) beachtet.
.sp 1
Verfügbare Optionen sind:
.sp 1
.PD 0
.RSs
.IPs 2
Stereo
.IPs 4
Surround
.IPs 6
volles 5.1
.RE
.PD 1
.
.TP
.B \-chapter <Kapitel-ID>[\-<Kapitel-ID\ des\ letzten\ Kapitels>] (nur bei DVD)
Gibt das Kapitel an, ab dem abgespielt werden soll.
Optional kann angegeben werden, nach welchem Kapitel mit dem Abspielen
aufgehört werden soll (Standard: 1).
.
.TP
.B \-cookies (nur bei Netzwerk)
Sende Cookies bei HTTP-Anfragen.
.
.TP
.B \-cookies-file <Dateiname>) (nur bei Netzwerk)
Lies HTTP-Cookies aus <Dateiname> und überspringe die Suche in den
Standardverzeichnissen (Standard: ~/.mozilla/ und ~/.netscape/).
Es wird angenommen, dass die Datei im Netscape-Format vorliegt.
.
.TP
.B \-demuxer <Nummer>
Erzwingt den Demuxertyp.
Gib die Demuxer-ID an wie in libmpdemux/\:demuxer.h definiert.
\-demuxer 17 erzwingt das Abspielen als MP3.
.
.TP
.B \-dumpaudio (nur MPlayer)
Schreibt den unbehandelten, komprimierten Audiostream nach ./\:stream.dump
(mit MPEG/\:AC3 nützlich).
.
.TP
.B \-dumpfile <Dateiname> (nur MPlayer)
Gibt den Dateinamen an, in den MPlayer schreiben soll.
Sollte in Verbindung mit \-dumpaudio / \-dumpvideo / \-dumpstream benutzt
werden.
.
.TP
.B \-dumpstream (nur MPlayer)
Schreibt den unbehandelten Stream nach ./\:stream.dump.
Nützlich, um DVD- oder Netzwerk-Streams zu rippen.
.
.TP
.B \-dumpvideo (nur bei MPlayer)
Schreibt den unbehandelten, komprimierten Videostream nach ./stream.dump
(nicht sehr nützlich).
.
.TP
.B \-dvbin <Optionen> (nur bei DVB)
Übergibt die folgenden Parameter an das DVB-Inputmodul und überschreibt dabei
die Standardeinstellungen:
.sp 1
.PD 0
.RSs
.IPs card=<1\-4>
Benutze Karte 1\-4 (Standard: 1).
.IPs file=<Dateiname>
Weist MPlayer an, die Liste der Kanäle aus <Dateiname> zu lesen (Standard:
~/\:.mplayer/\:channels.conf.{sat,ter,cbl,atsc} (je nach Kartentyp)
oder ~/\:.mplayer/\:channels.conf als letzte Möglichkeit).
.RE
.PD 1
.
.TP
.B \-dvd-device <Pfad\ zum\ Gerät> (nur bei DVD)
Gibt das DVD-Gerät an (Standard: /dev/\:dvd).
Du kannst auch ein Verzeichnis angeben, das die zuvor direkt von DVD kopierten
Dateien enthält (z.B.\& von vobcopy).
Beachte, dass die Benutzung von \-dumpstream normalerweise ein besserer Weg
ist, DVD-Titel zu kopieren (siehe Beispiele).
.
.TP
.B \-dvdangle <Winkel-ID> (nur bei DVD)
Einige DVDs beinhalten Szenen, die aus verschiedenen Perspektiven/\:Winkeln
betrachtet werden können. 
Mit dieser Option kannst du MPlayer bestimmen, welche Perspektive er
wiedergeben soll (Standard: 1).
.
.TP
.B \-edl <Dateiname> (nur bei EDL)
Aktiviert EDL-Aktionen (Edit Decision List) während der Wiedergabe.
Teile des Videos werden entsprechend den Einträgen der angegebenen
Datei übersprungen und Teile des Audios stummgeschaltet.
Siehe DOCS/\:de/\:documentation.html#edl für Details, wie du dieses
Feature benutzen kannst.
.
.TP
.B \-forceidx
Erzwingt Indexgenerierung.
Nützlich für Dateien mit defektem Index (A/\:V-Desynchronisation etc).
Das ermöglicht das Spulen in Dateien, in denen dies vorher nicht möglich war.
Mit MEncoder kann der Index permanent repariert werden (siehe Dokumentation).
.br
.I ANMERKUNG:
Diese Option funktioniert nur, wenn das zugrunde liegende Medium Spulen
unterstützt (z.B.\& nicht bei Standardeingabe, Pipe etc)
.
.TP
.B \-fps <Fließkommazahl>
Überschreibt die Videobildrate.
Nützlich, falls dieser Wert falsch ist oder fehlt.
.
.TP
.B \-frames <Anzahl>
Nur die ersten <Anzahl> Bilder werden wiedergegeben/\:encodiert.
Danach wird MPlayer beendet.
.
.TP
.B \-hr-mp3-seek (nur bei .MP3)
Hi-res mp3-Spulen.
Standardmäßig ist diese Option an, wenn ein externes MP3 abgespielt wird,
da MPlayer an die exakte Position spulen muss, um die A/\:V-Syncronisation
beizubehalten.
Kann langsam sein, vor allem dann, wenn zurückgespult wird, da dann erst
zum Anfang gespult wird, um die genaue Stelle zu finden.
.
.TP
.B \-idx (siehe auch \-forceidx)
Erstellt den Index neu, wenn kein Index gefunden wurde, und ermöglicht somit
Spulen.
Nützlich bei defekten/\:unvollständigen Downloads oder bei schlecht
erstellten Dateien.
.br
.I ANMERKUNG:
Diese Option ist nur nutzbar, wenn das zugrundeliegende Medium spulen
unterstützt (z.B.\& nicht bei Standardeingabe, Pipe usw.)
.
.TP
.B \-ipv4-only-proxy (nur bei Netzwerk)
Überspringt Proxy-Server bei IPv6-Adressen.
Für IPv4-Verbindungen wird er aber benutzt.
.
.TP
.B \-loadidx <Index-Datei>
Die Datei, von der die von \-saveidx gespeicherten Indexdaten für das Video
gelesen werden.
Dieser Index wird zum Spulen benutzt, dabei wird der im AVI enthaltene Index
überschrieben.
MPlayer wird nicht verhindern, dass du einen Index einer anderen AVI-Datei
benutzt, aber dies wird sicherlich zu ungewünschten Resultaten führen.
.br
.I ANMERKUNG:
Diese Option ist veraltet, da MPlayer nun Unterstützung für OpenDML hat.
.
.TP
.B \-mc <Sekunden/\:Bild>
maximale A/\:V-Synchronisationsanpassung pro Bild (in Sekunden)
.
.TP
.B \-mf <Option1:Option2:...>
Wird benutzt, wenn mehrere PNG- oder JPEG-Dateien decodiert werden.
.sp 1
Verfügbare Optionen sind folgende:
.sp 1
.PD 0
.RSs
.IPs w=<Wert>
Ausgabebreite (Standard: automatische Erkennung)
.IPs h=<Wert>
Ausgabehöhe (Standard: automatische Erkennung)
.IPs fps=<Wert>
Frames pro Sekunde bei der Ausgabe (Standard: 25)
.IPs type=<Wert>
Typ der Quelldateien (mögliche Typen sind: jpeg, png, tga, sgi)
.RE
.PD 1
.
.TP
.B \-ni (nur bei AVI)
Erzwingt die Benutzung des nicht-interleaved-AVI-Parsers (was die Wiedergabe
einiger schlecht erstellter AVIs ermöglicht).
.
.TP
.B \-nobps (nur bei AVI)
Benutze nicht den durchschnittlichen Bytes/\:Sekunde-Wert für die
A/\:V-Synchronisation.
Hilft bei einigen AVIs mit defektem Header.
.
.TP
.B \-noextbased
Deaktiviert die auf Dateinamenserweiterungen basierende Demultiplexerauswahl.
Wenn der Dateityp (und damit der Demultiplexer) nicht zweifelsfrei
festgestellt werden kann (z.B. wenn die Datei keinen Header besitzt
oder dieser nicht zuverlässig genug ist), dann wird normalerweise ein
Demultiplexer anhand der Dateiendung gewählt.
Die inhaltsbasierte Demultiplexerauswahl wird bei Problemen immer
vorgenommen.
.
.TP
.B \-passwd <Passwort> (siehe auch \-user) (nur bei Netzwerk)
Gibt das Passwort für die HTTP-Authentifizierung an.
.
.TP
.B \-prefer-ipv4 (nur bei Netzwerk)
Benutzt IPv4 bei Netzwerkverbindungen.
Greift automatisch auf IPv6-Verbindungen zurück.
.
.TP
.B \-prefer-ipv6 (nur bei IPv6-Netzwerk)
Benutzt IPv6 bei Netzwerkverbindungen.
Greift automatisch auf IPv4-Verbindungen zurück.
.
.TP
.B \-rawaudio <Option1:Option2:...>
Mit dieser Option können raw-Audiodateien abgespielt werden.
Sie kann auch verwendet werden, um Audio-CDs abzuspielen, die nicht mit 44KHz
16Bit stereo aufgenommen wurden.
Zum Abspielen von RAW-AC3-Streams benutze \-rawaudio on:format=0x2000.
.sp 1
Verfügbare Optionen sind folgende:
.sp 1
.PD 0
.RSs
.IPs on\ \ \ 
Benutze den Raw-Audio-Demuxer.
.IPs channels=<Wert>
Anzahl der Kanäle
.IPs rate=<Wert>
Rate in Samples pro Sekunde
.IPs samplesize=<Wert>
Sample-Größe in Bytes
.IPs format=<Wert>
FourCC als Hexadezimalwert
.RE
.PD 1
.
.TP
.B \-rawvideo <option1:option2:...>
Mit dieser Option kannst du Dateien abspielen, die nur aus Videodaten bestehen.
.sp 1
Verfügbare Optionen sind folgende:
.sp 1
.PD 0
.RSs
.IPs on\ \ \ 
benutze den Raw-Video-Demuxer
.IPs fps=<Wert>
Anzahl der Bilder pro Sekunde (Standard: 25.0)
.IPs sqcif|qcif|cif|4cif|pal|ntsc
setzt die Standardbildgröße
.IPs w=<Wert>
Bildbreite in Pixeln
.IPs h=<Wert>
Bildhöhe in Pixeln
.IPs i420|yv12|yuy2|y8
wählt den Farbraum
.IPs format=<Wert>
Farbraum (FourCC) als Hexadezimalwert
.IPs size=<Wert>
Bildgröße in Bytes
.RE
.PD 1
.
.TP
.B \-rtsp-stream-over-tcp (nur bei LIVE.COM)
Kann zusammen mit 'rtsp://'-URLs verwendet werden, um anzugeben, dass die
daraus resultierenden eingehenden RTP- und RTCP-Pakete per TCP 
übertragen werden (mit der gleichen TCP-Verbindung wie RTSP). 
Diese Option kann hilfreich sein, wenn deine Internetverbindung eingehende
UDP-Pakete nicht durchlässt (siehe http://www.live.com/\:mplayer/).
.
.TP
.B \-saveidx <Dateiname>
Erzwingt Neugenerierung des Index und schreibt den Index in <Dateiname>.
Funktioniert momentan nur mit AVI-Dateien.
.br
.I ANMERKUNG:
Diese Option ist veraltet, da MPlayer nun OpenDML unterstützt.
.
.TP
.B \-sb <Byte-Position> (siehe auch \-ss)
Springt an die Byte-Position.
Nützlich beim Abspielen von CD-ROM-Abbildern / .VOB-Dateien mit Schrott
am Anfang.
.
.TP
.B \-speed <0.01\-100>
Erhöht oder verringert die Abspielgeschwindigkeit abhängig vom angegebenen
Faktor.
Es wird nicht garantiert, dass diese Option zusammen mit \-ovc copy
funktioniert.
.
.TP
.B \-srate <Hz>
Erzwingt eine zu benutzende Audioabspielrate (natürlich haben Soundkarten
diesbezüglich Beschränkungen).
Falls die gewählte Samplefrequenz verschieden von der des aktuellen Mediums
ist, wird der resample oder lavcresample Audiofilter in die Audiofilterschicht
eingefügt, um den Unterschied auszugleichen.
Der Resampling-Typ kann mit der Option \-af-adv gesteuert werden.
Standard ist ein schnelles Resampling, das Störungen verursachen kann.
.
.TP
.B \-ss <Zeit> (siehe auch \-sb)
Springt zu der angegebenen Zeitposition.
.sp 1
.I BEISPIELE:
.PD 0
.RSs
.IPs "\-ss 56"
Springt zu 56 Sekunden.
.IPs "\-ss 01:10:00"
Springt zu 1 Stunde 10 Minuten.
.RE
.PD 1
.
.TP
.B \-tskeepbroken 
Sorgt dafür, daß MPlayer solche TS-Pakete, die als unbrauchbar markiert wurden,
nicht ignoriert.
Diese Option wird manchmal gebraucht, um korrupte MPEG-TS-Dateien abzuspielen.
.
.TP
.B \-tsprobe <Byte-Position>
Beim Abspielen eines MPEG-TS-Streams kannst du mit dieser Option auswählen,
wie viele Bytes MPlayer nach den gewünschten Program-IDs durchsuchen soll.
.
.TP
.B \-tsprog <1\-65534>
Beim Abspielen eines MPEG-TS-Streams kann mit dieser Option ausgewählt werden,
welches Programm (falls vorhanden) abgespielt werden soll.
Kann in Verbindung mit \-vid und \-aid benutzt werden.
.
.TP
.B \-tv <Option1:Option2:...> (nur bei TV)
Diese Option steuert verschiedene Einstellungen des TV-Empfang-Moduls.
Um mit MPlayer fernzusehen, benutze die Optionen 'tv://'
oder 'tv://<Kanalnummer>' oder sogar 'tv://Kanalname' (siehe unten die
Option 'channels' für die Kanalnamen) als Film-URL.
.sp 1
Verfügbare Optionen:
.RSs
.IPs noaudio
kein Sound
.IPs driver=<Wert>
mögliche Werte: dummy, v4l, v4l2, bsdbt848
.IPs device=<Wert>
Gibt ein anderes Videogerät als /dev/\:video0 an.
.IPs input=<Wert>
Gibt einen anderen Eingang als den Standardeingang 0 (Television)
an (such in der Ausgabe nach einer Liste)
.IPs freq=<Wert>
Gibt die Frequenz an, auf die der Tuner gesetzt wird (z.B.\& 511.250).
Kann nicht zusammen mit 'channels' benutzt werden.
.IPs outfmt=<Wert>
Gibt das Ausgabeformat des Tuners mit einer Voreinstellung des
V4L-Treibers (yv12, rgb32, rgb24, rgb16, rgb15, uyvy, yuy2, i420) oder ein
frei wählbares Format als hexadezimalen Wert an.
.IPs width=<Wert>
Breite des Ausgabefensters
.IPs height=<Wert>
Höhe des Ausgabefensters
.IPs fps=<Wert>
Bildanzahl, mit der Video aufgenommen wird (Bilder pro Sekunde, frames per
second).
.IPs buffersize=<Wert>
Maximalgröße des Capture-Puffers in Megabytes (standardmäßig: dynamische
Größe)
.IPs norm=<Wert>
Für bsdbt848 and v4l sind die Normen PAL, SECAM und NTSC verfügbar.
Für v4l2, siehe Option normid und die Ausgabe von MPlayer für eine Liste der
verfügbaren TV-Normen.
.IPs "normid=<ID> (nur bei V4L2)"
Setzt die TV-Norm auf die angegebene ID.
Die TV-Norm hängt von der Videokarte ab. 
Siehe MPlayer-Output für eine Liste der verfügbaren TV-Normen.
.IPs channel=<Wert>
Setzt den Tuner auf Kanal <Wert>.
.IPs chanlist=<Wert>
Werte: europe-east, europe-west, us-bcast, us-cable, etc
.IPs channels=<Kanal>\-<Name>,<Kanal>\-<Name>,...
Setzt Namen für Kanäle. 
Benutze '_' anstelle von Leerzeichen bei Namen (oder spiel mit der
Shellquotierung rum ;-).
Die Sendernamen werden dann per OSD angezeigt, und die Slave-Kommandos
tv_step_channel, tv_set_channel und tv_last_channel werden per
Fernbedienung benutzbar sein (siehe LIRC).
Kann nicht zusammen mit dem frequency\-Parameter benutzt werden.
.br
.I ANMERKUNG:
Die Sendernummer wird dann die Position des Eintrags in 
der 'channels'-Liste sein, wobei der erste Eintrag die 1 bekommt.
.br
.I BEISPIEL:
tv://1, tv://TV1, tv_set_channel 1, tv_set_channel TV1
.IPs [brightness|contrast|hue|saturation]=<-100\-100>
Setzt Werte des Bild-Equaliziers der Karte.
.IPs audiorate=<Werte>
Setzt die Audiobitrate für's Capturen.
.IPs forceaudio
Capture auch dann Audio, wenn v4l keine Audioquellen zurückmeldet.
.IPs alsa
Benutze ALSA zum Capturen.
.IPs amode=<0\-3>
Wählt einen Audiomodus:
.RSss
0: mono
.br
1: stereo
.br
2: Sprache 1
.br
3: Sprache 2
.REss
.IPs forcechan=<1\-2>
Normalerweise wird die Anzahl der aufgenommenen Audiokanäle automatisch
durch Ermitteln des Audiomodus der TV-Karte festgelegt.
Mit dieser Option kann Mono/\:Stereo unabhängig von dem von V4L
zurückgegebenen Audiomodus erzwungen werden.
Kann benutzt werden, wenn die TV-Karte den aktuellen Audiomodus nicht
zurückgeben kann.
.IPs adevice=<Wert>
Setzt das Audiogerät.
<Wert> sollte /dev/\:xxx bei OSS und eine Hardware-ID bei ALSA sein.
Du musst in der Hardware-ID von ALSA jedes ':' durch ein '.' ersetzen.
.IPs audioid=<Wert>
Wählt einen Audioausgang der TV-Karte, wenn diese mehrere hat.
.IPs "[volume|bass|treble|balance]=<0\-65535> v4l1"
.IPs "[volume|bass|treble|balance]=<0\-100> v4l2"
Diese Optionen setzen Parameter des Mixers auf der Capture-Karte.
Sie haben keinen Effekt, wenn deine Karte keinen Mixer hat.
Bei V4L2 geht der gültige Bereich von 0 bis 100, und 50 steht für den vom
Treiber angegebenen Default-Wert.
.IPs immediatemode=<Boolean>
Ein Wert von 0 bedeutet: Nimm Audio und Video zusammen in einem Puffer auf
(Standardwert für MEncoder).
Ein Wert von 1 bedeutet: Nimm nur Video direkt von der Karte und Audio
über ein externes Kabel von der TV-Karte zur Soundkarte auf (Standardwert
für MPlayer).
.IPs mjpeg
Benutzte Hardware-MJPEG-Kompression (wenn dies die Karte unterstützt). 
Bei dieser Option mußt du Breite und Höhe des Ausgabefensters nicht
angeben, denn MPlayer ermittelt diese Werte automatisch vom
Dezimierungswert (siehe unten).
.IPs decimation=<1|2|4>
Wählt die Bildgröße für die Hardware-MJPEG-Kompression:
.RSss
1: volle Größe
    704x576    PAL
    704x480    NTSC
.br
2: mittlere Größe
    352x288    PAL
    352x240    NTSC
.br
4: kleine Größe
    176x144    PAL
    176x120    NTSC
.REss
.IPs quality=<0\-100>
Wählt die Qualität der JPEG-Kompression.
(< 60 für volle Größe empfohlen)
.RE
.
.TP
.B \-user <Benutzername> (siehe auch \-passwd) (nur bei Netzwerk)
Gibt den Benutzernamen für die HTTP-Authentifizierung an.
.
.TP
.B \-user-agent <Zeichenkette>
Benutze Zeichenkette als User-Agent beim HTTP-Streaming.
.
.TP
.B \-vid <ID>
Wählt die Videospur (MPG: 0\-15 ASF: 0\-255 MPEG-TS: 17\-8190).
Beim Abspielen von MPEG-TS-Streams benutzt MPlayer/\:MEncoder das erste
Programm (falls vorhanden) mit dem gewählten Video-Stream.
.
.TP
.B \-vivo <sub\-Optionen> (DEBUG\-CODE)
Erzwingt Audioparameter für den VIVO-Demuxer (nur für Debugging-Zwecke).
.
.
.
.SH "OSD-/\:UNTERTITEL-OPTIONEN"
.I ANMERKUNG:
Siehe auch \-vf expand.
.
.TP
.B \-dumpjacosub (nur bei MPlayer)
Konvertiert die mit der \-sub-Option angegebenen Untertitel in das
zeitbasierende JACOsub-Format.
Erstellt eine Datei dumpsub.js im aktuellen Verzeichnis.
.
.TP
.B \-dumpmicrodvdsub (nur bei MPlayer)
Konvertiert die mit der \-sub-Option angegebenen Untertitel in das
MicroDVD-Format.
Erstellt eine Datei dumpsub.sub im aktuellen Verzeichnis.
.
.TP
.B \-dumpmpsub (nur bei MPlayer)
Konvertiert die mit der \-sub-Option angegebenen Untertitel in das
MPlayer-Format MPsub.
Erstellt eine Datei dump.mpsub im aktuellen Verzeichnis.
.
.TP
.B \-dumpsami (MPlayer only)
Konvertiert die mit der \-sub-Option angegebenen Untertitel in das
zeitbasierende SAMI-Format.
Erstellt eine Datei dumpsub.smi im aktuellen Verzeichnis.
.
.TP
.B \-dumpsrtsub (nur bei MPlayer)
Konvertiert die mit der \-sub-Option angegebenen Untertitel in das
zeitbasierende SubViewer-Format (SRT).
Erstellt eine Datei dumpsub.srt im aktuellen Verzeichnis.
.
.TP
.B \-dumpsub (nur bei MPlayer) (BETA\-CODE)
Speichert den Untertitel-Substream eines VOB-Streams.
Siehe auch -dump*sub und -vobsubout*.
.
.TP
.B \-ffactor <Nummer> (nur bei OSD)
Resamplet die Alpha-Matrix der Schrift.
Mögliche Werte:
.PD 0
.RSs
.IPs 0\ \ \ \ 
komplett weiße Schrift
.IPs 0.75\ \ 
sehr dünner schwarzer Umriss (Standard)
.IPs 1\ \ \ \ 
dünner schwarzer Umriss
.IPs 10\ \ \ 
dicker schwarzer Umriss
.RE
.PD 1
.
.TP
.B \-flip-hebrew (nur bei FriBiDi)
Schaltet horizontales Spiegeln der Untertitel ein.
Benutzt dazu FriBiDi.
.
.TP
.B \-noflip-hebrew-commas
Ändere die Annahmen von FriBiDi über die Positionierung von Kommata in
Untertiteln.
Benutze dies, falls Kommata in Untertiteln am Anfang eines Satzes anstatt am
Ende angezeigt werden.
.TP
.B \-font <Pfad\ zur\ font.desc-Datei> (nur bei OSD)
Sucht nach den OSD-/\:Untertitelschriften in einem anderen Verzeichnis
(Standard für normale Schriften: ~/\:.mplayer/\:font/\:font.desc,
Standard für FreeType\-Schriften: ~/.mplayer/\:subfont.ttf).
.br
.I ANMERKUNG:
Bei FreeType gibt diese Option den Pfad zur Textschriftdatei an.
Bei fontconfig gibt diese Option den fontconfig-Schriftnamen an.
.sp 1
.I BEISPIELE:
.PD 0
.RSs
\-font ~/\:.mplayer/\:arial\-14/\:font.desc
.br
\-font ~/\:.mplayer/\:arialuni.ttf
.br
\-font 'Bitstream Vera Sans'
.RE
.PD 1
.
.TP
.B \-fontconfig (nur bei fontconfig)
Ermöglicht die Benutzung von Schriften, die von fontconfig verwaltet werden.
.
.TP
.B \-forcedsubsonly
Nur "erzwungene" DVD-Untertitel in der z.B.\& mit \-slang gewähten Sprache
darstellen.
.
.TP
.B \-fribidi-charset <Zeichensatzname> (nur bei FriBiDi)
Gibt den Zeichensatz an, der an FriBiDi übergeben wird, wenn Untertitel
dekodiert werden, die nicht im UTF8-Format sind (Standard: ISO8859-8).
.
.TP
.B \-ifo <VOBsub\ IFO-Datei>
Gibt die Datei an, aus der MPlayer die Palette und die Framegröße für
VOBsub-Untertitel lädt.
.
.TP
.B \-noautosub
Deaktiviert das automatische Laden von Untertiteln.
.
.TP
.B \-osdlevel <0\-3> (nur bei MPlayer)
Gibt den Modus an, in dem das OSD startet:
.PD 0
.RSs
.IPs 0
nur Untertitel
.IPs 1
Lautstärkeleiste und Positionsanzeige (Standard)
.IPs 2
Lautstärkeleiste, Positionsanzeige und prozentuale Dateiposition
.IPs 3
Lautstärkeleiste, Positionsanzeige, prozentuale Dateiposition und
Gesamtzeit
.RE
.PD 1
.
.TP
.B \-overlapsub
Erlaubt die Anzeige des nächsten Untertitels, während der aktuelle noch
sichtbar ist.
Standard ist, diese Unterstützung nur bei bestimmten Formaten zu
aktivieren.
.
.TP
.B \-sid <id> (siehe auch \-slang)
Zeigt den Untertitelstream an, der durch <ID> (0\-31) angegeben wird.
Eine Liste der verfügbaren Untertitel-IDs erhältst du bei der Verwendung
der Option \-v.
.
.TP
.B \-slang <Sprachcode[,Sprachcode,...]> (siehe auch \-sid)
Gibt eine Prioritätenliste von zu benutzenden Untertitelsprachen an.
Verschiedene Containerformate verwenden unterschiedliche Sprachcodes.
DVDs benutzen ISO 639-1-Sprachcodes mit zwei Buchstaben, Matroska verwendet 
ISO 639-2-Sprachcodes mit drei Buchstaben, während OGM einen formfreien
Bezeichner gebraucht.
Die verfügbaren Untertitelsprachen erhältst du bei der Verwendung
der Option \-v.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "mplayer dvd://1 \-slang hu,en"
Wählt den ungarischen Untertitel einer DVD und verwendet die englischen
Untertitel, wenn es keine ungarischen gibt.
.IPs "mplayer \-slang jpn example.mkv"
Spielt eine Matroskadatei mit japanischen Untertiteln ab.
.RE
.PD 1
.
.TP
.B \-spuaa <Modus> (nur bei OSD)
Antialiasing-/\:Skalierungsmodus für DVD/\:VOBsub.
Ein Wert von 16 kann zu <Modus> hinzuaddiert werden, um die Skalierung auch
dann zu erzwingen, wenn das Orignalbild und das skalierte Bild bereits die
gleiche Größe haben, um z.B.\& auch dann die Untertitel mit einem Gaußschen
Unschärfefilter zu glätten.
Die verfügbaren Modi lauten:
.PD 0
.RSs
.IPs 0
nix (am schnellsten, sehr hässlich)
.IPs 1
Approximation (kaputt?)
.IPs 2
komplett (langsam)
.IPs 3
bilinear (Standard, schnell und nicht zu übel)
.IPs 4
benutzt Gaußsche Unschärfe des Softwareskalierers (sieht sehr gut aus)
.RE
.PD 1
.
.TP
.B \-spualign <-1\-2> (nur bei OSD)
Gibt an, wie SPU-Untertitel (DVD/\:VOBsub) positioniert werden sollen.
.PD 0
.RSs
.IPs "-1"
Originalposition
.IPs " 0"
oben positionieren (Standard)
.IPs " 1"
mittig positionieren
.IPs " 2"
unten positionieren
.RE
.PD 1
.
.TP
.B \-spugauss <0.0\-3.0> (nur bei OSD)
Varianzparameter des Gaußschen Weichzeichners bei Benutzung von \-spuaa 4.
Höhere Werte stehen für stärkere Weichzeichnung (Standard: 1.0).
.
.TP
.B \-sub <Untertiteldatei1, Untertiteldatei2,...>
Diese Untertitel werden benutzt/\:angezeigt.
Nur ein Untertitel kann zu einer Zeit angezeigt werden.
.
.TP
.B \-sub-bg-alpha <0\-255>
Gibt an, wie transparent der Alphakanal bei Untertiteln und dem OSD ist.
Große Werte bedeuten mehr Transparenz.
Der Wert 0 ist eine Ausnahme und bedeutet 'vollständig transparent'.
.
.TP
.B \-sub-bg-color <0\-255>
Gibt den Farbwert für Untertitel und den OSD-Hintergrund an.
Momentan werden Untertitel nur in Graustufen dargestellt, so dass dieser
Wert äquivalent zur Farbintensität ist.
Der Wert 255 steht für weiß und 0 für schwarz.
.
.TP
.B \-sub-demuxer <Nummer> (nur mit \-subfile-Option) (BETA CODE)
Erzwinge Untertitel-Demuxertyp für \-subfile.
Gib die Demuxer ID wie in subreader.h definiert an.
.
.TP
.B \-sub-fuzziness <Modus>
Passe die Unschärfe für die Suche nach Untertiteln an:
.PD 0
.RSs
.IPs 0
exakter Treffer
.IPs 1
Lade alle Untertitel, die den Filmnamen enthalten
.IPs 2
Lade alle Untertitel im aktuellen Verzeichnis
.RE
.PD 1
.
.TP
.B \-sub-no-text-pp
Deaktiviert Text-Postprocessing jeder Art nach dem Laden der Untertitel.
Wird für Debugging-Zwecke verwendet.
.
.TP
.B \-subalign <0\-2> (nur bei OSD)
Gibt an, wie die Untertitel mit \-subpos positioniert werden sollen.
.PD 0
.RSs
.IPs 0
Positioniere oben (Standard).
.IPs 1
Positioniere mittig.
.IPs 2
Positioniere unten.
.RE
.PD 1
.
.TP
.B \-subcc \ 
Zeigt DVD-Closed-Caption-Untertitel an (CC).
Diese sind KEINE VOB-Untertitel. Hierbei handelt es sich um spezielle
ASCII-Untertitel für Hörgeschädigte, die in VOB-Userdatenstreams auf
den meisten Region-1-DVDs zu finden sind.
CC-Untertitel wurden bisher nicht auf DVDs für andere Regionen gefunden.
.
.TP
.B \-subcp <Codepage> (nur bei iconv)
Wenn dein System iconv(3) unterstützt, so kannst du mit dieser Option
die Codepage für die Untertitel angeben.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
\-subcp latin2
.br
\-subcp cp1250
.RE
.PD 1
.
.TP
.B \-subcp enca:<Sprache>:<alternative Codepage> (nur bei ENCA)
Du kannst eine Sprache im 2-Zeichen-Sprachcode angeben, um ENCA automatisch
eine Codepage wählen zu lassen.
Wenn du nicht sicher bist, gib irgendetwas ein und sieh dir die Ausgaben von
mplayer \-v an, um die verfügbaren Sprachen zu sehen.
Die alternative Codepage gibt die zu benutzende Codepage an, falls die
automatische Erkennung versagt.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-subcp enca:cs:latin2"
Nimm an, die Untertitel seien Tschechisch, und rate die Kodierung.
Wenn die Erkennung versagt, benutze latin2.
.IPs "\-subcp enca:pl:cp1250"
Rate die Kodierung für Polnisch, benutze sonst cp1250.
.RE
.PD 1
.
.TP
.B \-subdelay <sek>
Verzögert die Untertitel um <sek> Sekunden.
Kann negativ sein.
.
.TP
.B \-subfile <Dateiname> (BETA CODE)
Zur Zeit unbrauchbar.
Das gleiche wie \-audiofile, jedoch für Untertitel-Streams (OGGDS?).
.
.TP
.B \-subfont-autoscale <0\-3> (nur bei FreeType)
Setzt den Modus für automatische Skalierung der Untertitel.
.br
.I ANMERKUNG:
Null bedeutet, dass text-scale und osd-scale Schrifthöhen in Punkten sind.
.sp 1
Der Modus kann folgende Werte annehmen:
.sp 1
.PD 0
.RSs
.IPs 0
keine automatische Skalierung
.IPs 1
proportional zur Höhe des Films
.IPs 2
proportional zur Breite des Films
.IPs 3
proportional zur Diagonale des Films (Standard)
.RE
.PD 1
.
.TP
.B \-subfont-blur <0\-8> (nur bei FreeType)
Setzt den Verwischradius für die Schriften (Standard: 2).
.
.TP
.B \-subfont-encoding <Wert> (nur bei FreeType)
Setzt die Schriftcodierung.
Wenn 'unicode' angegeben wird, so werden alle Zeichen der Schriftdatei
gerendert, und unicode wird benutzt werden (Standard: unicode).
.
.TP
.B \-subfont-osd-scale <0\-100> (nur bei FreeType)
Setzt den Koeffizienten für die automatische Skalierung der OSD-Elemente
(Standard: 6).
.
.TP
.B \-subfont-outline <0\-8> (nur bei FreeType)
Setzt die Schriftumrissstärke (Standard: 2).
.
.TP
.B \-subfont-text-scale <0\-100> (nur bei FreeType)
Setzt den Koeffizienten für die automatische Skalierung der Untertitel
(prozentualer Anteil der Anzeigegröße) (Standard: 5).
.
.TP
.B \-subfps <Rate>
Gibt die Bilder/\:Sekunde-Rate der Untertitel an (Fließkommazahl).
Standard ist die gleiche FPS wie der Film.
.br
.I ANMERKUNG:
Funktioniert nur bei bildbasierten Untertitelformaten wie z.B.\& dem
MicroDVD-Format.
.
.TP
.B \-subpos <0\-100> (nützlich mit \-vf expand) (nur bei OSD)
Gibt die Position der Untertitel auf dem Bildschirm an.
Der Wert gibt die vertikale Position der Untertitel in % der Anzeigehöhe an.
.
.TP
.B \-subwidth <10\-100> (nur bei OSD)
Gibt die maximale Breite der Untertitel an.
Nützlich für Ausgabe auf dem Fernseher.
Der Wert ist die Breite in %  der Bildschirmbreite.
.
.TP
.B \-unicode
Sagt MPlayer, dass er die Untertitel als Unicode behandeln soll.
.
.TP
.B \-utf8 \ \ 
Sagt MPlayer, dass er die Untertitel als UTF-8 behandeln soll.
.
.TP
.B \-vobsub <VOBsub-Datei ohne Erweiterung>
Gibt die VOBsub-Dateien an, die als Untertitel angezeigt werden sollen.
Angegeben wird der volle Pfadname ohne Erweiterung, z.B.\& ohne '.idx',
\'.ifo' oder '.sub'.
.
.TP
.B \-vobsubid <0\-31>
Gibt die ID für die VOBsub-Untertitel an.
.
.
.
.SH "OPTIONEN FÜR DIE AUDIOAUSGABE (NUR BEI MPLAYER)"
.
.TP
.B \-abs <Wert> (nur bei \-ao oss) (VERALTET)
Überschreibt die automatisch erkannte Puffergröße der Audiotreiber/\:-karte.
.
.TP
.B \-delay <Sek>
Audioverzögerung in Sekunden (positive oder negative Fließkommazahl).
.
.TP
.B \-format <Format> (siehe auch format Audiofilter)
Wählt das Sampleformat, das für die Ausgabe der Filterschicht zur Soundkarte
verwendet wird.
Die Werte, die <Format> annehmen kann, stehen unten in der Beschreibung
des format Audiofilters.
.
.TP
.B \-mixer <Gerät>
Benutze einen anderen Mixer als den Standardmixer /dev/\:mixer.
Bei ALSA gibt dies den Mixer-Namen an.
.
.TP
.B \-mixer-channel <Mixer-Anschluß>[,Mixer-Index] <nur bei \-ao oss und \-ao
alsa)
Bei dieser Option benutzt MPlayer zur Lautstärkeregulierung einen anderen
Anschluß als die Standardeinstellung PCM.
Optionen für OSS beinhalten
.B vol, pcm, line.
Für eine komplette Liste der Optionen suche nach SOUND_DEVICE_NAMES in der
Datei /usr/\:include/\:linux/\:soundcard.h.
Bei ALSA kannst du die Namen benutzen, die beispielsweise alsamixer anzeigt,
wie
.B Master, Line, PCM.
.br
.I ANMERKUNG:
Die Namen von ALSA-Mixerkanälen gefolgt von einer Nummer müssen im Format
<Name,Nummer> angegeben werden, z.B.\& muß ein Kanal, der im alsamixer 'PCM 1'
heißt, umbenannt werden in
.BR PCM,1 .
.TP
.B \-softvol
Erzwingt den Gebrauch des Softwaremixers anstelle des Mixers der Soundkarte.
.
.TP
.B \-volstep <0\-100>
Setzt die Schrittweite der Mixer-Lautstärkeänderungen in Prozent der
Gesamtweite (Standard: 3).
.
.
.
.SH "AUDIOAUSGABETREIBER (NUR BEI MPLAYER)"
.
Audioausgabetreiber sind Schnittstellen zu verschiedenen Ausgabeeinrichtungen.
Die Syntax ist folgende:
.TP
.B \-ao <Treiber1[:Suboption[=Wert]:...],Treiber2,...[,]>
Gibt eine Prioritätenliste der zu benutzenden Audiotreiber an.
.PP
Wenn die Liste mit ',' endet, so werden notfalls auch nicht in der
Kommandozeile aufgeführte Treiber benutzt.
Suboptionen sind optional und können meistens weggelassen werden.
.br
.I ANMERKUNG:
Eine Liste der eincompilierten Audiotreiber erhälst du mit \-ao help.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-ao alsa,oss,"
Probiere den ALSA-Treiber, dann den OSS-Treiber, dann andere.
.IPs "\-ao alsa:mmap:noblock:device=hw=0.3"
Setzt den noblock-Modus, mmap-Modus und den Gerätenamen auf erste Karte,
viertes Gerät.
.RE
.PD 1
.sp 1
Verfügbare Audioausgabetreiber sind folgende:
.
.TP
.B alsa\ \ \ 
ALSA 0.9/\:1.x Audioausgabetreiber.
.PD 0
.RSs
.IPs mmap\ \ \ 
Setzt den experimentellen mmap-Modus (funktioniert nicht für mehr als zwei
Kanäle).
.IPs noblock
Setzt den noblock-Modus.
.IPs device=<Gerät>
Setzt den Gerätenamen.
Ersetze jedes ',' mit '.' und jeden ':' mit '=' im ALSA-Gerätenamen.
Setze diese Option nicht, wenn du hwac3-Ausgabe über S/PDIF wünschst, es sei
denn, du weißt wirklich, wie sie gesetzt werden muß.
.RE
.PD 1
.
.TP
.B alsa5\ \ 
ALSA 0.5 Audioausgabetreiber.
.
.TP
.B oss\ \ \ \ 
OSS Audioausgabetreiber.
.PD 0
.RSs
.IPs dsp-device
Setzt das Audioausgabegerät (Standard: /dev/\:dsp).
.RE
.PD 1
.
.TP
.B sdl\ \ \ \ 
Audioausgabetreiber der größtenteils plattformunabhängigen SDL (Simple
Directmedia Layer) Bibliothek.
.PD 0
.RSs
.IPs <Treiber>
Wähle den SDL-Audioausgabetreiber explizit (Standard: lasse SDL wählen).
.RE
.PD 1
.
.TP
.B arts\ \ \ 
Audioausgabe über den Arts-Daemon.
.
.TP
.B esd\ \ \ \ 
Audioausgabe über den ESD-Daemon.
.PD 0
.RSs
.IPs <Server>
Wähle den zu benutzenden ESD-Server explizit (Standard: localhost).
.RE
.PD 1
.
.TP
.B jack\ \ \ \ 
Audioausgabe über JACK (Jack Audio Connection Kit).
.
.TP
.B nas\ \ \ \ 
Audioausgabe über NAS.
.
.TP
.B macosx (nur bei Mac OS X)
Nativer Mac OS X-Audioausgabetreiber.
.
.TP
.B sgi (nur bei SGI)
Nativer SGI-Audioausgabetreiber.
.
.TP
.B sun (nur bei Sun)
Nativer Sun-Audioausgabetreiber.
.PD 0
.RSs
.IPs <Gerät>
Wähle das zu benutzende Audiogerät explizit (Standard: /dev/\:audio).
.RE
.PD 1
.
.TP
.B win32 (nur bei Windows)
Nativer Windows-Waveout-Audioausgabetreiber.
.
.TP
.B dsound (nur bei Windows)
DirectX-Audioausgabetreiber DirectSound.
.PD 0
.RSs
.IPs device=<Gerätenummer>
Setzt das zu benutzende Gerät.
Wenn du eine Datei mit \-v abspielst, wird dir eine Liste aller verfügbaren
Geräte angezeigt.
.RE
.PD 1
.
.TP
.B dxr2 (siehe auch \-dxr2) (nur bei DXR2)
Creative DXR2-spezifischer Ausgabetreiber.
.
.TP
.B mpegpes (nur bei DVB)
DVB-spezifischer Ausgabetreiber.
.
.TP
.B null\ \ \ 
Produziert keine Audioausgabe, behält aber die Videoabspielgeschwindigkeit bei.
Benutze \-nosound für Benchmarking-Zwecke.
.
.TP
.B pcm\ \ \ \ 
Filewriter-Audioausgabe im raw-PCM/\:Wave-Format.
.PD 0
.RSs
.IPs (no)waveheader
Fügt den Wave-Header (nicht) hinzu (Standard: hinzugefügt).
Wird er nicht hinzugefügt, erfolgt die Ausgabe als raw-PCM.
.IPs file=<Dateiname>
Schreibe den Sound nach <Dateiname> und nicht in die Standarddatei
audiodump.wav.
Wurde nowaveheader angegeben, ist der Standard audiodump.pcm.
.RE
.PD 1
.
.TP
.B plugin\ \ 
Plugin-Audioausgabetreiber.
.
.
.
.SH "OPTIONEN FÜR DIE VIDEOAUSGABE (NUR BEI MPLAYER)"
.
.TP
.B \-adapter <Wert>
Bestimmt die Grafikkarte, die das Bild erhalten wird.
Benötigt die \-vm-Option, um zu funktionieren.
Du bekommst eine Liste aller verfügbaren Karten, wenn du diese Option mit \-v
aufrufst.
Funktioniert momentan nur mit \-vo directx.
.
.TP
.B \-bpp <Farbtiefe>
Überschreibt die automatisch erkannte Farbtiefe.
Wird nur von fbdev-, dga2-, svga- und vesa-Ausgabetreibern unterstützt.
.
.TP
.B \-brightness <-100\-100>
Passt die Helligkeit der Videoausgabe an (Standard: 0).
Wird nicht von allen Videoausgabetreibern unterstützt
.
.TP
.B \-contrast <-100\-100>
Passt den Kontrast der Videoausgabe an (Standard: 0).
Wird nicht von allen Videoausgabetreibern unterstützt.
.
.TP
.B \-dfbopts <Wert> (nur mit \-vo directfb)
Gibt eine Parameterliste für den directfb-Videoausgabetreiber an.
.
.TP
.B \-display <Name> (nur bei X11)
Gibt den Rechnernamen und die Anzeigenummer des X-Servers an, auf dem
die Anzeige erscheinen soll.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
\-display xtest.localdomain:0
.RE
.PD 1
.
.TP
.B \-dr \ \ \ 
Schaltet direktes Rendern an (wird nicht von allen Codecs und
Videoausgabetreibern unterstützt).
.br
.I WARNUNG:
Kann zu Störungen beim OSD oder bei den Untertiteln führen!
.
.TP
.B \-dxr2 <option1:option2:...>
Mit dieser Option wird der dxr2-Videoausgabetreiber gesteuert.
.RSs
.IPs ar-mode=<Wert>
Modus für die Anpassung des Höhen-/Breitenverhältnisses (0 = normal,
1 = Panscan, 2 = letterbox (Standard))
.IPs iec958-encoded
Setzt den iec958-Ausgabemodus auf 'encoded'.
.IPs iec958-decoded
Setzt den iec958-Ausgabemodus auf 'decoded' (Standard).
.IPs macrovision=<Wert>
Macrovision-Modus (0 = aus (Standard), 1 = agc, 2 = agc 2 colorstripe,
3 = agc 4 colorstripe)
.IPs mute\
Stummschalten der Soundausgabe
.IPs unmute
Ausschalten der Stummschaltung der Soundausgabe
.IPs ucode=<Wert>
Pfad zum Microcode
.RE
.RS
.sp 1
.I TV-Ausgabe
.RE
.RSs
.IPs 75ire
Schaltet den 7.5 IRE-Ausgabemodus an.
.IPs no75ire
Schaltet den 7.5 IRE-Ausgabemodus ab (Standard).
.IPs bw\ \ \ 
TV-Ausgabe in Schwarz/\:Weiß 
.IPs color
TV-Ausgabe in Farbe (Standard)
.IPs interlaced
TV-Ausgabe ist interlaced (Standard).
.IPs nointerlaced
Schaltet die interlaced-TV-Ausgabe ab.
.IPs norm=<Wert>
TV-Norm (ntsc (Standard), pal, pal60, palm, paln, palnc)
.IPs square-pixel
Setzt TV-Pixelmodus auf 'square'.
.IPs ccir601-pixel
Setzt TV-Pixelmodus auf 'ccir601'.
.RE
.RS
.sp 1
.I Overlay
.RE
.RSs
.IPs cr-left=<0\-500>
Setzt den Wert für das Abschneiden des Bildrandes links (Standard: 50).
.IPs cr-right=<0\-500>
Setzt den Wert für das Abschneiden des Bildrandes rechts (Standard: 300).
.IPs cr-top=<0\-500>
Setzt den Wert für das Abschneiden des Bildrandes oben (Standard: 0)
.IPs cr-bottom=<0\-500>
Setzt den Wert für das Abschneiden des Bildrandes unten (Standard: 0)
.IPs ck-[r|g|b]=<0\-255>
Setzt die Verstärkung des r(oten), g(rünen) oder b(lauen) Wertes des
Overlay-Farbschlüssels.
.IPs ck-[r|g|b]min=<0\-255>
Setzt den Minimalwert für den entsprechenden Farbschlüssel.
.IPs ck-[r|g|b]max=<0\-255>
Setzt den Maximalwert für den entsprechenden Farbschlüssel.
.IPs ignore-cache
Ignoriere die zwischengespeicherten Overlay-Einstellungen.
.IPs update-cache
Aktualisiere die zwischengespeicherten Overlay-Einstellungen.
.IPs ol-osd
Aktiviert Overlay-Onscreen-Anzeige.
.IPs nool-osd
Deaktiviert Overlay-Onscreen-Anzeige (Standard).
.IPs ol[h|w|x|y]-cor=<Wert>
Passt die Größe (Höhe, Breite) und Position des Overlays an, falls es nicht
ganz den Fensterproportionen entspricht (Standard: 0).
.IPs overlay
Aktiviert das Overlay (Standard).
.IPs nooverlay
Aktiviert die TV-Ausgabe.
.IPs overlay-ratio=<1\-2500>
Stellt das Overlay ein (Standard: 1000).
.RE
.
.TP
.B \-fb <Gerät> (nur bei \-vo fbdev oder directfb) (VERALTET)
Gibt das zu benutzende Framebuffer-Gerät an (Standard: /dev/\:fb0).
.
.TP
.B \-fbmode <Modusname> (nur bei \-vo fbdev)
Wechselt in den angegebenen Videomodus, der als <Modusname> in
/etc/\:fb.modes steht.
.br
.I ANMERKUNG:
Der VESA-Framebuffer unterstützt den Auflösungswechsel nicht.
.
.TP
.B \-fbmodeconfig <Dateiname> (nur bei \-vo fbdev)
Benutze diese Konfigurationsdatei an Stelle der Standarddatei /etc/\:fb.modes.
.
.TP
.B \-fs (siehe auch \-zoom) 
Vollbildwiedergabe (zentriert den Film und erstellt schwarze Balken rund um
das Bild).
Nicht jeder Videoausgabetreiber unterstützt dies.
.
.TP
.B \-fsmode-dontuse <0\-31> (VERALTET) (benutze \-fs)
Benutze diese Option, wenn du mit dem Vollbildmodus Probleme hast.
.
.TP
.B \-fstype <Typ1,Typ2,...> (nur bei X11)
Gib eine Prioritätenliste von Vollbild-Layereinstellungsmodi an, die benutzt
werden sollen.
Du kannst die Modi durch Voransetzen von '\-' negieren.
Falls du das Problem hast, dass das Vollbild von anderen Fenstern überdeckt
wird, probiere eine andere Reihenfolge.
.br
.I ANMERKUNG:
Siehe \-fstype help für eine vollständige Liste aller verfügbaren Modi.
.sp 1
Die verfügbaren Modi sind:
.sp 1
.PD 0
.RSs
.IPs above
Benutze die _NETWM_STATE_ABOVE-Anweisung, falls verfügbar.
.IPs below
Benutze die _NETWM_STATE_BELOW-Anweisung, falls verfügbar.
.IPs fullscreen
Benutze die _NETWM_STATE_FULLSCREEN-Anweisung, falls verfügbar.
.IPs layer
Benutze die _WIN_LAYER-Anweisung mit dem Standard-Layer.
.IPs layer=<0...15>
Benutze die _WIN_LAYER-Anweisung mit der angegebenen Layernummer.
.IPs netwm
Erzwinge den NETWM-Stil.
.IPs none\ 
Richte den Vollbild-Fenster-Layer nicht ein.
.IPs stays_on_top
Benutze die _NETWM_STATE_STAYS_ON_TOP-Anweisung, falls verfügbar.
.REss
.sp 1
.RS
.I BEISPIEL:
.RE
.PD 0
.RSs
.IPs layer,stays_on_top,above,fullscreen
Standardreihenfolge; wird benutzt, wenn falsche oder nichtunterstützte Modi
angegeben werden.
.IPs \-fullscreen
Korrigiert den Vollbildwechsel für Benutzer von OpenBox 1.x.
.RE
.PD 1
.
.TP
.B \-geometry x[%][:y[%]] oder [WxH][+x+y]
Gibt an, wo die Videoausgabe initial erscheint.
x und y sind Angaben in Pixeln und geben den Abstand von der linken oberen
Ecke des Bildschirms zur linken oberen Ecke des darzustellenden
Bildes an.
Wenn ein Prozentzeichen nach einem Argument verwendet wird, dann wird statt
dessen die prozentuale Bildschirmbreite/\:-höhe verwendet.
Auch das bei der X-Standardoption \-geometry verwendete Format wird
unterstützt.
Falls ein externes Fenster mit der Option \-wid angegeben wird, so sind die
Koordinaten x und y relativ zur linken oberen Ecke des Fensters und nicht zu
der des Bildschirms.
.br
.I ANMERKUNG:
Diese Option wird nur von x11-, xmga-, xv-, xvmc-, xvidix-,
directx- und tdfxfb-Videoausgabetreibern unterstützt.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs 50:40
Platziert das Fenster bei x=50, y=40.
.IPs 50%:50%
Platziert das Fenster in der Mitte des Bildschirms.
.IPs 100%\
Platziert das Fenster in der Mitte des rechten Randes des Bildschirmes.
.IPs 100%:100%
Platziert das Fenster in der unteren rechten Ecke des Bildschirmes.
.RE
.PD 1
.
.TP
.B \-guiwid <Fenster ID> (siehe auch \-wid) (nur mit GUI)
Weist die GUI an, auch ein X11-Fenster zu benutzen und sich selbst an die
Unterseite des Videos zu heften, was nützlich ist beim Einbetten einer Mini-GUI
in einen Browser (z.B.\& mit dem MPlayer-Plugin).
.
.TP
.B \-hue <\-100\-100>
Passt die Farbe des Videosignals an (Standard: 0).
Du kannst mit dieser Option negative Farben erhalten.
Wird nicht von allen Videoausgabetreibern unterstützt.
.
.TP
.B \-monitor-dotclock <Bereich[,Bereich,...]> (nur bei \-vo fbdev und vesa)
Gib den Bereich für dotclock oder pixelclock des Monitors an.
.
.TP
.B \-monitor-hfreq <Bereich[,Bereich,...> (nur bei \-vo fbdev und vesa)
Gibt den Bereich für die horizontale Frequenz des Monitors an.
.
.TP
.B \-monitor-vfreq <Bereich[,Bereich,...> (nur bei \-vo fbdev und vesa)
Gibt den Bereich für die vertikale Frequenz des Monitors an.
.
.TP
.B \-monitoraspect <Verhältnis> (siehe auch \-aspect)
Gibt das Höhen-/\:Breitenverhältnis deines Monitors oder Fernsehers an.
Siehe auch \-aspect, das das Verhältnis des Films angibt.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
\-monitoraspect 4:3  oder 1.3333
.br
\-monitoraspect 16:9 oder 1.7777
.RE
.PD 1
.
.TP
.B \-nodouble
Deaktiviert Double-Buffering, hauptsächlich für Debugging-Zwecke.
Double-Buffering vermeidet Flimmern dadurch, dass zwei Bilder im Speicher
gehalten werden, von denen das eine angezeigt wird, während das andere noch
decodiert wird.
Es kann das OSD negativ beeinflussen, entfernt aber oft Flimmern des OSD.
Es braucht doppelt so viel Speicher wie Einfachpufferung und wird somit
nicht mit Grafikkarten funktionieren, die nur über sehr wenig Speicher
verfügen.
.
.TP
.B \-nograbpointer
Übernimmt den Mauszeiger nach einem Wechsel des Videomodus (mit \-vm)
nicht.
Nützlich bei Multihead-Einstellungen.
.
.TP
.B \-nokeepaspect
Erhalte beim Ändern der Fenstergröße unter X11 nicht das
Höhen-/\:Breitenverhältnis.
Funktioniert nur mit den x11-, xv-, xmga-, xvidix- und
directx-Videoausgabetreibern.
Außerdem muß dein Windowmanager unter X11 Anweisungen zum
Fenster-Seitenverhältnis verstehen.
.
.TP
.B \-ontop\ 
Sorgt dafür, daß das Abspielfenster nicht von anderen Fenstern verdeckt wird.
Wird unterstützt von Videoausgabetreibern, die X11 benutzen, außer SDL,
außerdem directx, macosx, quartz, ggi und gl2.
.
.TP
.B \-panscan <0.0\-1.0>
Aktiviert Pan & Scan.
Dabei werden z.B.\& bei einem 16:9-Film und einem 4:3-Monitor die Seiten
abgeschnitten, damit der komplette Bildbereich ausgefüllt wird.
Der Bereich kontrolliert, wieviel vom Bild abgeschnitten wird.
Dies funktioniert nur mit den xv-, xmga-, mga-, gl-, quartz-, macosx- und
xvidix-Videoausgabetreibern.
.
.TP
.B \-refreshrate <Hz>
Setzt die Bildwiederholfrequenz des Monitors in Hz.
Momentan nur unterstützt durch \-vo directx kombiniert mit der \-vm-Option.
.
.TP
.B \-rootwin
Spielt den Film im Root-Fenster (dem Desktophintergrund) ab.
Desktophintergrundbilder können den Film allerdings verdecken.
Funktioniert nur mit den x11-, xv-, xmga-, xvidix-, quartz-, macosx- und
directx-Videoausgabetreibern.
.
.TP
.B \-saturation <\-100\-100>
Passt die Sättigung des Videosignals an (Standard: 0).
Mit dieser Option kannst du ein Graustufenbild bekommen.
Wird nicht von allen Videoausgabetreibern unterstützt.
.
.TP
.B \-screenh <Pixel>
Gib die horizontale Bildauflösung für Videoausgabetreiber an, die die
Bildschirmauflösung nicht kennen, wie fbdev, x11 und TV-Ausgang.
.
.TP
.B \-screenw <Pixel>
Gib die vertikale Bildauflösung für Videoausgabetreiber an, die die
Bildschirmauflösung nicht kennen, wie fbdev, x11 und TV-Ausgang.
.
.TP
.B \-stop-xscreensaver (nur bei X11)
Deaktiviert den Bildschirmschoner beim Start von MPlayer und aktiviert ihn
beim Beenden wieder.
.
.TP
.B \-vm \ \ \ 
Versucht, in einen anderen Videomodus zu wechseln.
Unterstützt von dga-, x11, xv-, sdl- und directx-Videoausgabetreibern.
In Verbindung mit dem directx-Videoausgabetreiber können die Optionen
\-screenw, \-screenh, \-bpp und \-refreshrate benutzt werden, um einen neuen
Anzeigemodus zu setzen.
.
.TP
.B \-vsync \ \ 
Aktiviert VBI für vesa-, dfbmga- und svga-Videoausgabetreiber.
.
.TP
.B \-wid <Fenster-ID> (siehe auch \-guiwid, \-geometry) (nur bei X11 und DirectX)
Weist MPlayer an, sich an ein bestehendes X11-Fenster zu heften, was
beispielsweise nützlich ist, um MPlayer in einen Browser einzubetten (z.B.\&
mit der plugger-Erweiterung).
.
.TP
.B \-xineramascreen <0\-...>
Bei Xinerama-Konfigurationen (z.B.\& bei einem einzigen Desktop, der sich
über mehrere Monitore erstreckt) gibt diese Option an, auf welchem Schirm
das Video angezeigt werden soll.
.
.TP
.B \-zrbw (nur bei \-vo zr)
Anzeige in schwarz/\:weiß.
Für optimale Performance kann dies mit der Option '\-lavdopts gray'
kombiniert werden.
.
.TP
.B \-zrcrop <[Breite]x[Höhe]+[x Offset]+[y Offset]> (nur bei \-vo zr)
Wählt den anzuzeigenden Teilausschnitt des Bildes.
Wird diese Option mehrmals angegeben, so aktiviert sie den Cinerama-Modus.
Im Cinerama-Modus wird der Film auf mehr als einen Fernseher (oder Beamer)
verteilt, um insgesamt eine größere Anzeigefläche zu erhalten.
Optionen, die nach dem n-ten \-zrcrop erscheinen, gelten für die
n-te MJPEG-Karte.
Für jede Karte sollte zusätzlich zu \-zrcrop ein \-zrdev angegeben werden.
Beispiele befinden sich in der Zr-Sektion der Dokumentation oder in der
Ausgabe von \-zrhelp.
.
.TP
.B \-zrdev <Gerät> (nur bei \-vo zr)
Gibt die zu deiner MJPEG-Karte gehörende Gerätedatei an.
Standardmäßig verwendet der zr-Videoausgabetreiber das erste v4l-Gerät, das
er findet.
.
.TP
.B \-zrfd (nur bei \-vo zr)
Erzwungene Dezimierung: Dezimierung, wie mit \-zrhdec und \-zrvdec angegeben.
Wird nur angewandt, wenn der Hardwareskalierer das Bild wieder auf seine
ursprüngliche Größe ausdehnen kann.
Mit dieser Option wird die Dezimierung erzwungen.
.
.TP
.B \-zrhdec <1|2|4> (nur bei \-vo zr)
Horizontale Dezimierung: Weist den Treiber an, nur jede zweite
oder vierte Zeile/\:Pixel des Bildes an die MJPEG-Karte zu schicken und
den Hardwareskalierer der MJPEG-Karte dazu zu benutzen, das Bild wieder
auf seine Urpsrungsgröße auszudehnen.
.
.TP
.B \-zrhelp (nur bei \-vo zr)
Zeigt eine Liste aller \-zr*-Optionen, ihre Standardwerte und ein Beispiel
für den Cinerama-Modus an.
.
.TP
.B \-zrnorm <norm> (nur bei \-vo zr)
Gibt die Fernsehnorm PAL oder NTSC an (Standardwert: keine Änderung).
.
.TP
.B \-zrquality <1\-20> (nur bei \-vo zr)
Eine Nummer von 1 (beste) bis 20 (schlechteste), die die
JPEG-Codierungsqualität angibt.
.
.TP
.B \-zrvdec <1|2|4> (nur bei \-vo zr)
Horizontale Dezimierung: Weist den Treiber an, nur jede zweite
oder vierte Spalte/\:Pixel des Bildes an die MJPEG-Karte zu schicken und
den Hardwareskalierer der MJPEG-Karte dazu zu benutzen, das Bild wieder
auf seine Urpsrungsgröße auszudehnen.
.
.TP
.B \-zrxdoff <x Anzeige-Offset> (nur bei \-vo zr)
Wenn das Bild kleiner als der Fernsehbildschirm ist, so wird mit dieser
Option die Bildposition relativ zur oberen linken Ecke des Fernsehers
kontrolliert (Standard: zentriert).
.
.TP
.B \-zrydoff <y Anzeige-Offset> (nur bei \-vo zr)
Wenn das Bild kleiner als der Fernsehbildschirm ist, so wird mit dieser
Option die Bildposition relativ zur oberen linken Ecke des Fernsehers
kontrolliert (Standard: zentriert).
.
.
.
.SH "VIDEOAUSGABETREIBER (NUR BEI MPLAYER)"
Videoausgabetreiber sind Schnittstellen zu verschiedenen
Videoausgabe-Einrichtungen.
.
Die Syntax ist folgende:
.TP
.B \-vo <Treiber1[:Suboption1[=Wert]:...],Treiber2,...[,]>
Gibt eine Prioritätenliste der zu verwendenden Videoausgabetreiber an.
.PP
Wenn die Liste mit ',' endet, so werden notfalls auch nicht in der
Kommandozeile aufgeführte Treiber benutzt.
Suboptionen sind optional und können meistens weggelassen werden.
.br
.I ANMERKUNG:
Eine Liste der eincompilierten Videotreiber erhälst du mit \-vo help.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-vo xmga,xv,"
Probiert zuerst den Matrox-X11-Treiber, dann den Xv-Treiber, dann andere.
.IPs "\-vo directx:noaccel"
Benutzt den directx-Treiber mit abgeschalteten Beschleunigungs-Features.
.RE
.PD 1
.sp 1
Folgende Videoausgabetreiber sind verfügbar:
.
.TP
.B xv (nur bei X11)
Benutzt die XVideo-Erweiterung von XFee86 4.x, um hardwarebeschleunigtes
Abspielen zu ermöglichen.
Wenn du keinen hardwarespezifischen Treiber wählen kannst, ist dies für dich
vermutlich die beste Wahl.
Für Informationen darüber, welcher Farbschlüssel benutzt wird und wie er
dargestellt wird, starte MPlayer mit der Option \-v und suche in der Ausgabe
Zeilen, die am Anfang mit [xv common] gekennzeichnet sind.
.PD 0
.RSs
.IPs port=<Nummer>
Wähle einen bestimmten Port für XVideo.
.IPs ck=<cur|use|set>
Wählt die Quelle, von der der Farbschlüssel genommen wird (Standard: cur).
.RSss
.IPs cur
Benutzt den aktuell in Xv gesetzten Farbschlüssel.
.IPs use
Benutze, setze aber nicht den Farbschlüssel von MPlayer (benutze die Option
\-colorkey, um dies zu ändern).
.IPs set
Das gleiche wie bei der Option use, setzt jedoch auch den gelieferten
Farbschlüssel.
.RE
.IPs ck-method=<man|bg|auto>
Setzt die Zeichenmethode für den Farbschlüssel (Standard: man).
.RSss
.IPs man
Zeichne den Farbschlüssel manuell (reduziert in manchen Fällen Flimmern).
.IPs bg
Setze den Farbschlüssel als Fensterhintergrund.
.IPs auto
Lässt Xv den Farbschlüssel zeichnen.
.RE
.RE
.PD 1
.
.TP
.B x11 (nur bei X11)
Ein Videoausgabetreiber mit Shared Memory ohne Hardwarebeschleunigung, der
immer funktioniert, wenn X11 läuft.
.
.TP
.B xover (nur bei X11)
Ergänzt alle Overlay-basierten Treiber um X11-Unterstützung.
Momentan nur von tdfx_vid unterstützt.
.PD 0
.RSs
.IPs <vo_Treiber>
Wähle den Treiber, der als Quelle für das Overlay oberhalb von X11 benutzt
werden soll.
.RE
.PD 1
.
.TP
.B xvmc (nur bei X11 mit \-vc ffmpeg12mc)
Ein Videoausgabetreiber, der die XvMC- (X Video Motion Compensation)
Unterstützung von XFree86 4.x benutzt, um das Decodieren von MPEG-1/\:2 und
VCR2 zu beschleunigen.
.PD 0
.RSs
.IPs port=<Nummer>
Wählt einen speziellen XVideo-Port.
.IPs (no)benchmark
Deaktiviert die Anzeige von Bildern.
Benötigt für einwandfreies Benchmarking von Treibern, die den Bildpuffer nur
bei einem Monitor-Retrace ändern (nVidia).
Voreinstellung ist, die Bildwiedergabe nicht zu deaktivieren (nobenchmark).
.IPs (no)queue
Frames werden in einer Queue angeordnet, um der Videohardware weitergehendes
paralleles Arbeiten zu ermöglichen.
Dies kann eine geringe konstante (nicht bemerkbare) A/\:V-Desynchronisation mit
sich bringen (Standard: noqueue).
.IPs (no)sleep
Benutze die Sleep-Funktion, während auf Beendigung des Renderns gewartet
wird (nicht empfohlen unter Linux) (Standard: nosleep).
.IPs ck=cur|use|set
Das gleiche wie \-vo xv:ck (siehe \-vo xv).
.IPs ck-method=man|bg|auto
Das gleiche wie die \-vo xv:ck-Methode (siehe \-vo xv).
.RE
.PD 1
.
.TP
.B dga (nur bei X11)
Gib das Video über die Direct Graphics Access-Erweiterung von XFree86 aus.
Wird als veraltet betrachtet.
.
.TP
.B sdl (nur bei SDL)
Höchst-plattformunabhängiger Videoausgabetreiber der SDL-Bibliothek (Simple
Directmedia Layer).
Da SDL einen eigenen X11-Layer benutzt, haben die X11-Optionen von MPlayer
keine Wirkung auf SDL.
.PD 0
.RSs
.IPs driver=<Treiber>
Wähle den zu benutzenden SDL-Treiber explizit.
.IPs (no)forcexv
Erzwingt die Benutzung von XVideo über den SDL-Videoausgabetreiber (Standard:
forcexv).
.IPs (no)hwaccel
Benutze den hardwarebeschleunigten Skalierer (Standard: hwaccel).
.RE
.PD 1
.
.TP
.B vidix\ \ 
VIDIX (VIDeo Interface für *niX) ist eine Schnittstelle zu den
Videobeschleunigungsfunktionen verschiedener Grafikkarten.
Sehr schneller Videoausgabetreiber bei Karten, die dies unterstützen.
.PD 0
.RSs
.IPs <Subdevice>
Wähle explizit einen VIDIX-Subdevice-Treiber, der benutzt werden soll.
Verfügbare Subdevice-Treiber sind cyberblade_vid, mach64_vid, mga_crtc2_vid,
mga_vid, nvidia_vid, pm3_vid, radeon_vid, rage128_vid, sis_vid und
unichrome_vid.
.RE
.PD 1
.
.TP
.B xvidix (nur bei X11)
X11-Frontend für VIDIX
.PD 0
.RSs
.IPs <Subdevice>
das gleich wie bei vidix
.RE
.PD 1
.
.TP
.B cvidix\ 
Generisches, plattformunabhängiges VIDIX-Frontend, das mit nVidia-Karten sogar
in der Konsole läuft.
.PD 0
.RSs
.IPs <Subdevice>
das gleich wie bei vidix
.RE
.PD 1
.
.TP
.B winvidix (nur bei Windows)
Windows-Frontend für VIDIX
.PD 0
.RSs
.IPs <Subdevice>
das gleich wie bei vidix
.RE
.PD 1
.
.TP
.B directx (nur bei Windows)
Videoausgabetreiber, der die DirectX-Schnittstelle benutzt.
.PD 0
.RSs
.IPs noaccel
Schaltet Hardwarebeschleunigung ab.
Probiere diese Option bei Problemen mit der Darstellung.
.RE
.PD 1
.
.TP
.B quartz (nur bei Mac OS X)
Mac OS X Quartz-Videoausgabetreiber.
Unter manchen Umständen mag es effizienter sein, ein komprimiertes
YUV-Ausgabeformat zu erzwingen, z.B.\& mit \-vf format=yuy2.
.PD 0
.RSs
.IPs device_id=<Nummer>
Wähle ein Gerät für die Darstellung im Vollbildmodus.
.IPs fs_res=<Breite>:<Höhe>
Gib die Auflösung im Vollbildmodus an (nützlich auf langsamen Systemen).
.RE
.PD 1
.
.TP
.B macosx (Mac OS X 10.4 oder 10.3.9 mit QuickTime 7)
Mac OS X CoreVideo Videoausgabetreiber
.PD 0
.RSs
.IPs device_id=<Nummer>
Wähle das Anzeigegerät für die Vollbildwiedergabe.
.RE
.PD 1
.
.TP
.B fbdev (nur bei Linux)
Benutze für die Videoausgabe den Kernel-Framebuffer.
.PD 0
.RSs
.IPs <Gerät>
Wähle explizit das zu benutzende fbdev-Gerät (z.B.\& /dev/\:fb0) oder das
VIDIX-Subdevice, falls der Gerätename mit 'vidix' beginnt (z.B.\&
'vidixsis_vid' beim SIS-Treiber).
.RE
.PD 1
.
.TP
.B fbdev2 (nur bei Linux)
Benutze für die Videoausgabe den Kernel-Framebuffer, alternative
Implementation.
.PD 0
.RSs
.IPs <Gerät>
Wähle das zu benutzende fbdev-Gerät explizit. (Standard: /dev/\:fb0).
.RE
.PD 1
.
.TP
.B vesa\ \ \ 
Sehr genereller Videoausgabetreiber, der mit jeder VESA VBE 2.0-kompatiblen
Karte funktionieren sollte.
.PD 0
.RSs
.IPs dga\ \ 
Schaltet den DGA-Modus an.
.IPs nodga
Schaltet den DGA-Modus ab.
.IPs neotv_pal
Aktiviere die TV-Ausgabe von NeoMagic und setze die Norm auf PAL.
.IPs neotv_ntsc
Aktiviere die TV-Ausgabe von NeoMagic und setze die Norm auf NTSC.
.IPs vidix
Benutze den VIDIX-Treiber.
.IPs lvo:\ \ \ 
Aktiviere das Linux-Video-Overlay über dem VESA-Modus.
.RE
.PD 1
.
.TP
.B svga\ \ \ 
Gib das Video über die SVGA-Bibliothek aus.
.PD 0
.RSs
.IPs "<Videomodus>"
Gib den zu benutzenden Videomodus an.
Der Modus kann angegeben werden im Format <Breite>x<Höhe>x<Farben>, z.B.\&
640x480x16M, oder per Grafikmodusnummer, z.B.\& 84.
.IPs bbosd
Zeigt das OSD in den schwarzen Rändern des Films an (langsamer).
.IPs native
Benutze nur native Darstellungsfunktionen.
Dies verhindert direktes Rendern, OSD und Hardwarebeschleunigung.
.IPs retrace
Erzwingt Frame-Wechsel bei vertikalem Retrace.
Nur benutzbar mit \-double.
Dies hat denselben Effekt wie die Option \-vsync.
.IPs sq\ \ \
Versucht, einen Videomodus mit quadratischen Pixeln zu wählen.
.IPs vidix
Benutze svga mit VIDIX.
.RE
.PD 1
.
.TP
.B gl\ \ \ \ \ 
OpenGL-Videoausgabetreiber.
Einfache Version, die Videogröße muß kleiner
sein als die maximale Texturgröße deiner OpenGL-Implementierung.
Es ist beabsichtigt, auch mit den einfachsten OpenGL-Implementierungen zu
funktionieren.
.PD 0
.RSs
.IPs (no))manyfmts
Schaltet die Unterstütztung für mehr (RGB und BGR) Farbformate.
Benötigt eine OpenGL-Version >= 1.2.
.IPs slice-height=<0\-...>
Anzahl der Linien, die an einem Stück zur Textur kopiert werden (Standard: 4).
0 für ganzes Bild.
.IPs (no)osd
(De)aktiviere die Unterstützung für das Rendern des OSD via OpenGL (Standard:
aktiviert).
Hauptsächlich für Testzwecke, Du solltest \-osdlevel 0 benutzen, um OSD zu
deaktivieren.
.IPs (no)scaled-osd
Ändert das Verhalten des OSD bei Änderung der Fenstergröße (Standard:
deaktiviert).
Falls aktiviert ist das Verhalten den anderen Videoausgabetreibern ähnlicher,
was bei Schriftarten mit fester Größe besser ist.
Deaktiviert sieht es mit FreeType-Schriftarten besser aus und benutzt im
Vollbildmodus die Ränder.
.IPs (no)aspect
(De)aktiviert die Skalierung des Aspekts und die Unterstützung für Panscan
(Standard: aktiviert).
Deaktivierung könnte die Geschwindigkeit erhöhen.
.RE
.PD 1
.
.TP
.B gl2\ \ \ \ 
OpenGL-Videoausgabetreiber, zweite Generation.
Unterstützt OSD und Videos, die größer als die maximale Texturgröße sind.
.
.TP
.B null\ \ \ 
Produziert keine Videoausgabe.
Nützlich für Benchmarking-Zwecke.
.
.TP
.B aa\ \ \ \ \ 
ASCII-Art-Videoausgabetreiber, der auf einer Textkonsole funktioniert.
Du bekommst eine Liste mit allen Optionen und ihren Erläuterungen mit
.I mplayer \-vo aa:help
.
.TP
.B caca\ \ \ 
Farbiger ASCII-Art-Videoausgabetreiber, der auf einer Textkonsole funktioniert.
.
.TP
.B bl\ \ \ \ \ 
Videowiedergabe, die das Blinkenlights-UDP-Protokoll unterstützt.
Dieser Treiber ist höchstgradig hardwarespezifisch.
.PD 0
.RSs
.IPs <Subdevice>
Wählt den zu benutzenden Subdevice-Treiber von Blinkenlights explizit.
Die Angabe ist der Art arcade:host=localhost:2323 oder
hdl:file=Name1,file=Name2.
Du musst ein Subdevice angeben.
.RE
.PD 1
.
.TP
.B ggi\ \ \ \ 
Videoausgabetreiber für das GGI-Grafiksystem.
.PD 0
.RSs
.IPs <Treiber>
Wählt den zu benutzenden GGI-Treiber explizit.
Ersetze jedes ',' das in der Treiberzeichenkette vorkommt durch ein '.'.
.RE
.PD 1
.
.TP
.B directfb
Videowiedergabe über die DirectFB-Bibliothek.
.PD 0
.RSs
.IPs (no)input
Benutze DirectFB anstelle des MPlayer-Tastaturcodes (Standard: aktiviert).
.IPs buffermode=single|double|triple
Doppeltes (double) und dreifaches (triple) Buffering liefern die besten
Resultate, wenn du Abreiß-Probleme vermeiden möchstest.
Triplebuffering ist effizienter als Doublebuffering, da es MPlayer
während des Wartens auf das vertikale Retrace nicht blockiert.
Einfaches Buffern sollte vermieden werden (Standard: single).
.IPs fieldparity=top|bottom
Kontrolliert die Ausgabereihenfolge für interlaced-Bilder (Standard:
deaktiviert).
Gültige Werte sind top = obere Felder zuerst, bottom = untere Felder zuerst.
Diese Option hat keinerlei Effekt auf progressives Filmmaterial, wie es die
meisten MPEG-Filme sind.
Du mußt diese Option aktivieren, wenn es beim Schauen von
interlaced-Filmmaterial
zu Abreißeffekten oder unscharfen Bewegungen kommt.
.IPs layer=N
Wird den Layer mit der ID N für die Wiedergabe erzwingen (Standard: -1 - auto).
.RE
.PD 1
.
.TP
.B dfbmga\ 
Matrox G400/\:G450/\:G550-spezifische Videoausgabetreiber, die die
DirectFB-Bibliothek benutzen.
Ermöglicht CRTC2 (zweiter Bildschirm), stellt Videos unabhängig vom ersten
Bildschirm dar.
.PD 0
.RSs
.IPs (no)bes
Ermöglicht die Nutzung von Matrox BES (Backend-Skalierer) (Standard:
deaktiviert).
Gibt hinsichtlich Geschwindigkeit und Ausgabequalität sehr gute Resultate, da
interpolierte Bildverarbeitung in der Hardware geschieht.
Funktioniert nur auf dem ersten Bildschirm.
.IPs (no)spic
Nutzt den Matrox-Sub-Picture-Layer für die Anzeige des OSD (Standard:
aktiviert).
.IPs (no)crtc2
Schaltet TV-Out des zweiten Monitors an (Standard: aktiviert).
An der Wiedergabequalität ist erstaunlich, dass ein komplettes Interlaced-Bild
mit exakter Synchronisation auf jedem un-/\:graden Feld dargestellt wird.
.IPs (no)input
Benutze DirectFB anstelle des MPlayer-Tastaturcodes (Standard: aktiviert).
.IPs buffermode=single|double|triple
Doppeltes (double) und dreifaches (triple) Buffering liefern die besten
Resultate, wenn du Abreiß-Probleme vermeiden möchstest.
Triplebuffering ist effizienter als Doublebuffering, da es MPlayer
während des Wartens auf das vertikale Retrace nicht blockiert.
Einfaches Buffern sollte vermieden werden (Standard: single).
.IPs fieldparity=top|bottom
Kontrolliert die Ausgabereihenfolge für interlaced-Bilder (Standard:
deaktiviert).
Gültige Werte sind top = obere Felder zuerst, bottom = untere Felder zuerst.
Diese Option hat keinerlei Effekt auf progressives Filmmaterial, wie es die
meisten MPEG-Filme sind.
Du mußt diese Option aktivieren, wenn es beim Schauen von
interlaced-Filmmaterial
zu Abreißeffekten oder unscharfen Bewegungen kommt.
.IPs tvnorm=pal|ntsc|auto
Setzt die TV-Norm der Matrox-Karte, ohne /etc/\:directfbrc ändern zu
müssen (Standard: deaktiviert).
Gültige Normen sind pal = PAL, ntsc = NTSC.
Eine spezielle Norm ist auto (automatisches Anpassen zu PAL/\:NTSC), denn
die Norm wird bestimmt, indem die Framerate des Films betrachtet wird.
.RE
.PD 1
.
.TP
.B mga (nur bei Linux)
Matrox-spezifischer Videoausgabetreiber, der den YUV-Backend-Scaler von
Gxxx-Karten durch ein Kernelmodul benutzt.
Wenn du eine Matroxkarte hast, ist dies die schnellste Option.
.PD 0
.RSs
.IPs <Gerät>
Wählt das zu benutzende Matrox-Gerät explizit (Standard: /dev/\:mga_vid).
.RE
.PD 1
.
.TP
.B xmga (nur bei Linux, X11)
Der mga-Videoausgabetreiber, läuft in einem X11-Fenster.
.PD 0
.RSs
.IPs <Gerät>
Wählt das zu benutzende Matrox-Gerät explizit (Standard: /dev/\:mga_vid).
.RE
.PD 1
.
.TP
.B syncfb\ 
Videoausgabetreiber für das SyncFB-Kernelmodul, das spezielle
Hardwareeigenschaften von Matrox Gxxx-Karten bereitstellt, wie
Hardware-Deinterlacing, Skalierung und Synchronisation der Videoausgabe für
das vertikale Retrace auf dem Monitor.
.
.TP
.B 3dfx (nur bei Linux)
3Dfx-spezifischer Videoausgabetreiber.
Dieser Treiber benutzt die 3Dfx-Hardware direkt auf X11.
Nur 16 bpp werden unterstützt.
FIXME: Unterschied zwischen 3dfx, tdfxfb and tdfx_vid ok?
.
.TP
.B tdfxfb (Linux only)
Dieser Treiber setzt den tdfx-Framebuffer-Treiber ein, um Filme mit
YUV-Beschleunigung abzuspielen.
FIXME: Unterschied zwischen 3dfx, tdfxfb and tdfx_vid ok?
.PD 0
.RSs
.IPs <Gerät>
Wähle das zu benutzende fbdev-Gerät explizit (Standard: /dev/\:fb0).
.RE
.PD 1
.
.TP
.B tdfx_vid (Linux only)
3Dfx-spezifischer Videoausgabetreiber.
Dieser Treiber benutzt das tdfx_vid-Kernelmodul direkt.
FIXME: Unterschied zwischen 3dfx, tdfxfb and tdfx_vid ok?
.PD 0
.RSs
.IPs <Gerät>
Wähle das zu benutzende Gerät explizit (Standard:/dev/\:tdfx_vid).
.RE
.PD 1
.
.TP
.B dxr2 (siehe auch \-dxr2) (nur bei DXR2)
Creative DXR2-spezifischer Videoausgabetreiber.
.PD 0
.RSs
.IPs <vo_Treiber>
Der für das Overlay zu benutzende unterliegende Videoausgabetreiber (x11, xv)
.RE
.PD 1
.
.TP
.B dxr3 (nur bei DXR3)
Sigma Designs em8300 MPEG-Decoder-Chip- (Creative DXR3, Sigma Designs
Hollywood Plus) spezifischer Videoausgabetreiber.
Siehe auch lavc-Videofilter.
.PD 0
.RSs
.IPs overlay
Aktiviert Overlay anstelle von TV-Ausgabe.
.IPs prebuf
Schaltet Prebuffering ein.
.IPs sync\ 
Schaltet die neue Sync-Engine ein.
.IPs norm=<Norm>
Gibt die TV-Norm an.
.RSss
0: Ändert die aktuelle Norm nicht (Standard).
.br
1: Automatische Anpassung mit PAL/\:NTSC.
.br
2: Automatische Anpassung mit PAL/\:PAL-60.
.br
3: PAL
.br
4: PAL-60
.br
5: NTSC
.REss
.IPs <0\-3>
Gibt die Gerätenummer an, wenn mehr als eine em8300-Karte vorhanden ist.
.RE
.PD 1
.
.TP
.B mpegpes (nur bei DVB)
Videoausgabetreiber für DVB-Karten, der die Ausgabe in eine MPEG-PES-Datei
schreibt, falls keine DVB-Karte installiert ist.
.PD 0
.RSs
.IPs card=<1\-4>
Gibt die Gerätenummer an, wenn mehr als eine DVB-Karte vorhanden ist (nur bei
V3 API, wie bei den Treibern der 1.x.y-Serie).
.IPs <Dateiname>
Erlaubt die genaue Angabe des Ausgabedateinamens (Standard: ./grab.mpg).
.RE
.PD 1
.
.TP
.B zr (siehe auch \-zr* und \-zrhelp)
Videoausgabetreiber für eine Anzahl von MJPEG-Capture/\:Wiedergabe-Karten.
.
.TP
.B zr2 (siehe auch den zrmjpeg-Videofilter)
Videoausgabetreiber für eine Anzahl von MJPEG-Capture/\:Wiedergabe-Karten,
zweite Generation.
.PD 0
.RSs
.IPs dev=<Gerät>
Gibt das zu benutzende Gerät an.
.IPs pal\ \ 
Aktiviert die Videonorm PAL.
.IPs secam
Aktiviert die Videonorm SECAM.
.IPs ntsc\ 
Aktiviert die Videonorm NTSC.
.IPs prebuf
Aktiviert Prebuffering, wird noch nicht unterstützt.
.RE
.PD 1
.
.TP
.B md5sum\ 
Berechnet MD5-Summen von jedem Frame und schreibt sie in eine Datei.
Unterstützt die Farbräume RGB24 und YV12.
Nützlich für Debugging-Zwecke.
.PD 0
.RSs
.IPs outfile=<Dateiname>
Gibt den Ausgabe-Dateinamen an (Standard: ./md5sums).
.RE
.PD 1
.
.TP
.B yuv4mpeg
Wandelt den Videostream in eine Abfolge von unkomprimierten YUV 4:2:0-Bildern
um und speichert diese in einer Datei im aktuellen Verzeichnis
(Standard: ./stream.yuv).
Das Format ist das gleiche, das von den mjpegtools benutzt wird, daher ist
diese Option nützlich, wenn du das Video mit den mjpegtools bearbeiten
möchtest.
Es unterstützt das YV12-, RGB- (24 bpp) und BGR-Format (24 bpp).
Du kannst dies mit der Option \-fixed-vo kombinieren, um Dateien mit derselben
Größe (bezogen auf das Format) und gleichem fps-Wert aneinanderzuhängen.
.PD 0
.RSs
.IPs interlaced
Schreibt die Ausgabe-Frames interlaced, obere Felder zuerst.
.IPs interlaced_bf
Schreibt die Ausgabe-Frames interlaced, untere Felder zuerst.
.IPs file=<Dateiname>
Schreibe die Ausgabe nach <Dateiname> anstatt in die Standarddatei stream.yuv.
.REss
.PD 1
.RS
.sp 1
.I ANMERKUNG:
Bei Weglassen dieser Optionen ist die Ausgabe 'progressive' (d.h.\& nicht
interlaced).
.RE
.
.TP
.B gif89a\ 
Gibt jeden Frame in eine GIF-Datei im aktuellen Verzeichnis aus.
Jede Datei bekommt die Frame-Nummer mit vorangestellt ergänzenden Nullen als
Name.
Es unterstützt nur das RGB-Format (24 bpp), und die Ausgabe wird zu 256 Farben
konvertiert.
.PD 0
.RSs
.IPs <fps>
Fließkommawert, der die Framerate angibt (Standard: 5.0).
.IPs <Dateiname>
Gibt den Ausgabedateinamen an (Standard: ./out.gif).
.REss
.PD 1
.RS
.sp 1
.I ANMERKUNG:
Du musst die Framerate vor dem Dateinamen angeben, sonst wird die Framerate
Teil des Dateinamens.
.sp 1
.I BEISPIEL:
.RE
.PD 0
.RSs
mplayer video.nut \-vo gif89a:15.0:test.gif
.RE
.PD 1
.
.TP
.B jpeg\ \ \ 
Gibt jeden Frame in eine JPEG-Datei im aktuellen Verzeichnis aus.
Jede Datei bekommt die Frame-Nummer mit vorangestellt ergänzenden Nullen als
Name.
.PD 0
.RSs
.IPs [no]progressive
Gibt Standard-JPEG oder progressives JPEG an (Standard: noprogressive).
.IPs [no]baseline
Benutze eine/\:keine Baseline (Standard: baseline).
.IPs optimize=<Wert>
Optimierungswert <0\-100> (Standard: 100)
.IPs smooth=<Wert>
Glättungsfaktor <0\-100> (Standard: 0)
.IPs quality=<Wert>
Qualitätsfaktor <0\-100> (Standard: 75)
.IPs outdir=<Verzeichnisname>
Gib das Verzeichnis an, in das die JPEG-Bilder gespeichert werden
(Standard: ./).
.IPs subdirs=<Präfix>
Erstellt nummerierte Unterverzeichnisse mit dem angegebenen Präfix, in
welches die Dateien gespeichert werden anstatt in das aktuelle Verzeichnis.
.IPs maxfiles=<Wert> (nur mit subdirs)
Maximale Anzahl an JPEG-Dateien, die pro Unterverzeichnis gespeichert werden.
Muss größer oder gleich 1 sein (Standard: 1000).
.RE
.PD 1
.
.TP
.B pnm\ \ \ \ 
Gibt jeden Frame in eine PNM-Datei in das aktuelle Verzeichnis aus.
Jede Datei bekommt die Frame-Nummer mit vorangestellt ergänzenden Nullen als
Name.
Unterstützt PPM-, PGM- und PGMYUV-Dateien sowohl im raw- als auch im
ASCII-Modus.
Siehe auch pnm(5), ppm(5) and pgm(5).
.PD 0
.RSs
.IPs ppm\ \ 
Schreibe PPM-Dateien (Standard).
.IPs pgm\ \ 
Schreibe PGM-Dateien.
.IPs pgmyuv
Schreibe PGMYUV-Dateien.
PGMYUV ist wie PGM, enthält jedoch zusätzlich eine U- und V-Ebene unten im
Bild.
.IPs raw\ \ 
Schreibe PNM-Dateien im raw-Modus (Standard).
.IPs ascii
Schreibe PNM-Dateien im ASCII-Modus.
.IPs outdir=<Verzeichnisname>
Gib das Verzeichnis an, in das die PNM-Dateien gespeichert werden
(Standard: ./).
.IPs subdirs=<Präfix>
Erstellt nummerierte Unterverzeichnisse mit dem angegebenen Präfix, in
welches die Dateien gespeichert werden anstatt in das aktuelle Verzeichnis.
.IPs maxfiles=<Wert> (nur mit subdirs)
Maximale Anzahl an JPEG-Dateien, die pro Unterverzeichnis gespeichert werden.
Muss größer oder gleich 1 sein (Standard: 1000).
.RE
.PD 1
.
.TP
.B png\ \ \ \ 
Gibt jeden Frame in eine PNG-Datei im aktuellen Verzeichnis aus.
Jede Datei bekommt die Frame-Nummer mit vorangestellt ergänzenden Nullen als
Name.
Unterstützt die RGB- und BGR-Formate mit 24 bpp.
.PD 0
.RSs
.IPs z=<0\-9>
Gibt die Kompressionsstufe an.
0 steht für keine, 9 für maximale Kompression.
.RE
.PD 1
.
.TP
.B tga\ \ \ \ 
Gibt jeden Frame in eine TGA-Datei im aktuellen Verzeichnis aus.
Jede Datei bekommt die Frame-Nummer mit vorangestellt ergänzenden Nullen als
Name.
Der Zweck dieses Videoausgabetreibers ist das Schreiben von verlustfreien
Bildern, die mit jeder externen Bibliothek verwendet werden können.
Unterstützt werden BGR[A]-Farbformate mit 15, 24 und 32 bpp.
Ein bestimmtes Format kann erzwungen werden durch Benutzung des
format-Videofilters.
.sp 1
.I BEISPIEL:
.RE
.PD 0
.RSs
mplayer video.nut \-vf format=bgr15 \-vo tga
.RE
.PD 1
.
.
.
.SH "OPTIONEN FÜR DIE DECODIERUNG/\:DAS FILTERN"
.
.TP
.B \-ac <[-]Codec1,[-]Codec2,...[,]>
Gib eine Prioritätsliste der zu verwendenden Audiocodecs an.
Die Codecnamen entsprechen den in codecs.conf definierten Einträgen.
Ein '-' vor dem Codecnamen deaktiviert diesen Codec.
Wenn die Liste mit ',' endet, wird MPlayer auch auf Codecs zurückgreifen, die
nicht in der Liste stehen.
.br
.I ANMERKUNG:
Mit \-ac help erhälst du eine vollständige Liste aller verfügbaren Codecs.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-ac mp3acm"
Erzwingt den l3codeca.acm-MP3-Codec.
.IPs "\-ac mad,"
Probiert zuerst libmad und dann andere Codecs.
.IPs "\-ac hwac3,a52,"
Zuerst wird versucht, AC3 unverändert durchzureichen, dann die
Software-AC3-Decodierung, danach andere Codecs.
.IPs "\-ac -ffmp3,"
Probiere andere Codecs, ausgenommen den MP3-Decoder von FFmpeg.
.RE
.PD 1
.
.TP
.B \-af-adv <force=(0\-3):list=(Filter)> (siehe auch \-af)
Gibt erweiterte Audiofilteroptionen an:
.RSs
.IPs force=<0\-7>
Erzwingt das Einfügen von Audiofiltern nach folgenden Regeln:
.RSss
0: Komplett automatisches Einfügen (Standard)
.br
1: Optimiere auf Genauigkeit.
.br
2: Optimiere auf Geschwindigkeit.
.I Warnung:
Manche Features der Audiofilter können ohne Meldung zu geben versagen, wodurch
sich die Audioqualität verringern kann.
.br
3: Benutze kein automatisches Einfügen von Filtern und keine Optimierung.
.I Warnung:
Diese Einstellung kann MPlayer zum Absturz bringen.
.br
4: Benutze automatisches Einfügen von Filtern gemäß Option 0 oben, benutze
aber Verarbeitung von Fließkommawerten, falls möglich.
.br
5: Benutze automatisches Einfügen von Filtern gemäß Option 1 oben, benutze
aber Verarbeitung von Fließkommawerten, falls möglich.
.br
6: Benutze automatisches Einfügen von Filtern gemäß Option 2 oben, benutze
aber Verarbeitung von Fließkommawerten, falls möglich.
.br
7: Benutze automatisches Einfügen von Filtern gemäß Option 3 oben, benutze
aber Verarbeitung von Fließkommawerten, falls möglich.
.REss
.IPs list=<Filter>
Das gleiche wie \-af (siehe \-af).
.RE
.
.TP
.B \-afm <Treiber1,Treiber2,...>
Gibt eine Prioritätsliste der zu verwendenden Audiocodecfamilien an,
so wie sie in codecs.conf definiert wurden. Wenn keine der angegebenen
Familien benutzt werden kann, so werden die Standardcodecs verwendet.

.I ANMERKUNG:
.br
Mit \-afm help erhälst du eine Liste aller verfügbaren Treiber.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-afm ffmpeg"
Probiert zuerst die Codecs von FFmpegs libavcodec.
.IPs "\-afm acm,dshow"
Probiert zuerst die Win32-Codecs.
.RE
.PD 1
.
.TP
.B \-aspect <Verhältnis> (siehe auch \-zoom)
Überschreibt das Höhen-/\:Breitenverhältnis des Films in dem Falle, dass die in
der wiedergegebenen Datei gespeicherten Informationen fehlerhaft sind oder ganz
fehlen.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
\-aspect 4:3  oder \-aspect 1.3333
.br
\-aspect 16:9 oder \-aspect 1.7777
.RE
.PD 1
.
.TP
.B \-noaspect
Deaktiviert die automatische Anpassung des Höhen-/\:Breitenverhältnisses.
.
.TP
.B \-flip \ 
Stellt das Bild auf den Kopf (horizontales Spiegeln).
.
.TP
.B \-lavdopts <Option1:Option2:...> (DEBUG-CODE)
Gibt Parameter für das Decodieren mit libavcodec an.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
\-lavdopts bug=1
.RE
.PD 1
.sp 1
.RS
Verfügbare Optionen sind folgende:
.RE
.RSs
.IPs bug=<Wert>
Umgehe Fehler (Bugs) des Encoders manuell.
.RSss
0: nichts
.br
1: automatische Erkennung von Fehlern (Standard)
.br
2 (msmpeg4v3): manche ältere, von lavc generierte msmpeg4v3-Dateien (keine
automatische Erkennung)
.br
4 (mpeg4): XviD-Interlacing-Fehler (automatisch erkannt bei fourcc==XVIX)
.br
8 (mpeg4): UMP4 (automatisch erkannt bei fourcc==UMP4)
.br
16 (mpeg4): Padding-Fehler (automatisch erkannt)
.br
32 (mpeg4): Fehler durch ungültigen vlc (automatisch erkannt durch fourcc)
.br
64 (mpeg4): qpel-Fehler bei XviD und DivX (automatisch erkannt durch
fourcc/\:version)
.br
128 (mpeg4): alter qpel-Standardfehler (automatisch erkannt durch
fourcc/\:version)
.br
256 (mpeg4): noch ein anderer qpel-Fehler (automatisch erkannt durch
fourcc/\:version)
.br
512 (mpeg4): Fehler bei direkter qpel-Blockgröße (automatisch erkannt durch
fourcc/\:version)
.br
1024 (mpeg4): Randfüllungsfehler (edge padding, automatisch erkannt durch
fourcc/\:version)
.REss
.IPs debug=<Wert>
Zeige Debugging-Informationen an.
.RSss
.br
0: deaktiviert
.br
1: Bildinformationen
.br
2: Ratenkontrolle (Rate Control)
.br
4: Bitstream 
.br
8: Makroblock-Typ (MB type)
.br
16: Quantisierungsparameter (QP)
.br
32: Motion-Vector (MV)
.br
0x0040: Motion-Vector-Visualisierung (benutze \-noslices)
.br
0x0080: Überspringen des Makroblocks (MB)
.br
0x0100: Startcode
.br
0x0200: PTS
.br
0x0400: Fehler-Belastbarkeit
.br
0x0800: Speichermanagement-Kontrolloperationen (H.264)
.br
0x1000: Fehler/\:Bugs
.REss
.IPs ec=<Wert>
Setze zu verwendende Strategie zum Verbergen von Fehlern.
.RSss
1: Benutze einen starken Deblock-Filter bei beschädigten Makroblöcken (MBs).
.br
2: iterative Motion-Vector-Suche (langsam)
.br
3: alles (Standard)
.REss
.IPs er=<Wert>
Setze Strategie zur Fehlerbehandlung.
.RSss
.br
0: deaktiviert
.br
1: vorsichtig (Sollte mit den meisten fehlerhaften Encodern funktionieren.)
.br
2: normal (Standard) (Funktioniert mit den meisten konformen Encodern.)
.br
3: aggressiv (mehr Überprüfungen, die aber selbst bei konformen Daten
Fehler liefern können)
.br
4: sehr agressiv
.REss
.IPs fast\ 
Aktiviere Optimierungen, die nicht den Spezifikationen entsprechen und
möglicherweise Probleme verursachen können, wie beispielsweise einfachere
Dequantisierung, angenommene Benutzung der Standardquantisierungsmatrix, YUV
angenommen 4:2:0 und das Überspringen von ein paar Überprüfungen, die sonst
vorgenommen werden, um fehlerhafte Bitstreams zu erkennen.
.IPs gray
Decodierung nur mit Graustufen (was ein bischen schneller als mit Farbe ist)
.IPs "idct=<0\-99> (siehe \-lavcopts)"
Um die beste Decodierqualität zu erreichen, benutze denselben IDCT-Algorithmus
für Encodierung und Decodierung.
Dies kann allerdings auf Kosten der Genauigkeit gehen.
.IPs lowres=<Nummer>[,<b>]
Decodierung von niedrigeren Auflösungen.
Dies wird nicht von allen Codecs unterstützt und wird oft in hässlichen
Artefakten resultieren.
Dies ist kein Bug sondern ein Nebeneffekt der Decodierung bei nicht voller
Auflösung.
.RSss
.br
0: deaktiviert
.br
1: 1/2 Auflösung
.br
2: 1/4 Auflösung
.br
3: 1/8 Auflösung
.REss
.RS
Falls <b> angegeben wurde, wird die Decodierung für niedrige Auflösungen nur
dann benutzt, falls die Breite des Videos größer oder gleich dem Wert <b> ist.
.RE
.IPs "sb=<Nummer> (nur bei MPEG2)"
Überspringe unten die angegebene Anzahl von Makroblockreihen.
.IPs "st=<Nummer> (nur bei MPEG2)"
Überspringe oben die angegebene Anzahl von Makroblockreihen.
.IPs vismv=<Wert>
Visualisiere Motion-Vectors.
.RSss
.br
0: deaktiviert
.br
1: Mache von P-Frames vorwärts vorausberechnete Motion-Vectors sichtbar.
.br
2: Mache von B-Frames vorwärts vorausberechnete Motion-Vectors sichtbar.
.br
4: Mache von B-Frames rückwärts vorausberechnete Motion-Vectors sichtbar.
.REss
.IPs vstats
Gebe Statistiken aus und speichere sie in ./vstats_*.log.
.RE
.
.TP
.B \-noslices
Deaktiviert die Anzeige des Videos in 16-Pixel-hohen Streifen und stellt den
kompletten Frame statt dessen in einem einzigen Durchgang dar.
Dies kann die Darstellung schneller oder langsamer machen, abhängig von der
Hardware/\:dem Cache.
Dies hat nur einen Effekt bei den Codecfamilien libmpeg2 und libavcodec.
.
.TP
.B \-nosound
Spielt keinen Sound ab bzw.\& encodiert keinen Sound.
.TP
.B \-novideo
Spielt kein Video ab bzw.\& encodiert kein Video.
.
.TP
.B \-oldpp <Qualität> (nur bei OpenDivX) (OBSOLET)
Benutze den Postprocessing-Code von opendivx anstelle des internen.
Das interne Postprocessing liefert bessere Qualität und Performance, ersetzt
durch \-pp.
Der gültige Wertebereich für \-oldpp variiert je nach Codec, ist meistens
aber 0\-6, wobei 0=deaktiviert und 6=langsamster/\:bester Modus bedeutet.
.
.TP
.B \-pp <Qualität> (siehe auch \-vf pp)
Setzt das Postprocessing-Level der DLL.
Diese Option kann nicht mehr in Verbindung mit \-vf pp verwendet werden,
sondern nur noch mit Win32-DirectShow-DLLs, die eigene interne 
Postprocessing-Routinen mitbringen.
Der gültige Wertebereich für \-pp variiert je nach Codec, ist meistens aber
0\-6, wobei 0=deaktiviert und 6=langsamster/\:bester Modus bedeutet.
.
.TP
.B \-pphelp (siehe auch \-vf pp)
Zeigt eine Zusammenfassung der vorhandenen Postprocessing-Filter und
Nutzungshinweise an.
.
.TP
.B \-ssf <Modus>
Gibt die Parameter für den Softwareskalierer an.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
\-vf scale \-ssf lgb=3.0
.RE
.PD 1
.PD 0
.RSs
.IPs lgb=<0\-100>
gaußscher Unschärfefilter (beim Helligkeitsanteil)
.IPs cgb=<0\-100>
gaußscher Unschärfefilter (beim Farbanteil)
.IPs ls=<0\-100>
Schärfefilter (beim Helligkeitsanteil)
.IPs cs=<0\-100>
Schärfefilter (beim Farbanteil)
.IPs chs=<h>
Horizontale Verschiebung des Farbanteils
.IPs cvs=<v>
Vertikale Verschiebung des Farbanteils
.RE
.PD 1
.
.TP
.B \-stereo <Modus>
Wählt den Typ der MP2/\:MP3-Stereoausgabe.
.PD 0
.RSs
.IPs 0
Stereo
.IPs 1
Linker Kanal
.IPs 2
Rechter Kanal
.RE
.PD 1
.
.TP
.B \-sws <Typ\ des\ Softwareskalierers> (siehe auch \-vf scale und \-zoom)
Mit dieser Option wird die Qualität (und damit auch die Geschwindigkeit)
des Softwareskalierers gewählt, der bei \-zoom zum Einsatz kommt.
Dieser wird beispielsweise bei x11 oder anderen Videotreibern benutzt,
die keine Hardwarebeschleunigung bieten.
.sp 1
Mögliche Werte sind:
.sp 1
.PD 0
.RSs
.IPs 0
fast bilinear
.IPs 1
bilinear
.IPs 2
bicubic (gute Qualität) (Standard)
.IPs 3
experimentell
.IPs 4
nearest neighbour (schlechte Qualität)
.IPs 5
area
.IPs 6
luma bicubic / chroma bilinear
.IPs 7
gauss
.IPs 8
sincR
.IPs 9
lanczos
.IPs 10
natural bicubic spline
.RE
.PD 1
.sp 1
.RS
.I ANMERKUNG:
Manche \-sws-Optionen sind einstellbar.
Die Beschreibung des Videofilters scale enthält weitere Informationen.
.RE
.
.TP
.B \-vc <[-]Codec1,[-]Codec2,...[,]>
Gibt eine Prioritätsliste der zu verwendenden Videocodecs an, so wie sie
in codecs.conf definiert werden.
Ein '-' vor dem Codecnamen deaktiviert diesen Codec.
Wenn die Liste mit ',' endet, dann greift MPlayer auch auf auch nicht
aufgeführte Codecs zurück.
.br
.I ANMERKUNG:
Mit \-vc help wird eine vollständige Liste der verfügbaren Codecs ausgegben.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-vc divx"
Erzwingt den Win32/\:VFW DivX-Codec; andere werden nicht ausprobiert.
.IPs "\-vc divx4,"
Probiet zuerst den divx4linux-Codec, danach andere, wenn dieser nicht
funktioniert.
.IPs "\-vc -divxds,-divx,"
Probiert alle Codecs außer den Win32-DivX-Codecs.
.IPs "\-vc ffmpeg12,mpeg12,"
Probiert zuerst libavcodecs MPEG-1/\:2-Codec, gefolgt von libmpeg2, und
dann erst andere.
.RE
.PD 1
.
.TP
.B \-vfm <Treiber1,Treiber2,...>
Gibt eine Prioritätsliste der zu verwendenden Videocodecfamilien an, so wie sie
in codecs.conf definiert werden.
Wenn keine davon funktioniert, werden die Standardfamilien ausprobiert.
.br
.I ANMERKUNG:
Mit \-vfm help wird eine vollständige Liste der verfügbaren
Videocodecfamilien ausgegeben.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-vfm ffmpeg,dshow,vfw"
Probiert zuerst libavcodec, dann DirectShow, dann die VfW-Codecs und
schließlich
andere, falls keine der Familien funktioniert hat.
.IPs "\-vfm xanim"
Probiert zuerst die XAnim-Codecs.
.RE
.PD 1
.
.TP
.B \-x <x> (nur bei MPlayer)
Skaliert das Bild auf eine Breite von <x> (falls
Software-/\:Hardwareskalierung verfügbar ist).
Deaktiviert die Berechnung des Höhen-/\:Breitenverhältnisses.
.
.TP
.B \-xvidopts <Option1:Option2:...>
Gibt zusätzliche Parameter für die Decodierung mit XviD an.
.br
.I ANMERKUNG:
Da libavcodec schneller als XviD ist, könntest du in Betracht ziehen, den
Nachbearbeitungsfilter (\-vf pp) und Decoder (\-vfm ffmpeg) von libavcodec zu
benutzen.
.sp 1
XviD's interne Nachbearbeitungsfilter:
.PD 0
.RSs
.IPs deblock-chroma (siehe auch \-vf pp)
Chrominanz-Deblock-Filter
.IPs deblock-luma (siehe auch \-vf pp)
Luminanz-Deblock-Filter
.IPs dering-luma (siehe auch \-vf pp)
Luminanz-Deringing-Filter
.IPs dering-chroma (siehe auch \-vf pp)
Chrominanz-Deringing-Filter
.IPs filmeffect (siehe auch \-vf noise)
Fügt dem Video künstlich Körnung hinzu.
Kann die wahrgenommene Qualität erhöhen, während die eigentliche Qualität
geringer ist.
.RE
.sp 1
.RS
Methoden für das Rendern:
.RE
.PD 0
.RSs
.IPs dr2\ \ 
Aktiviert direktes Rendern mit Methode 2.
.IPs nodr2
Deaktiviert direktes Rendern mit Methode 2.
.RE
.PD 1
.
.TP
.B \-xy <Wert>
.PD 0
.RSs
.IPs Wert<=8
Skaliert das Bild um den Faktor <Wert>.
.IPs Wert>8
Setzt die Bildbreite auf <Wert> und berechnet die Höhe so, dass das
ursprüngliche Höhen-/\:Breitenverhältnis beibehalten wird.
.RE
.PD 1
.
.TP
.B \-y <y> (nur bei MPlayer)
Skaliert das Bild auf eine Höhe von <y> (falls Software-/\:Hardwareskalierung
verfügbar ist).
Deaktiviert die Berechnung des Höhen-/\:Breitenverhältnisses.
.
.TP
.B \-zoom\ \ 
Lässt Softwareskalierung zu, wo sie verfügbar ist.
Kann benutzt werden, um Skalierung mit \-vf scale zu erzwingen.
.br
.I ANMERKUNG:
\-vf scale ignoriert die Optionen \-x / \-y / \-xy / \-fs / \-aspect, wenn
\-zoom nicht angegeben wird.
.
.
.
.SH "AUDIOFILTER"
Audiofilter erlauben dir, den Audiostream und seine Eigenschaften zu verändern.
Der Syntax ist folgender:
.
.TP
.B \-af <Filter1[=Parameter1:Parameter2:...],Filter2,...>
Aktiviert eine Kette von Audiofiltern.
Siehe auch die Sektion Audiofilter der (englischen) Dokumentation.
.PP
.I ANMERKUNG:
Für eine vollständige Liste der verfügbaren Audiofilter, siehe \-af help.
.PP
Die verfügbaren Filter lauten:
.
.TP
.B resample[=srate[:salopp][:Typ]]
Ändert die Samplerate des Audiostreams zu der ganzzahligen srate (in Hz).
Kann benutzt werden, wenn du eine Soundkarte mit fester Frequenz hast oder
eine, die maximal 44.1kHz unterstützt.
Dieser Filter wird automatisch eingefügt, wenn nötig.
Unterstützt nur 16-bit-Integer und -Float im Native-Endian-Format.
.br
.I ANMERKUNG:
In Verbindung mit MEncoder musst du zusätzlich \-srate <srate> angeben.
.PD 0
.RSs
.IPs <srate>
Ausgabe-Samplerate in Hz.
Der gültige Bereich dieses Parameters ist 8000 bis 192000.
Falls die Samplefrequenz von Eingabe und Ausgabe gleich ist oder dieser
Parameter ausgelassen wird, wird der Filter automatisch entfernt.
Eine hohe Samplefrequenz erhöht normalerweise die Audioqualität, vor allem in
Kombination mit anderen Filtern.
.IPs <salopp>
Erlaube (1) oder erlaube nicht (0), dass sich die Ausgabefrequenz leicht von
der von <srate> vorgegebenen Frequenz unterscheidet (Standard: 1).
Kann benutzt werden, wenn der Start der Wiedergabe extrem langsam ist.
.IPs <Typ>
Wählt die zu verwendende Methode für das Resampling.
.RSss
0: lineare Interpolation (schnell, schlechte Qualität, vor allem bei
Erhöhung der Frequenz)
.br
1: mehrphasige Filterbank und Integer-Verarbeitung
.br
2: mehrphasige Filterbank und Fließkommazahl-Verarbeitung (langsam,
beste Qualität)
.REss
.PD 1
.RE
.sp 1
.RS
.I BEISPIEL:
.RE
.PD 0
.RSs
.IPs "mplayer \-af resample=44100:0:0"
würde die Ausgabefrequenz des resample-Filters auf 44100Hz setzen und dabei
exakte Skalierung der Ausgabefrequenz und lineare Interpolation verwenden.
.RE
.PD 1
.
.TP
.B lavcresample[=srate[:Länge[:linear[:Zähler[:Abschluss]]]]]
Ändert die Samplerate des Audiostreams zu einem Integerwert in Hz.
Unterstützt nur das 16-bit Native-Endian-Format.
.br
.I ANMERKUNG:
In Verbindung mit MEncoder musst du zusätzlich \-srate <srate> angeben.
.PD 0
.RSs
.IPs <srate>
die Samplerate der Ausgabe
.IPs <Länge>
Länge: Länge des Filters hinsichtlich der niedrigeren Samplerate (Standard: 16)
.IPs <linear>
Falls 1 werden die Filter zwischen Polyphase-Einträgen linear interpoliert.
.IPs <Zähler>
log2 der Anzahl der Polyphase-Einträge
(..., 10->1024, 11->2048, 12->4096, ...)
(Standard: 10->1024)
.IPs <Abschluss>
Abschlussfrequenz (0.0-1.0), Standardwert wird abhängig von der Filterlänge
gesetzt.
.RE
.PD 1
.
.TP
.B sweep[=Geschwindigkeit]
Erzeugt eine Sinus-Schwingung.
.PD 0
.RSs
.IPs <0.0\-1.0>
Sinusfunktions-Delta, benutze sehr geringe Werte, um die Schwingung zu hören.
.RE
.PD 1
.
.TP
.B hrtf[=flag]
Die "head-related transfer function": Konvertiert mehrkanäliges
Audiosignal auf zwei Kanäle für Kopfhörer, behält dabei die Räumlichkeit des
Klangs.
.sp 1
.PD 0
.RS
.IPs "Flag  Bedeutung"
.IPs "m     Matrixdecodierung des hinteren Kanals"
.IPs "s     2-Kanal-Matrixdecodierung"
.IPs "0     keine Matrixdecodierung (Standard)"
.RE
.PD 1
.
.TP
.B equalizer=[g1:g2:g3:...:g10]
Graphischer Equalizier, der im 10-Octaven-Frequenzbereich arbeitet; benutzt
10-IIR-Bandfilter.
Das bedeutet, dass er unabhängig davon funktioniert, welcher Art der
wiedergegebene Audiotyp ist.
Die mittleren Frequenzen für die 10 Frequenzbereiche sind:
.sp 1
.PD 0
.RS
.IPs "Nr.  Frequenz"
.IPs "0    31.25 Hz"
.IPs "1    62.50 Hz"
.IPs "2   125.00 Hz"
.IPs "3   250.00 Hz"
.IPs "4   500.00 Hz"
.IPs "5    1.00 kHz"
.IPs "6    2.00 kHz"
.IPs "7    4.00 kHz"
.IPs "8    8.00 kHz"
.IPs "9   16.00 kHz"
.RE
.PD 1
.sp 1
.RS
Falls die Samplerate des wiedergegebenen Klangs niedriger ist als die mittlere
Frequenz für einen Frequenzbereich, wird dieser Bereich deaktiviert.
Ein bekannter Fehler dieses Filters ist, dass die Charakteristiken für den
höchsten Bereich nicht komplett symmetrisch sind, wenn die Samplerate nah an
der mittleren Frequenz dieses Bereichs liegt.
Dieses Problem kann dadurch umgangen werden, dass man mit Hilfe des
Filters resample die Samplerate des Klangs erhöht, bevor er diesen Filter
erreicht.
.RE
.PD 0
.RSs
.IPs <g1>:<g2>:<g3>:...:<g10>
Fließkommawerte, die die Verstärkung in dB für jeden Frequenzbereich
repräsentieren (-12\-12)
.RE
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.IPs "mplayer \-af equalizer=11:11:10:5:0:-12:0:5:12:12 media.avi"
Würde den Klang im Bereich der oberen und unteren Frequenzen verstärken und
ihn gleichzeitig im Bereich um 1kHz fast verschwinden lassen.
.RE
.PD 1
.
.TP
.B channels=nch[:nr:from1:to1:from2:to2:from3:to3:...]
Kann benutzt werden, um Audiokanäle hinzuzufügen, zu entfernen, zu kopieren
oder deren Routing zu verändern.
Wenn nur <nch> gegeben ist, wird das Standardrouting benutzt, es funktioniert
folgendermaßen: Falls die Anzahl der Ausgabekanäle größer ist als die Anzahl
der Eingangskanäle, so werden leere Kanäle erzeugt (Ausnahme: Upmix von Mono
auf Stereo, dann wird der Monokanal auf beiden Ausgabekanälen wiederholt).
Ist die Anzahl der Ausgabekanäle kleiner als die Anzahl der Eingangskanäle,
so werden die überschüssigen Kanäle verworfen.
.PD 0
.RSs
.IPs <nch>
Anzahl der Ausgabekanäle (1\-6)
.IPs <nr>\ 
Anzahl der Leitungen für das Routing (1\-6)
.IPs <von1:bis1:von2:bis2:von3:bis3:...>
Paare von Nummers zwischen 0 und 5, die festlegen, wo das Routing für jeden
Kanal stattfinden soll.
.RE
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.IPs "mplayer \-af channels=4:4:0:1:1:0:2:2:3:3 media.avi"
Würde die Anzahl der Kanäle auf 4 setzen und 4 Routen aufsetzen, die die
Kanäle 0 und 1 vertauschen und die Kanäle 2 und 3 unberührt lassen.
Beachte, dass bei der Wiedergabe eines Mediums mit nur zwei Känalen die Kanäle
2 und 3 still wären, 0 und 1 aber trotzdem vertauscht würden.
.IPs "mplayer \-af channels=6:4:0:0:0:1:0:2:0:3 media.avi"
Würde die Anzahl der Kanäle auf 6 setzen und 4 Routen aufsetzen, die den Kanal
0 nach Kanal 0 und 3 kopieren.
Kanäle 4 und 5 werden keinen Ton enthalten.
.RE
.PD 1
.
.TP
.B format[=Format] (siehe auch \-format)
Konvertiert zwischen verschiedenen Sampleformaten.
Wird automatisch aktiviert, falls die Soundkarte oder ein anderer Filter dies
benötigt.
.PD 0
.RSs
.IPs <Format>
Setzt das gewünschte Format.
Die allgemeine Form is 'sbe', wobei 's' für 'signed' steht (alternativ 'u'
für 'unsigned'), 'b' die Anzahl der Bits pro Sample ist (16, 24 oder 32)
und 'e' die Endianness angibt ('le' heißt little-endian, 'be' big-endian; 'ne'
ist die Endianness des Computers, auf dem MPlayer läuft).
Gültige Werte (unter anderem) sind: 's16le', 'u32be' und 'u24ne'.
Ausnahmen dieser Regel, die auch gültige Formatangaben sind: u8, s8,
floatle, floatbe, floatne, mulaw, alaw, mpeg2, ac3 und imaadpcm.
.RE
.PD 1
.
.TP
.B volume[=v:sc]
Implementiert die Lautstärkeregulierung in Software.
Benutze diesen Filter mit Vorsicht, da er das Verhältnis von Signalstärke zum
Rauschen (signal to noise ratio) reduzieren kann.
In den meisten Fällen ist es am besten, das Level für den PCM-Sound auf
maximal zu stellen, diesen Filter wegzulassen und die Ausgabestärke zu den
Lautsprechern mit der Mixereinstellung Master zu regulieren.
In dem Falle, dass deine Soundkarte einen digitalen anstelle eines analogen
PCM-Mixers hat, benutze stattdessen die MASTER-Mixereinstellung.
Wenn ein externer Verstärker mit dem Computer verbunden ist (das ist fast
immer der Fall), kann das Rauschlevel minimiert werden, indem Master-Level und
der Lautstärkeregler am Verstärker angepasst werden, bis das Rauschen im
Hintergrund verschwunden ist.
.br
Dieser Filter hat ein zweites Feature: Er misst die insgesamt maximale
Lautstärke und gibt diese aus, wenn MPlayer beendet wird.
Diese Lautstärkeabschätzung kann benutzt werden, um die Lautstärke in MEncoder
so zu setzen, dass ein maximaler dynamischer Bereich benutzt wird.
.br
.I ANMERKUNG:
Dieser Filter ist nicht reentrant (ablaufinvariant) und kann dementsprechend
nur einmal pro Audiostream aufgerufen werden.
.PD 0
.RSs
.IPs <v>\ \ 
Setzt die gewünschte Verstärkung in dB für alle Kanäle in diesem Stream.
Die Verstärkung kann zwischen -200dB und +60dB liegen, wobei -200dB den
Sound komplett verstummen lässt und +60dB einer 1000-fachen Verstärkung
entspricht (Standard: 0).
.IPs <sc>\ 
Schaltet "Soft-Clipping" an (1) oder aus (0).
Soft-Clipping kann den Klang weicher machen, wenn sehr hohe Lautstärken
benutzt werden.
Benutze diese Option, wenn der dynamische Bereich der Lautsprecher sehr
niedrig ist.
.br
.I WARNUNG:
Dieses Feature bewirkt Störgeräusche und sollte als letzte Möglichkeit
angesehen werden.
.RE
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.IPs "mplayer \-af volume=10.1:0 media.avi"
Würde den Klang um 10.1dB verstärken und abschneiden, wenn die Lautstärke zu
hoch ist.
.RE
.PD 1
.
.TP
.B pan=n[:l01:l02:...l10:l11:l12:...ln0:ln1:ln2:...]
Mischt Kanäle beliebig.
Im Prinzip eine Kombination der Filter volume und channels, der benutzt werden
kann, viele Kanäle auf nur wenige herunterzumischen, z.B.\& stereo nach mono
oder das Verändern der "Breite" vom mittleren Lautsprecher in einem
Surroundsound-System.
Dieser Filter ist schwierig zu benutzen und wird etwas Herumprobieren
benötigen, bevor die gewünschten Ergebnisse eintreten.
Die Anzahl der Optionen für diesen Filter hängt von der Anzahl der
Ausgabekanäle ab.
Ein Beispiel dazu, wie mit diesem Filter eine 6-Kanal-Datei auf 2 Kanäle
heruntergemischt werden kann, findest du im Abschnitt Beispiele nahe dem Ende
der man page.
.PD 0
.RSs
.IPs <n>\ \ 
Anzahl der Eingabekanäle (1\-6).
.IPs <lij>
Gibt an, wieviel vom Eingabekanal j in den Ausgabekanal i gemischt wird (0\-1).
.RE
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.IPs "mplayer \-af pan=1:0.5:0.5 \-channels 1 media.avi"
Würde von stereo nach mono heruntermischen.
.IPs "mplayer \-af pan=3:1:0:1:0.5:0.5 \-channels 3 media.avi"
Würde 3 Ausgabekanäle liefern, Kanäle 0 und 1 bleiben intakt und der
Ausgabekanal 2 wäre die Mischung aus den Kanälen 0 und 1 (und könnte zum
Beispiel an eine Subwoofer geschickt werden).
.RE
.PD 1
.
.TP
.B sub[=fc:ch]
Fügt dem Audiostream einen Subwoofer-Kanal hinzu.
Die Audiodaten, die für die Erzeugung des Subwoofer-Kanals benutzt werden,
ist ein Durchschnitt des Klanges in Kanal 0 und Kanal 1.
Der resultierende Klang ist dann tiefpassgefiltert von einem
Butterworth-Filter vierten Ranges mit einem voreingestellten Abschnitt der
Frequenzen bei 60Hz und wird in einem separaten Kanal dem Audiostream
hinzugefügt.
.br
.I WARNUNG:
Deaktiviere diesen Filter, wenn du DVDs mit Dolby Digital 5.1-Klang abspielst,
sonst wird dieser Filter den Klang des Subwoofers stören.
.PD 0
.RSs
.IPs <fc>\ 
Ab dieser Frequenz schneidet der Tiefpassfilter ab (20Hz bis 300Hz)
(Standard: 60Hz).
Versuche für beste Resultate die Frequenz, ab der abgeschnitten
wird, so niedrig wie möglich zu setzten.
Das wird den Stereo- oder Surroundsound-Genuß erhöhen.
.IPs <ch>\ 
Bestimmt die Kanalnummer, in die der Sub-Kanal eingefügt werden soll.
Die Kanalnummer kann zwischen 0 und 5 liegen (Standard: 5).
Beachte, dass die Anzahl der Kanäle automatisch auf <ch> erhöht wird, sollte
es nötig sein.
.RE
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.IPs "mplayer \-af sub=100:4 \-channels 5 media.avi"
Würde einen Subwoofer-Kanal mit einer Abschlussfrequenz von 100Hz zum
Ausgabekanal 4 hinzufügen.
.RE
.PD 1
.
.TP
.B center\ 
Erzeugt aus den vorderen Kanälen einen mittleren Kanal.
Kann zur Zeit möglicherweise geringe Qualität liefern, da er keine
Hochpassfilter für eine entsprechende Extraktion besitzt, sondern nur über die
Kanäle mittelt und halbiert.
.PD 0
.RSs
.IPs <ch>\ 
Legt die Kanalnummer fest, in die der mittlere Kanal eingefügt werden soll.
Die Kanalnummer kann zwischen 0 und 5 liegen (Standard: 5).
Beachte dass die Anzahl der Kanäle automatisch auf <ch> erhöht wird, wenn es
nötig sein sollte.
.RE
.PD 1
.
.TP
.B surround[=Verzögerung]
Decoder für Matrix-encodierten Surroundsound, funktioniert bei vielen
Zweikanaldateien.
.PD 0
.RSs
.IPs <Verzögerung>
Verzögerung in ms für den hinteren Lautsprecher (0 bis 1000) (Standard: 20)
Diese Verzögerung sollte wie folgt gesetzt werden: Wenn d1 der Abstand ist,
von dem aus die vorderen Lautsprecher gehört werden, und d2 der Abstand ist,
von dem aus die hinteren Lautsprecher gehört werden, dann sollte die
Verzögerung auf 15ms gesetzt werden, falls d1 <= d2 und auf 15 + 5*(d1-d2),
falls d1 > d2.
.RE
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.IPs "mplayer \-af surround=15 \-channels 4 media.avi"
Würde Decodierung von Surroundsound hinzufügen mit einer Verzögerung von 15ms
für die hinteren Lautsprecher.
.RE
.PD 1
.
.TP
.B delay[=ch1:ch2:...]
Verzögert die Soundausgabe zu den Lautsprechern so, dass der Klang der
verschiedenen Kanäle die Position, an dem sie gehört werden, gleichzeitig
erreicht.
Das macht nur Sinn, wenn du mehr als 2 Lautsprecher hast.
.PD 0
.RSs
.IPs ch1,ch2,...
Die Verzögerung in ms, die jedem Kanal auferlegt wird (Fließkommazahl zwischen
0 und 1000).
.RE
.PD 1
.sp 1
.RS
Um die benötigte Verzögerung für die verschiedenen Kanäle zu berechnen, gehe
wie folgt vor:
.IP 1. 3
Messe die Entfernung der Lautsprecher in Metern in Relation zu der Position,
an der gehört wird, was dir die Entfernungen s1 bis s5 liefert (bei einem
5.1-System).
Für den Subwoofer macht Anpassung keinen Sinn (du wirst den Unterschied eh
nicht hören).
.IP 2. 3
Subtrahiere die Abstände s1 bis s5 von der maximalen Entfernung, z.B.\&
s[i] = max(s) - s[i]; i = 1...5.
.IP 3.
Berechne die benötigten Verzögerungen in ms als d[i] = 1000*s[i]/342; i =
1...5.
.RE
.PD 0
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.IPs "mplayer \-af delay=10.5:10.5:0:0:7:0 media.avi"
Würde die vordere Linke und Rechte um 10.5ms verzögern, die beiden hinteren
Kanäle und den Subwoofer um 0ms und Center um 7ms.
.RE
.PD 1
.
.TP
.B export[=mmapped_Datei[:nsamples]]
Exportiert das Eingangssignal an andere Prozesse mittels Memory Mapping
(mmap()).
Memory-mapped-Bereiche enhalten einen Header:
.sp 1
.nf
int nch                     /*Anzahl der Kanäle*/
int size                    /*Größe des Buffers*/
unsigned long long counter  /*Wird benutzt, um Synchronisation zu
                              wahren und aktualisiert, wenn neue
                              Daten exportiert werden.*/
.fi
.sp 1
Der Rest sind (nicht-interleaved) 16-bit-Daten über die Auslastung.
.PD 0
.RSs
.IPs <mmapped_Datei>
Datei, zur der die Daten exportiert werden sollen
(Standard: ~/\:.mplayer/\:mplayer-af_export).
.IPs <nsamples>
Anzahl der Samples pro Kanal (Standard: 512)
.RE
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.IPs "mplayer \-af export=/tmp/mplayer-af_export:1024 media.avi"
Würde 1024 Samples pro Kanal nach '/tmp/mplayer-af_export' exportieren.
.RE
.PD 1
.
.TP
.B extrastereo[=mul]
Erhöht den Unterschied zwischen linken und rechten Kanälen (linear), was der
Wiedergabe eine Art "Live"-Effekt hinzuzufügt.
.PD 0
.RSs
.IPs <mul>
Setzt den Differenz-Koeffizient (Standard: 2.5).
0.0 bedeutet Klang in mono (Durchschnitt beider Kanäle), bei 1.0 bleibt der
Klang unverändert, mit -1.0 werden linker und rechter Kanal vertauscht.
.RE
.PD 1
.
.TP
.B volnorm[=Methode]
Maximiert die Lautstärke, ohne den Klang zu verzerren.
.PD 0
.RSs
.IPs <Methode>
Setzt die zu benutzende Methode.
.RSss
1: Benutze ein einziges Sample, um die Abweichungen mit Hilfe eines
standardgewichteten Durchschnitts der vorigen Samples zu glätten (Standard).
.br
2: Benutze mehrere Samples, um die Abweichungen mit Hilfe eines
standardgewichteten Durchschnitts der vorigen Samples zu glätten.
.REss
.RE
.PD 1
.
.TP
.B ladspa=Datei:Label[:Kontrollen...]
Lade ein LADSPA (Linux Audio Developer's Simple Plugin API) Plugin.
Es können mehrere Filter gleichzeitig verwendet werden.
.PD 0
.RSs
.IPs <Datei>
Gibt eine Bibliotheksdatei des LADSPA-Plugins an.
Falls LADSPA_PATH gesetzt ist, wird nach der angegeben Datei gesucht.
Ist es nicht gesetzt, muss der volle Pfadname angegeben werden.
.IPs <Label>
Gibt den Filter innerhalb der Bibliothek an.
Manche Bibliotheken beinhalten nur einen Filter, andere aber enthalten mehrere.
Angabe von 'help' zeigt alle verfügbaren Filter innerhalb der angegebenen
Bibliothek, was die Benutzung von 'listplugins' des LADSPA SDK überflüssig
macht.
.IPs <Kontrollen>
Kontrollen sind null oder mehr Fließkommawerte, die das Verhalten des
geladenen Plugins bestimmen (zum Beispiel Verzögerung, Schwellenwert oder
Verstärkung).
Im ausführlichen Modus (füge \-v zur MPlayer-Kommandozeile hinzu) werden alle
Kontrollen und ihre dazugehörigen Wertebereiche ausgegeben.
Dies macht die Benutzung von 'analyseplugin' des LADSPA SDK überflüssig.
.RE
.PD 1
.
.TP
.B comp\ \ \ 
Kompressor/Expandier-Filter, der bei Input von einem Mikrophon benutzt werden
kann.
Verhindert Artefakte bei sehr lautem Klang und erhöht die Lautstärke bei sehr
leisem Klang.
Dieser Filter ist nicht getestet und möglicherweise unbrauchbar.
.
.TP
.B gate\ \ \ 
Ein das Rauschen beschränkender Filter, ähnlich dem Filter comp.
Dieser Filter ist nicht getestet und möglicherweise unbrauchbar.
.
.
.SH "VIDEOFILTER"
Videofilter erlauben dir, den Videostream und seine Eigenschaften zu ändern.
Die Syntax ist folgender:
.
.TP
.B \-vf <Filter1[=Parameter1:Parameter2:...],Filter2,...>
Aktiviert eine Videofilterkette zusammen mit ihren Optionen.
.
.TP
.B \-vop <...,Filter2[=Parameter1:Parameter2:...],Filter1> (OBSOLET)
Aktiviert eine Kette von Videofiltern zusammen mit ihren Optionen, die in
.B umgekehrter
Reihenfolge angewendet wird.
Wurde ersetzt durch \-vf.
.PP
Viele Parameter sind optional und werden teilweise mit Standardwerten belegt,
wenn sie weggelassen werden.
Mit '-1' werden die Standardwerte beibehalten.
Die Parameter w:h bedeuten Breite (width) und Höhe (height); x:y bedeutet
die x:y-Position relativ zur linken oberen Ecke des größeren Bildes.
.br
.I ANMERKUNG:
Eine vollständige Liste aller verfügbaren Plugins liefert \-vf help.
.sp 1
Videofilter werden in Listen verwaltet.
Es gibt ein paar Kommandos, um die Filterliste zu regeln.
.
.TP
.B \-vf-add <Filter1[,Filter2,...]>
Fügt die angegebenen Filter ans Ende der Filterliste hinzu.
.
.TP
.B \-vf-pre <Filter1[,Filter2,...]>
Fügt die angegebenen Filter an den Anfang der Filterliste hinzu.
.
.TP
.B \-vf-del <Index1[,Index2,...]>
Löscht die Filter an der angegebenen Indexposition.
Indexnummern beginnen bei 0, negative Nummern adressieren das Ende der Liste
(-1 ist der letzte).
.
.TP
.B \-vf-clr
Leert die Filterliste komplett.
.PP
Bei Filtern, die dies unterstützen, kannst Du auf Parameter über den Namen
zugreifen.
.
.TP
.B \-vf <filter>=help
Gibt die Parameternamen und die gültigen Wertebereiche der Parameter für einen
bestimmen Filter aus.
.
.TP
.B \-vf <Filter=benannter_Parameter1=Wert1[:benannter_Parameter2=Wert2:...]>
Setzt einen benannten Parameter auf den angegebenen Wert.
Benutze 'on' und 'off' oder 'yes' und 'no', um Flag-Parameter zu setzen.
.PP
Die verfügbaren Filter sind folgende:
.
.TP
.B crop[=b:h:x:y]
Schneidet den angegeben Teil des Bildes aus und verwirft den Rest.
Nützlich, um schwarze Balken bei Widescreen-Filmen zu entfernen.
.PD 0
.RSs
.IPs <b>,<h>
Abgeschnittene Breite und Höhe, ist voreingestellt auf die originale Breite
und Höhe.
.IPs <x>,<y>
Position des abgeschnittenen Bildes, ist voreingestellt auf die Mitte.
.RE
.PD 1
.
.TP
.B cropdetect[=Limit:Rundung]
Berechnet die Schneideparameter für den crop-Filter und gibt die empfohlenen
Parameter auf die Standardausgabe aus.
.PD 0
.RSs
.IPs <Limit>
Schwellenwert, der optional angegeben werden kann als nichts (0) bis hin zu
allem
(255) (Standard: 24).
.br
.IPs <Rundung>
Wert, durch den die Breite/\:Höhe teilbar sein sollte (Standard: 16).
Der Offset wird automatisch angepasst, um das Video zu zentrieren.
Benutze 2, um gerade Dimensionen zu bekommen (wird für 4:2:2-Video gebraucht).
16 ist beim Encodieren für die meisten Videocodecs die beste Wahl.
.RE
.PD 1
.
.TP
.B rectangle[=b:h:x:y]
Das Plugin reagiert auf die Direktive 'change_rectangle' der Datei input.conf,
die zwei Parameter entgegennimmt.
.PD 0
.RSs
.IPs <b>,<h>
Breite und Höhe (Standard: -1, maximal mögliche Breite, wobei die Begrenzungen
sichtbar bleiben)
.IPs <x>,<y>
Position der linken oberen Ecke (Standard: -1, ganz oben, ganz links)
.RE
.PD 1
.
.TP
.B expand[=b:h:x:y:o]
Vergrößert das Bild ohne Skalierung auf die angegebene Größe und
platziert das unskalierte Originalbild an die Koordinaten x/\:y.
Kann benutzt werden, um die Platzierung des OSD/\:der Untertitel auf
schwarzen Balken zu erreichen.
.RSs
.IPs <b>,<h>
Expandierte Breite,Höhe (Standard: originale Breite,Höhe).
Negative Werte für b und h werden als Offsets zur Originalgröße behandelt.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IP expand=0:-50:0:0
Fügt unterhalb des Bildes einen Rand von 50 Pixel ein.
.RE
.PD 1
.IPs <x>,<y>
Position des ursprünglichen Bildes im expandierten Bild (Standard: Mitte)
.IPs <o>\ \ 
Anzeige von OSD/\:Untertiteln
.RSss
0: deaktiviert (Standard)
.br
1: aktiviert
.REss
.RE
.
.TP
.B flip (siehe auch \-flip)
Stellt das Bild auf den Kopf.
.
.TP
.B mirror\ 
Spiegelt das Bild an der Y-Achse.
.
.TP
.B rotate[=<0\-7>]
Dreht das Bild um +/\:- 90 Grad (und stellt es optional auf den Kopf).
Bei 4\-7 wird das Bild nur dann gedreht, wenn es vorher hochkant war
(es also höher als breit ist).
.
.TP
.B scale[=b:h[:interlaced[:chr_drop[:param[:param2[:presize]]]]]]
Skaliert das Bild mit dem Softwareskalierer (langsam) und führt eine
Farbraumkonvertierung zwischen YUV und RGB durch (siehe auch \-sws).
.RSs
.IPs <b>,<h>
skalierte Breite/\:Höhe (Standard: originale Breite/\:Höhe)
.br
.I ANMERKUNG:
Wenn \-zoom benutzt wird und die unterliegenden Filter (inklusive libvo)
Skalierung nicht unterstützen, werden die Werte d_width/\:d_height benutzt.
.\" FIXME: Klärung von d_width/\:d_height!
.RSss
 0:   skalierte d_width/\:d_height
.br
-1:   originale Breite/\:Höhe
.br
-2:   Berechne Breite/\:Höhe anhand der jeweils anderen Größe und dem
vorskalierten Breiten-/\:Höhenverhältnis.
.br
-3:   Berechne Breite/\:Höhe anhand der jeweils anderen Größe und dem
originalen Breiten-/\:Höhenverhältnis.
.br
-(n+8): wie -n oben, rundet aber die Abmessung auf das nächste Vielfache von
16.
.REss
.IPs <interlaced>
Schalte Interlaced-Skalierung an/\:aus.
.RSss
0: aus (Standard)
.br
1: ein
.REss
.IPs <chr_drop>
Chroma-Skipping, Auslassen von Chrominanz-Berechnungen
.RSss
0: Benutze alle verfügbaren Eingabelinien für Chrominanz-Berechnungen.
.br
1: Benutze nur jede zweite Eingabelinie für Chrominanz-Berechnungen.
.br
2: Benutze nur jede vierte Eingabelinie für Chrominanz-Berechnungen.
.br
3: Benutze nur jede achte Eingabelinie für Chrominanz-Berechnungen.
.REss
.IPs "<param>:[:<param2>] (siehe auch \-sws)"
Setzt einige Skalierungsparameter abhängig vom Skalierer, der mit \-sws
gewählt wurde.
.RSss
\-sws 2 (bicubic):  B (weichzeichnend) und C (verstärkend)
.br
0.00:0.60 Standard
.br
0.00:0.75 "precise bicubic" von VirtualDub
.br
0.00:0.50 Catmull-Rom spline
.br
0.33:0.33 Mitchell-Netravali spline
.br
1.00:0.00 cubic B-spline
.br
\-sws 7 (gaussian): Schärfe (0 (weich) \- 100 (scharf))
.br
\-sws 9 (lanczos):  Filterlänge (1\-10)
.REss
.IPs <presize>
Skaliere auf eine Standardgröße.
.RSss
qntsc:   352x240 (NTSC Quarter-Screen)
.br
qpal:    352x288 (PAL Quarter-Screen)
.br
ntsc:    720x480 (Standard-NTSC)
.br
pal:     720x576 (Standard-PAL)
.br
sntsc:   640x480 (NTSC mit quadratischen Pixeln)
.br
spal:    768x576 (PAL mit quadratischen Pixeln)
.REss
.RE
.
.TP
.B dsize={Aspekt|b:h}
Ändert die beabsichtigte Displaygröße/\:den Aspekt an einer frei wählbaren
Position der Filterkette.
Der Aspekt kann als Bruch (4/\:3) oder Fließkommazahl (1.33) angegeben werden.
Alternativ können exakte Wiedergabebreite und -höhe wie gewünscht angegeben
werden.
Beachte, dass dieser Filter selbst
.B keine
Skalierung vornimmt; er beeinflusst nur, was spätere Skalierer (Software oder
Hardware) beim automatischen Skalieren tun werden, um den Aspekt zu
korrigieren.
.
.TP
.B yuy2\ \ \ 
Erzwingt YV12/\:I420/\:422P zu YUY2-Konvertierung in Software.
Nützlich bei Videokarten/\:Treibern mit langsamer YV12- aber
schneller YUY2-Unterstützung.
.
.TP
B yvu9\ \ \ 
Erzwingt eine Software-Farbraumkonvertierung von YVU9 nach YV12.
Zu Gunsten des Softwareskalierers abgelehnt.
.
.TP
.B yuvcsp\ 
Zieht die YUV-Farbwerte auf den CCIR 601-Bereich zusammen, ohne eine
wirkliche Konvertierung vorzunehmen.
.
.TP
.B rgb2bgr[=swap]
Farbraumkonvertierung RGB 24/\:32 <\-> BGR 24/\:32
.PD 0
.RSs
.IPs swap\ 
Führe auch eine R <-> B-Vertauschung durch.
.RE
.PD 1
.
.TP
.B palette
Farbraumkonvertierung RGB/\:BGR 8 \-> 15/\:16/\:24/\:32bpp unter Verwendung
einer Farbpalette.
.
.TP
.B format[=fourcc]
Beschränkt den Farbraum des nächsten Filters ohne wirkliche Konvertierung.
Benutze ihn zusammen mit dem scale-Filter, um tatsächlich eine Konvertierung
durchzuführen.
.br
.I ANMERKUNG:
Für eine Liste der verfügbaren Formate siehe format=fmt=help.
.PD 0
.RSs
.IPs <fourcc>
Formatname wie rgb15, bgr24, yv12 usw.\& (Standard: yuy2)
.RE
.PD 1
.
.TP
.B noformat[=fourcc]
Beschränkt den Farbraum des nächsten Filters ohne wirkliche Konvertierung.
Anders als der format-Filter erlaubt dieser jeden Farbraum
.B außer
dem von dir angegebenen.
.br
.I ANMERKUNG:
Für eine Liste der verfügbaren Formate siehe noformat=fmt=help.
.PD 0
.RSs
.IPs <fourcc>
Formatname wie rgb15, bgr24, yv12 usw.\& (Standard: yv12)
.RE
.PD 1
.
.TP
.B pp[=Filter1[:Option1[:Option2...]]/[-]Filter2...] (siehe auch \-pphelp)
Diese Option aktiviert die Benutzung von MPlayers internen
Postprocessing-Filtern.
Unterfilter müssen durch ein '/'\-Zeichen voneinander getrennt werden und
können durch ein vorangestelltes '\-' deaktiviert werden.
Jeder Unterfilter und manche Optionen haben einen kurzen und einen langen
Namen, die abwechselnd benutzt werden können, z.B.\& dr/dering gleichzeitig.
Alle Unterfilter teilen gemeinsame Optionen, um ihren Geltungsbereich zu
bestimmen:
.PD 0
.RSs
.IPs a/autoq
Schalte den Unterfilter automatisch aus, falls die CPU zu langsam ist.
.IPs c/chrom
Führe außerdem Chrominanz-Filterung durch (Standard).
.IPs y/nochrom
Führe nur Luminanz-Filterung durch (keine Chrominanz).
.IPs n/noluma
Führe nur Chrominanz-Filterung durch (keine Luminanz).
.RE
.PD 1
.sp 1
.RS
.br
.I ANMERKUNG:
\-pphelp zeigt eine Liste der verfügbaren Unterfilter.
.sp 1
Verfügbare Unterfilter sind folgende:
.RE
.RSs
.IPs hb/hdeblock[:Differenz[:Flachheit]]
horizontaler Deblocking-Filter
.RSss
<Differenz>: Differenzfaktor, wobei größere Werte mehr Deblocking
bedeuten (Standard: 32).
.br
<Flachheit>: Schwellenwert für die Flachheit, wobei niedrigere Werte
mehr Deblocking bedeuten (Standard: 39).
.REss
.IPs vb/vdeblock[:Differenz[:Flachheit]]
vertikaler Deblocking-Filter
.RSss
<Differenz>: Differenzfaktor, wobei größere Werte mehr Deblocking
bedeuten (Standard: 32).
.br
<Flachheit>: Schwellenwert für die Flachheit, wobei niedrigere Werte
mehr Deblocking bedeuten (Standard: 39).
.REss
.IPs ha/hadeblock[:Differenz[:Flachheit]]
genauer horizontaler Deblocking-Filter
.RSss
<Differenz>: Differenzfaktor, wobei größere Werte mehr Deblocking
bedeuten (Standard: 32).
.br
<Flachheit>: Schwellenwert für die Flachheit, wobei niedrigere Werte
mehr Deblocking bedeuten (Standard: 39).
.REss
.IPs va/vadeblock[:Differenz[:Flachheit]]
genauer vertikaler Deblocking-Filter
.RSss
<Differenz>: Differenzfaktor, wobei größere Werte mehr Deblocking
bedeuten (Standard: 32).
.br
<Flachheit>: Schwellenwert für die Flachheit, wobei niedrigere Werte
mehr Deblocking bedeuten (Standard: 39).
.REss
.sp 1
Die horizontalen und vertikalen Deblocking-Filter benutzen die Werte
für Differenz und Flachheit gemeinsam, du kannst daher keine unterschiedlichen
horizontalen und vertikalen Schwellenwerte angeben.
.sp 1
.IPs h1/x1hdeblock
experimenteller horizontaler Deblocking-Filter
.IPs v1/x1vdeblock
experimenteller vertikaler Deblocking-Filter
.IPs dr/dering
Störungsfilter
.IPs tn/tmpnoise[:Schwelle1[:Schwelle2[:Schwelle3]]]
Reduzierung zeitweisen Rauschens
.RSss
<Schwelle1>: größer -> stärkere Filterung
.br
<Schwelle2>: größer -> stärkere Filterung
.br
<Schwelle3>: größer -> stärkere Filterung
.REss
.IPs al/autolevels[:f/fullyrange]
automatische Korrektur von Helligkeit und Kontrast
.RSss
f/fullyrange: Ausdehnung der Luminanz auf (0\-255).
.REss
.IPs lb/linblenddeint
Linearer Mischungs-Deinterlace-Filter, der Deinterlacing eines gegebenen
Blocks durch Filterung mit einem (1 2 1)-Filter durchführt.
.IPs li/linipoldeint
Linearer Interpolations-Deinterlace-Filter, der Deinterlacing eines gegebenen
Blocks durch lineare Interpolation jeder zweiten Zeile durchführt.
.IPs ci/cubicipoldeint
Cubischer Interpolations-Deinterlace-Filter, der Deinterlacing eines gegebenen
Blocks durch cubische Interpolation jeder zweiten Zeile durchführt.
.IPs md/mediandeint
Median-Deinterlace-Filter, der Deinterlacing eines gegebenen Blocks durch
Medianfilterung jeder zweiten Zeile durchführt.
.IPs fd/ffmpegdeint
FFmpeg-Deinterlace-Filter, der Deinterlacing eines gegebenen Blocks durch
Filterung jeder zweiten Zeite mit einem (-1 4 2 4 -1)-Filter durchführt.
.IPs l5/lowpass5
Vertikal angewendeter FIR-Tiefpass-Deinterlace-Filter, der Deinterlacing eines
gegebenen Blocks durch Filterung aller Zeilen mit einem (-1 2 6 2 -1)-Filter
durchführt.
.IPs fq/forceQuant[:Quantisierungsparameter]
Überschreibt die Quantisierungstabelle der Eingabe mit einem konstanten
Quantisierungsparameter, den du angibst.
.RSss
<Quantisierungsparameter>: zu benutzender Quantisierungsparameter
.REss
.IPs de/default
Standard-pp-Filterkombination (hb:a,vb:a,dr:a)
.IPs fa/fast
schnelle pp-Filterkombination (h1:a,v1:a,dr:a)
.IPs ac\ \ \ 
hochqualitative pp-Filterkombination (ha:a:128:7,va:a,dr:a)
.RE
.RS
.sp 1
.I BEISPIEL:
.RE
.PD 0
.RSs
.IPs "\-vf pp=hb/vb/dr/al"
horizontales und vertikales Deblocking, Abschwächung und automatische
Helligkeit/\:Kontrast
.IPs "\-vf pp=de/-al"
Standardfilter ohne Helligkeits\-/\:Kontrastkorrektur
.IPs "\-vf pp=default/tmpnoise:1:2:3"
Aktiviert Standardfilter und temporäre Rauschunterdrücker.
.IPs "\-vf pp=hb:y/vb:a"
Horizontales Deblocking nur luminanz-bezogen, schaltet vertikales Deblocking
je nach verfügbarer CPU-Auslastung hinzu.
.RE
.PD 1
.
.TP
.B spp[=Qualität[:qp[:Modus]]]
einfacher Nachbearbeitungsfilter
.RSs
.IPs <Qualität>
0\-6 (Standard: 3)
.IPs <qp>\ 
Erzwinge Quantisierungsparameter (Standard: 0, benutze QP vom Video).
.IPs <Modus>
0: harter Schwellenwert (Standard)
.br
1: weicher Schwellenwert (bessere Entschärfung, aber unschärfer)
.RE
.
.TP
.B qp=Gleichung
Quantisierungsparameter- (QP) Wechselfilter
.RSs
.IPs <Gleichung>
eine Gleichung wie "2+2*sin(PI*qp)"
.RE
.
.TP
.B test\ \ \ 
Generiere verschiedene Testmuster.
.
.TP
.B rgbtest
Generiere ein RGB-Testmuster, nützlich, um RGB/\:BGR-Probleme zu erkennen.
Du solltest einen roten, grünen und blauen Streifen von oben nach unten sehen.
.
.TP
.B lavc[=Qualität:fps]
Schnelle Softwarekonvertierung mit libavcodec für die Benutzung von
DVB/\:DXR3.
Schnellere und bessere Qualität als mit \-vf fame.
.RSs
.IPs <Qualität>
.RSss
1\-31: feste qscale
.br
32\-:  feste Bitrate in kBit
.REss
.IPs <fps>
Erzwinge Ausgabe-fps (Fließkommawert) (Standard: 0, automatische
Erkennung basierend auf Höhe)
.RE
.
.TP
.B fame\ \ \ 
Schnelle Softwarekonvertierung mit libfame für die Benutzung von
DVB/\:DXR3.
.
.TP
.B dvbscale[=Verhältnis]
Wählt die optimale Skalierung für DVB-Karten, skaliert hardwareseitig
die X-Achse und berecht die Y-Achse softwareseitig, um den Aspekt
beizubehalten.
Nützlich nur in Verbindung mit expand und scale.
.RSs
.IPs <Verhältnis>
Kontrolliere das Seitenverhältnis, berechnet durch DVB_HÖHE*VERHÄLTNIS
(Standard:
576*4/\:3=768), setze auf 576*(16/\:9)=1024 für einen 16:9-Fernseher.
.RE
.sp 1
.RS
.I BEISPIEL:
.RE
.PD 0
.RSs
.IPs "\-vf dvbscale,scale=-1:0,expand=-1:576:-1:-1:1,lavc"
.\" FIXME: Erkläre, was dieser Befehl bewirkt.
.RE
.PD 1
.
.TP
.B "noise[=Helligkeit[u][t|a][h][p]:Farbwert[u][t|a][h][p]]"
Fügt Rauschen hinzu.
.PD 0
.RSs
.IPs <0\-100>
Helligkeitsrauschen
.IPs <0\-100>
Farbrauschen
.IPs u
gleichförmiges Rauschen (sonst gaußsch)
.IPs t
temporäres Rauschen (Rauschmuster wechselt zwischen Bildern)
.IPs a
gemitteltes temporäres Rauschen (weicher, aber viel langsamener)
.IPs h
hohe Qualität (sieht etwas besser aus, dafür etwas langsamer)
.IPs p
Mische Rauschen mit einem (halbwegs) gleichmäßigen Muster
.RE
.PD 1
.
.TP
.B "denoise3d[=Helligkeit:Farbwert:Zeit]"
Dieser Filter versucht, Bildrauschen zu unterdrücken und so bewegungslose
Bilder wirklich statisch zu machen (was das Bild besser komprimierbar macht).
.PD 0
.RSs
.IPs <Helligkeit>
räumliche Helligkeitsstärke (Standard = 4)
.IPs <Farbwert>
räumliche Farbstärke (Standard = 3)
.IPs <Zeit>
zeitliche Stärke (Standard = 6)
.RE
.PD 1
.
.TP
.B hqdn3d[=Helligkeit:Farbwert:Zeit]
Hochpräzise und -qualitative Version des Denoise3d-Filters.
Parameter und Gebrauch sind dieselben.
.
.TP
.B eq[=Helligkeit:Kontrast] (OBSOLET)
Softwareequalizer mit interaktiver Kontrolle wie beim Hardwareequalizer, für
Karten/\:Treiber, die die Kontrolle über Helligkeit und Kontrast via Hardware
nicht unterstützen.
Kann in Verbindung mit MEncoder nützlich sein; einerseits, um schlecht 
aufgenommene Filme zu reparieren, und zum anderen, um Artifakte zu maskieren
und niedrigere Bitraten benutzen zu können.
.PD 0
.RSs
.IPs <-100\-100>
initiale Helligkeit
.IPs <-100\-100>
initialer Kontrast
.RE
.PD 1
.
.TP
.B eq2[=gamma:Kontrast:Helligkeit:Sättigung:rg:gg:bg:weight]
Alternativer Softwareequalizer, der Lookup-Tabellen benutzt (sehr langsam).
Er erlaubt neben simpler Anpassung der Helligkeit, des Kontrastes und der
Sättigung auch eine Gammakorrektur.
Beachte, dass er den gleichen MMX-optimierten Code benutzt wie \-vf eq, wenn
alle Gammawerte 1.0 betragen!
Die Parameter werden als Fließkommazahlen angegeben.
.PD 0
.RSs
.IPs <0.1\-10>
initialer Gammawert (Standard: 1.0)
.IPs <-2\-2>
initialer Kontrast, wobei negative Werte ein Negativbild bewirken
(Standard: 1.0)
.IPs <-1\-1>
initiale Helligkeit (Standard: 0.0)
.IPs <0\-3>
initiale Sättigung (Standard: 1.0)
.IPs <0.1\-10>
Gammawert der roten Komponente (Standard: 1.0)
.IPs <0.1\-10>
Gammawert der grünen Komponente  (Standard: 1.0)
.IPs <0.1\-10>
Gammawert der blauen Komponente  (Standard: 1.0)
.IPs <0\-1>
Der Parameter weight kann verwendet werden, um die Wirkung hoher Gammawerte auf
helle Bildbereiche zu reduzieren, sie also davon abzuhalten
zu übersteuern und ganz weiss zu werden.
Bei 0.0 hat die Gammakorrektur gar keinen Effekt mehr, bei 1.0 hat sie die
volle Stärke.
.RE
.PD 1
.
.TP
.B hue[=Farbton:Sättigung]
Softwareequalizer mit interaktiver Kontrolle wie beim Hardwareequalizer, für
Karten/\Treiber, die Farbton- und Sättigungskontrolle nicht in Hardware
unterstützen.
.PD 0
.RSs
.IPs <-180\-180>
initiale Farbtonstärke (Standard: 0.0)
.IPs <-100\-100>
initiale Sättigung, wobei negative Werte zu negativer Chrominanz führen
(Standard: 1.0)
.RE
.PD 1
.
.TP
.B halfpack[=f]
Konvertiert planaeres YUV 4:2:0 in halbhohes, gepacktes 4:2:2, wobei
der Farbanteil beibehalten und die Helligkeit nach unten angepasst wird.
Nützlich bei Ausgaben auf Geräte mit niedriger Auflösung, bei denen
die Hardwareskalierung schlechte Qualität liefert oder nicht verfügbar ist.
Kann auch als primitiver Deinterlacer benutzt werden, der nur auf dem
Helligkeitsanteil arbeitet und sehr wenig CPU-Leistung erfordert.
.PD 0
.RSs
.IPs <f>\ \ 
In der Voreinstellung bildet halfpack  beim Downsampling den Durchschnitt
mehrer Zeilen.
Jeder von 0 oder 1 verschiedene Wert liefert das Standardverhalten.
.RSss
0: Benutze beim Downsampling nur die geraden Zeilen.
.br
1: Benutze beim Downsampling nur die ungeraden Zeilen.
.REss
.RE
.PD 1
.
.TP
.B ilpack[=Modus]
Wenn interlaced-Videos in YUV 4:2:0-Formaten gespeichert wird, wird das
Interlacing der Chrominanz wegen vertikalen Resamplings der Chrominanzkanäle
nicht an den richtigen Stellen dargestellt.
Dieser Filter packt die planaren 4:2:0-Daten in das YUY2 (4:2:2)-Format
mit den Chrominanzlinien an den richten Stellen.
So kommen die Daten für Helligkeit und Chrominanz für jede Linie vom selben
Feld.
.PD 0
.RSs
.IPs <Modus>
Wähle den Sampling-Modus.
.RSss
0: Sampling-Methode des nächstgelegenen Nachbars (nearest-neighbor), schnell
oder ungenau
.br
1: lineare Interpolation (Standard)
.REss
.RE
.PD 1
.
.TP
.B harddup
Nur in Verbindung mit MEncoder nützlich.
Wenn harddup bei der Encodierung verwendet wird, sorgt es dafür, daß doppelte
Frames auch im encodierten Output doppelt vorkommen.
Dies verbraucht sehr wenig mehr an Platz, ist jedoch für die Ausgabe in
MPEG-Dateien nötig oder dann, wenn der Videostream nach der Encodierung
getrennt und neu zusammengesetzt werden soll (demux bzw.\& remux).
Die Option sollte am oder nahe am Ende der Filterkette stehen, es sei denn, du
hast einen guten Grund, es anders zu machen.
.
.TP
.B softskip
Nur in Verbindung mit MEncoder nützlich.
Softskip verschiebt den Schritt des Encodierungsvorgangs, Frames zu
Überspringen (Wegzulassen) von der Position vor der Filterkette in die
Filterkette hinein.
Dies erlaubt denjenigen Filtern, die alle Frames untersuchen müssen
(umgekehrtes Telecine, temporäre Rauschunterdrückung), korrekt zu arbeiten.
Sollte nach den Filtern, die alle Frames untersuchen müssen, platziert werden
und vor all denjenigen, die CPU-intensiv sind.
.
.TP
.B decimate[=max:hi:lo:frac]
Lässt Frames weg, die sich nicht sehr on den vorigen unterscheiden, um die
Framerate zu reduzieren.
Die Hauptanwendung für diesen Filters ist die Encodierung bei sehr niedrigen
Bitraten (z.B.\& Streaming über eine Modemverbindung), er kann aber
theoretisch auch dazu benutzt werden, Filme zu reparieren, die mit
inversed-telecine fehlerhaft encodiert worden sind.
.PD 0
.RSs
.IPs <max>
Setzt eine obere Grenze für die Anzahl aufeinanderfolgender Frames, die
weggelassen werden können (falls positiv), sonst das kleinste Intervall
zwischen weggelassenen Frames (falls negativ).
.IPs <hi>,<lo>,<frac>
Ein Frame ist Kanditat dafür, weggelassen zu werden, falls keine 8x8-Region
sich mehr unterscheidet als der Schwellenwert <hi> angibt und falls sich nicht
mehr als der Anteil <frac> angibt (wobei 1 das ganze Bild bedeutet) vom
Schwellenwert <lo> unterscheidet.
Werte für <hi> und <lo> beziehen sich auf 8x8-Pixelblöcke und repräsentieren
aktuelle Unterschiede der Pixelwerte.
Ein Schwellenwert von 64 entspricht einer Einheit im Unterschied für jeden
Pixel oder derselben unterschiedlichen Ausbreitung über einen Block.
.RE
.PD 1
.
.TP
.B dint[=sense:level]
Der verwerfende Deinterlace-Filter (drop-deinterlace, dint) erkennt und
verwirft den ersten einer Gruppe von interlaced Frames.
.PD 0
.RSs
.IPs <0.0\-1.0>
relative Differenz zwischen benachbarten Pixeln (Standard: 0.1)
.IPs <0.0\-1.0>
Wie groß der als interlaced erkannte Teil eines Bildes sein muß, damit der
Frame verworfen wird (Standard: 0.15).
.RE
.PD 1
.
.TP
.B lavcdeint (VERALTET)
FFmpeg-Deinterlace-Filter, gleichbedeutend mit \-vf pp=fd
.
.TP
.B kerndeint[=thresh[:map[:order[:sharp[:twoway]]]]]
Donald Grafts adaptiver Kernel-Deinterlacer.
Führt ein Deinterlacing von Teilen des Videos durch, falls ein
wählbarer Schwellenwert überschritten wird.
.PD 0
.RSs
.IPs <0\-255>
Schwellenwert (Standard 10)
.IPs <map>
.RSss
0: Ignoriere Pixel, die den Schwellenwert überschreiten (Standard).
.br
1: Färbt Pixel, die den Schwellenwert überschreiten, weiß.
.REss
.IPs <order>
.RSss
0: Rühre die Felder nicht an (Standard).
.br
1: Tausche die Felder.
.REss
.IPs <sharp>
.RSss
0: Deaktiviert zusätzliches Schärfen (Standard).
.br
1: Fügt zusätzlich Schärfe hinzu.
.REss
.IPs <twoway>
.RSss
0: Deaktiviert zwei-Wege-Schärfung (default).
.br
1: Aktiviert zwei-Wege-Schärfung.
.REss
.RE
.PD 1
.
.TP
.B "unsharp=l|cBxH:Menge[:l|cWxH:Menge]"
Unschärfefilter / Gaußscher Weichzeichner
.RS
.IPs l\ \ \ \ 
Wendet den Effekt auf den Helligkeitsanteil an.
.IPs c\ \ \ \ 
Wendet den Effekt auf den Farbanteil an.
.IPs <Breite>x<Höhe>
Breite und Höhe der Matrix, die in beide Richtungen
ungerade sein muss (min = 3x3, max = 13x11 oder 11x13, normalerweise
zwischen 3x3 und 7x7).
.IPs Menge
relative "Menge" der Schärfe/\:Unschärfe, die dem Bild hinzugefügt
wird (ein vernünftiger Bereich ist -1.5\-1.5).
.RSss
<0: weichzeichnen
.br
>0: schärfen
.REss
.RE
.
.TP
.B swapuv\ 
Vertauscht die U- und V-Ebene.
.
.TP
.B il=[d|i][s][:[d|i][s]]
Führt ein (De)Interleaving von Zeilen durch.
Das Ziel dieses Filters ist es, die Bearbeitung von interlaced Bildern zu
ermöglichen, ohne sie vorher zu deinterlacen.
Du kannst eine interlaced DVD filtern und am Fernseher ausgeben, ohne
das Interlacing zu entfernen.
Die meisten Filter deinterlacen permanent (smoothing, averaging, etc).
Dieser Filter hingegen teilt das Bild in zwei Felder auf (sogenannte
Halbbilder),
so dass diese unabhängig voneinander gefiltert und wieder interleavt werden
können.
.PD 0
.RSs
.IPs d
deinterleave, entschachteln (einen über dem anderen plazieren)
.IPs i
interleave, verschachteln
.IPs s
vertauschen der Felder (gerade und ungerade Zeilen austauschen)
.RE
.PD 1
.
.TP
.B fil=[i|d]
Führt ein (De)Interleaving von Zeilen durch.
Dieser Filter ist dem il-Filter sehr ähnlich, jedoch viel schneller.
Der Hauptnachteil ist, dass er nicht immer funktioniert.
Besonders in Kombination mit anderen Filtern kann es zu zufällig gestörten
Bildern kommen.
Sei also froh, wenn es funktioniert, beschwere dich aber nicht, falls bei
deiner Filterkombination Fehler auftreten.
.PD 0
.RSs
.IPs d
Deinterleave der Felder, platziert beide Seite an Seite.
.IPs i
Erneutes Interleave der Felder (kehrt den Effekt von fil=d um).
.RE
.PD 1
.
.TP
.B field[=n]
Extrahiert ein einzelnes Feld eines interlaced Bildes mit Stride-Arithmetik,
um Verschwendung von CPU-Zeit zu vermeiden.
Der optionale Parameter n gibt an, ob das gerade oder ungerade Feld extrahiert
wird (abhängig davon, ob n selber gerade oder ungerade ist).
.
.TP
.B detc[=Var1=Wert1:Var2=Wert2:...]
Versucht, den 'Telecine'-Prozess umzukehren, um einen sauberen,
nicht-interlaced-Stream mit der Framerate des Films wiederherzustellen.
Dieser war der erste und primitivste Inverse-Telecine-Filter, der zu
MPlayer/\:MEncoder hinzugefügt wurde.
Er speichert Telecine-3:2-Muster zwischen und folgt ihnen soweit wie möglich.
Dies macht in tauglich für perfekt-telecined Material, selbst bei
Vorhandensein eines gewissen Grades an Störung.
Er wird jedoch nicht funktionieren bei Vorhandensein komplexer
Post-Telecine-Änderungen.
Die Entwicklung an diesem Filter findet nicht weiter statt, da ivtc, pullup
und filmdint für die meisten Anwendungen besser geeignet sind.
Die folgenden Argumente (Syntax siehe oben) steuern das Verhalten des
detc-Filters:
.RSs
.IPs <dr>\ 
Setzt den Framedropping-Modus.
.RSss
0: Kein Frame wird ausgelassen, um die Framerate der Ausgabe beizubehalten
(Standard).
.br
1: Ein Frame wird immer dann verworfen, wenn es keine Auslassungen oder
Telecine-Zusammenführungen innerhalb der letzten 5 Frames gab.
.br
2: Ein ständiges Verhältnis von 5:4 der Eingabe zur Ausgabe wird beibehalten.
.br
.I ANMERKUNG:
Benutze Modus 1 oder 2 mit MEncoder.
.REss
.IPs <am>\ 
Analyse-Modus.
.RSss
0: Festgelegtes Muster mit initialer Anzahl der Frames angegeben durch <fr>.
.br
1: aggressive Suche nach Telecine-Muster (Standard).
.REss
.IPs <fr>\ 
Setzt die initiale Anzahl der Frames in Folge.
0\-2 sind die drei sauberen, progressiven Frames; 3 und 4 sind die beiden
interlaced-Frames.
Der Standardwert, -1, bedeutet 'nicht in Telecine-Abfolge'.
Die hier angegebene Zahl gibt den Typ des imaginären vorigen Frames an, bevor
der Film beginnt.
.IPs "<t0>, <t1>, <t2>, <t3>"
Schwellenwerte, die in bestimmten Modi verwendet werden.
.RE
.
.TP
.B ivtc[=1]
Experimenteller 'zustandsloser' Inverse-Telecine-Filter.
Anstatt zu versuchen, ein Muster zu finden, wie es der detc-Filter tut, trifft
ivtc seine Entscheidungen unabhängig für jeden Frame.
Dies liefert wesentlich bessere Resultate für Material, das ausgiebiger
Editierung unterzogen wurde, nachdem Telecine angewendet wurde.
Im Endeffekt ist es jedoch nicht so nachsichtig bei leicht gestörtem Input,
wie bei Capturing von TV-Input.
Der optionale Parameter (ivtc=1) entspricht der Option dr=1 des detc-Filters
und sollte nur von MEncoder, nicht von MPlayer verwendet werden.
Wie bei detc muß auch hier bei Benutzung von MEncoder die korrekte
Ausgabe-Framerate (\-ofps 24000/1001) angegeben werden.
Die Entwicklung an itvc findet nicht weiter statt, da die Filter pullup und
filmident genauer zu sein scheinen.
.
.TP
.B pullup[=jl:jr:jo:ju:sb:mp]\
Pulldown-Umkehrungs- (inverse telecine) Filter der dritten Generation, der
mixed hard-telecine und Progressive-Material mit 24000/1001 und 30000/1001 fps
handhaben kann.
Der Pullup-Filter ist wesentlich robuster als detc oder ivtc, da er
für Entscheidungen zukünftigen Kontext zurate zieht.
Wie ivtc auch ist pullup zustandslos in dem Sinne, dass er nicht nach einem zu
folgenden Muster sucht, sondern stattdessen nach vorne schaut, um Gegenstücke
zu finden und progressive Frames zusammenzusetzen.
Der Filter befindet sich noch in der Entwicklung, scheint aber akkurat zu
arbeiten.
Die Optionen jl, jr, jo, und ju bestimmen die zu ignorierende Menge "Müll"
links, rechts, oben und unten am Bildrand, respektive.
Links/\:rechts sind in Einheiten von 8 Pixeln anzugeben, oben/\:unten in
Einheiten von 2 Zeilen.
Der Standardwert ist 8 Pixel an jeder Seite.
Setzen der Option sb (strict breaks) auf 1 reduziert die Chancen von pullup,
gelegentlich einen falsch getroffenen Frame zu generieren.
Es kann jedoch auch dazu führen, dass während schnellen bewegten Szenen eine
exzessive Anzahl an Frames ausgelassen wird.
Im Gegensatz dazu führt ein Setzen auf -1 dazu, dass pullup Felder leichter
zuordnet.
Dies kann helfen beim Verarbeiten von Videomaterial, das zwischen Feldern
leicht verwischt ist, jedoch kann es auch zu interlaced Frames in der Ausgabe
führen.
Die Option mp (metric plane) kann auf 1 oder 2 gesetzt werden, um bei den
Berechnungen von pullup eine Chrominanzebene anstelle einer Helligkeitsebene
zu verwenden.
Dies kann die Genauigkeit bei sehr sauberem Quellmaterial verbessern,
vermutlich wird die Qualitätt jedoch verschlechtert, vor allem wenn es sich um
Videomaterial in Graustufen handelt oder Regenbogeneffekte sichbar sind.
Der vorwiegende Zweck vom Setzen von mp auf Chrominanzebene ist, die
CPU-Auslastung zu verringern und pullup in Echtzeit oder auf langsamen
Maschinen zu benutzen.
.br
.I ANMERKUNG:
Lasse beim Encodieren auf jede Anwendung von pullup den Filter softskip folgen.
Dies stellt sicher, dass pullup jeden Frame betrachtet.
Falls dies nicht geschieht, führt dies zu einer unkorrekten Ausgabe und wird
auf Grund von Designbeschränkungen auf Codec-/\:Filterebene normalerweise
abbrechen.
.
.TP
.B filmdint[=Optionen]
Inverse telecine-Filter, ähnlich dem Pullup-Filter oben.
Er ist konstruiert, jedes Pulldown-Muster zu handhaben, inklusive mixed soft
und hard telecine sowie begrenzter Unterstützung für Filme, deren
Framerate für die Wiedergabe auf einem Fernseher verringert oder
erhöht worden ist.
Nur die Luminanzebene wird benutzt, um Frameunterbrechungen zu finden.
Falls es zu einem Feld keinen Treffer gibt, wird das Deinterlacing mit einer
einfachen linearen Approximation durchgeführt.
Falls die Quelle aus MPEG-2-Material besteht, muss dieser der erste Filter
sein, um Zugang zu den Feld-Flags zu erlauben, die vom MPEG-2-Decoder gesetzt
werden.
Abhängig von der MPEG-Quelle kannst du diesen Hinweis ignorieren, solange du
keine Warnungen "Bottom-first field" bekommst.
Werden keine Optionen angegeben, bewerkstelligt dieser Filter normales inverse
telecine und sollte zusammen mit mencoder \-fps 30000/1001 \-ofps 30000/1001
benutzt werden.
Wird dieser Filter mit mplayer benutzt wird, kommt es zu unregelmäßigen
Frameraten, aber dies ist im Allgemeinen besser als pp=lb oder gar kein
Deinterlacing zu benutzen.
Es können mehrere Optionen getrennt durch / angegeben werden.
.RSs
.IPs crop=<w>:<h>:<x>:<y>
Genau wie der Filter crop, aber schneller, und er funktioniert auch mit mixed
hard und soft telecined-Inhalten, wenn y kein Vielfaches von 4 ist.
Falls x oder y das Abschneiden von nicht-ganzzahligen Pixeln erfordern würde,
wird die Chrominanzebene erweitert.
Das bedeutet üblicherweise, dass x und y geradzahlig sein müssen.
.IPs io=<ifps>:<ofps>
Für alle ifps Eingabeframes wird der Filter ofps Ausgabeframes liefern.
Das Verhältnis von ifps/\:ofps sollte dem Verhältnis \-fps/\-ofps entsprechen.
Dies könnte benutzt werden, um Filme zu filtern, die auf einem Fernseher mit
einer anderen Framerate als der originalen wiedergegeben werden.
.IPs luma_only=<n>
Ist n ungleich 0, wird die Chrominanzebene unverändert kopiert.
Dies ist nützlich für Fernseher im YV12-Modus, die eine der Chrominanzebenen
wegfallen lassen.
.IPs mmx2=<n>
Auf der x86-Architektur, falls n=1, benutze MMX2-optimierte Funktionen, falls
n=2, benutze 3DNow!-optimierte Funktionen, sonst einfach C.
Wird diese Option nicht angegeben, werden MMX2 und 3DNow! automatisch erkannt.
Benutze diese Option, um die automatische Erkennung zu übergehen.
.IPs fast=<n>
Bei größeren Werten für n wird dies den Filter auf Kosten der Genauigkeit
beschleunigen.
Der Standardwert ist n=3.
Ist n ungerade, so wird ein Frame, der direkt auf einen mit dem
REPEAT_FIRST_FIELD-MPEG-Flag markierten Frame folgt, als progressive angesehen.
Daher wird sich der Filter keinen soft-telecined MPEG-2-Inhalten widmen.
Dies ist der einzige Effekt dieses Flags, falls MMX2 oder 3DNow! verfügbar ist.
Ohne MMX2 und 3DNow! und falls n=0 oder 1, werden dieselben Berechnungen
durchgeführt wie mit n=2 oder 3.
Ist n=2 oder 3, so wird die Anzahl der Helligkeitslevels, die benutzt werden,
um Frameunterbrechungen zu finden, von 256 auf 128 reduziert, was einen
schnelleren Filter zur Folge hat, ohne dabei an Genauigkeit zu verlieren.
Ist n=4 oder 5, so wird eine schnellere, aber weniger genauere Metrik benutzt,
um Frameunterbrechungen zu finden, welche dazu neigt, hohe vertikale Details
als interlaced-Inhalte fehlzuinterpretieren.
.IPs verbose=<n>
Falls n von null verschieden ist, gibt dies die detaillierteren Metriken für
jeden Frame aus.
Nützlich für Debugging.
.IPs dint_thres=<n>
Schwellenwert für Deinterlacing.
Wird während des Deinterlacing von nichtgetroffenen Frames benutzt.
Größere Werte bedeuten weniger Deinterlacing; benutze n=256, um Deinterlacing
komplett abzuschalten.
Standardwert ist n=8.
.IPs comb_thres=<n>
Schwellenwert für den Vergleich von top fields und bottom fields.
Standardwert ist 128.
.IPs diff_thres=<n>
Schwellenwert, um die zeitliche Veränderung eines Feldes zu
erkennen.
Standardwert ist 128.
.IPs sad_thres=<n>
Summe des "Absolute Difference"-Schwellenwerts, Standardwert ist 64.
.RE
.
.TP
.B softpulldown
Dieser Filter arbeitet nur mit MEncoder korrekt und richtet sich nur nach den
MPEG-2-Flags, die für soft 3:2-Pulldown (soft telecine) benutzt werden.
Wenn du einen der Filter ivtc oder detc für Filme benutzen möchtest, die zum
Teil 'soft telecined' sind, kann er durch das Einfügen dieses Filters
zuverlässiger gemacht werden.
.
.TP
.B divtc[=Optionen]
Inverse telecine für Videos im deinterlaced-Format.
Falls 3:2-pulldown telecined Videomaterial eins der Felder verloren hat oder
deinterlaced ist durch ein Verfahren, das ein Feld beibehält und das andere
interpoliert, ist das Ergebnis ein ruckelndes Video, das jeden vierten Frame
doppelt enthält.
Dieser Filter beabsichtigt, diese Duplikate zu finden und die ursprüngliche
Framerate des Films wiederherzustellen.
Bei Benutzung dieses Filters mußt du einen Wert für \-ofps angeben, der 4/\:5
der Framerate der Eingabedatei entspricht (23.976 bei einer Eingabe von
29.97fps).
Die Optionen sind:
.RSs
.IPs pass=1|2
Benutze das two-pass (zwei Durchläufe) Verfahren.
Dies liefert die besten Resultate.
Durchlauf 1 analysiert das Video und schreibt das Ergebnis in ein Logfile.
Durchlauf 2 liest dann dieses Logfile und benutzt die Informationen für die
eigentliche Arbeit.
Beachte, dass diese Durchläufe
.B nicht
den Durchläufen 1 und 2 des Encodierungsvorgangs entsprechen.
Um divtc two-pass mit der two-pass-Videoencodierung zu benutzen, sind drei
Schritte nötig: zuerst divtc Durchlauf 1 und Encoder Durchlauf 1, dann divtc
Durchlauf 2 und Encoder Durchlauf 1, schließlich dann divtc
Durchlauf 2 und Encoder Durchlauf 2.
.IPs file=<Dateiname>
Setzt den Dateinamen für das Logfile bei two-pass (Standard: "framediff.log").
.IPs threshold=<Wert>
Setzt die minimale Stärke, die das telecine-Muster haben muss, damit der Filter
es als solches wahrnimmt (Standard: 0.5).
Dies wird benutzt, um bei sehr dunklen oder fast still stehenden Videos die
Erkennung von falschen Mustern zu vermeiden.
.IPs window=<numframes>
Setzt die Anzahl der vorangegangenen Frames, die bei der Suche nach Mustern
berücksichtigt werden (Standard: 30).
Ein längeres Zeitfenster erhöht die Zuverlässigkeit der Mustersuche, ein
kürzeres Zeitfenster jedoch verbessert die Reaktionszeit für Änderungen in der
telecine-Phase.
Dies betrifft nur den one-pass-Modus.
Der two-pass-Modus benutzt zur Zeit ein festes Zeitfenster, das nach vorne und
hinten gerichtet ist.
.IPs phase=0|1|2|3|4
Setzt die anfängliche telecine-Phase für den one-pass-Modus (Standard: 0).
Der two-pass-Modus kann in die Zukunft sehen, so dass er von Anfang an die
richtige Phase wählen kann, der one-pass-Modus kann jedoch nur raten.
Er erkennt die richtige Phase, wenn er sie findet, aber diese Option kann
genutzt werden, um ein mögliches Haken am Anfang zu korrigieren.
Der erste Durchlauf des two-pass-Modus benutzt dies auch; wenn du also die
Ausgabe des ersten Durchlaufs speicherst, bekommst du als Ergebnis eine
konstante Phase.
.IPs deghost=<Wert>
Setzt den Schwellenwert für "Deghosting" (Entfernung von stark unscharfen
Bildern) (0\-255 im one-pass-Modus, -255\-255 im two-pass-Modus, Standard: 0).
Ist der Wert ungleich null, wird Deghosting benutzt.
Dies ist für Videomaterial gedacht, das deinterlaced wurde in der Art, dass
die Felder übereinandergelegt wurden anstatt eins von beiden wegzulassen.
Deghosting erhöht Kompressionsartefakte in übereinandergelegten Frames, daher
wird der Parameterwert als Schwellenwert benutzt, um diejenigen Pixel vom
Deghosting auszuschließen, die sich vom vorigen in weniger als dem angegebenen
Wert unterscheiden.
Wird der two-pass-Modus verwendet, so kann ein negativer Wert benutzt werden,
damit der Filter zu Beginn des zweiten Durchlaufs das ganze Video analysiert
um zu entscheiden, ob Deghosting verwendet werden muss oder nicht.
Der Filter wählt dann entweder null oder den absoluten Wert des Parameters.
Gib diesen Parameter im zweiten Durchlauf an, im ersten bewirkt er keinen
Unterschied.
.RE
.
.TP
.B phase=[t|b|p|a|u|T|B|A|U][:v]
Verzögert interlaced Video um ein Feld, so dass sich die Reihenfolge der
Felder ändert.
Die Absicht ist, Videos im PAL-Format zu korrigieren, die bei der Umsetzung
von Film zu Video mit umgekehrter Feldreihenfolge aufgenommen wurden.
Die Optionen sind:
.RSs
.IPs t
Nimm die Feldreihenfolge top-first, transferiere dabei bottom-first.
Der Filter verzögert das untere (bottom) Feld.
.IPs b
Nimm die Feldreihenfolge bottom-first, transferiere dabei top-first.
Der Filter verzögert das obere (top) Feld.
.IPs p
Nimm auf und transferiere mit derselben Feldreihenfolge.
Dieser Modus existiert nur als Referenz zur Dokumentation anderer Optionen;
falls du es trotzdem auswählst, wird der Filter treuevoll nichts tun ;-)
.IPs a
Nimm die Feldreihenfolge, die durch die Flags der Felder automatisch bestimmt
werden und transferiere die andere.
Der Filter wählt einen der Modi t und b Frame für Frame aus unter Zuhilfenahme
der Feld-Flags.
Ist keine Feldinformation verfügbar, arbeitet er wie bei Angabe von u.
.IPs u
Nimm unbekannte oder variable, transferiere die andere Feldreihenfolge.
Der Filter wählt einen der Modi t und b Frame für Frame aus durch Analyse der
Bilder und sucht diejenige Alternative mit dem besten Treffer zwischen den
Feldern aus.
.IPs T
Nimm die Feldreihenfolge top-first, transferiere unbekannte oder variable.
Der Filter wählt einen der Modi t und p nach Analyse der Bilder.
.IPs B
Nimm die Feldreihenfolge bottom-first, transferiere unbekannte oder variable.
Der Filter wählt einen der Modi b und p nach Analyse der Bilder.
.IPs A
Nimm die durch Feld-Flags bestimmte Feldreihenfolge, transferiere
unbekannte oder variable.
Der Filter wählt einen der Modi t und p nach Analyse der Bilder.
Ist keine Feldinformation verfügbar, arbeitet der Filter wie Angabe von U.
Dies ist der Standardmodus.
.IPs U
Nimm auf und transferiere unbekannte oder variable Feldreihenfolge.
Der Filter wählt einen der Modi t, b und p nur anhand der Bildanalyse.
.IPs v
Ausführliche Vorgehensweise.
Gibt den ausgewählten Modus für jeden Frame sowie die gemittelte quadrierte
Differenz der Felder für die Auswahlen von t, b und p aus.
.RE
.
.TP
.B telecine[=Start]
Wende 3:2 'telecine'-Prozess an, um die Framerate um 20% zu erhöhen.
Dies funktioniert mit MPlayer vermutlich nicht korrekt, kann jedoch in
Verbindung mit 'mencoder \-fps 29.97 \-ofps 29.97 \-vf telecine' benutzt
werden.
Beide fps-Optionen müssen angegeben werden!
(A/\:V-Synchronisation wird verlorengehen, wenn sie falsch sind.)
Der optionale Parameter Start bestimmt, wo im telecine-Muster zu beginnen ist
(0\-3).
.
.TP
.B tinterlace[=Modus]
Temporäres Interlacing der Felder \- verschmelze Paare von Frames in einen
Frame, halbiere dabei die Framerate.
Geradzahlige Frames werden in das obere Feld verschoben, ungerade in das
untere Feld.
Dies kann benutzt werden, um den Effekt des Filters tfields (im Modus 0)
komplett umzukehren.
Verfügbare Modi sind:
.PD 0
.RSs
.IPs 0
Verschiebe ungerade Frames in das obere Feld, geradzahlige in das untere.
Dies generiert einen Frame voller Höhe bei halbierter Framerate.
.IPs 1
Gib nur ungerade Frames aus, geradzahlige werden weggelassen; die Höhe bleibt
unverändert.
.IPs 2
Gib nur geradzahlige Frames aus, ungerade werden weggelassen; die Höhe bleibt
unverändert.
.IPs 3
Expandiere jeden Frame zu voller Höhe, aber fülle alternierende Zeilen
schwarz; die Framerate bleibt unverändert.
.RE
.PD 1
.
.TP
.B tfields[=Modus]
Temporäre Auftrennung der Felder \- trenne die Felder in ganze Frames auf;
dies verdoppelt die Framerate.
Genau wie beim Filter telecine wird tfields nur bei MEncoder korrekt arbeiten,
und nur dann, wenn sowohl \-fps als auch \-ofps mit der gewünschten (doppelten)
Framerate angegeben werden!
Verfügbare Modi sind:
.PD 0
.RSs
.IPs 0
Lasse die Felder unangetastet.
(Dies wird zu Sprüngen/\:Flackern führen.)
.IPs 1
Interpoliere fehlende Zeilen.
(Der benutzte Algorithmus könnte nicht allzu gut sein.)
.IPs 2
Wandle Felder mit linearer Interpolation zu 1/4 Pixel um (kein Sprung).
.IPs 4
Wandle Felder mit dem 4tap-Filter zu 1/4 Pixel um (höhere Qualität) (Standard).
.RE
.PD 1
.
.TP
.B "boxblur=Radius:Stärke[:Radius:Stärke]"
Kastenunschärfe
.PD 0
.RSs
.IPs <Radius>
Stärke des Unschärfefilters
.IPs <Stärke>
Anzahl der Anwendungen des Filters
.RE
.PD 1
.
.TP
.B sab=Radius:pf:colorDiff[:Radius:pf:colorDiff]
shape adaptive blur: umrissabhängige Glättung/Unschärfe
.PD 0
.RSs
.IPs <Radius>
Stärke des Glättungsfilters (~0.1\-4.0) (je größer desto langsamer)
.IPs <pf>\ 
Stärke der Vorfilterung (~0.1\-2.0)
.IPs <colorDiff>
maximale Differenz zwischen zwei Pixeln, damit diese betrachtet werden
(~0.1-100.0)
.RE
.PD 1
.
.TP
.B smartblur=Radius:Stärke:Schwellenwert[:Radius:Stärke:Schwellenwert]
intelligente Glättung
.PD 0
.RSs
.IPs <Radius>
Stärke des Glättungsfilters (~0.1\-5.0) (je größer desto langsamer)
.IPs <Stärke>
glätten (0.0\-1.0) oder schärfen (-1.0\-0.0)
.IPs <Schwellenwert>
Filterung von allem (0), nur gleichförmigen Bereichen (0\-30) oder nur Kanten
(-30\-0)
.RE
.PD 1
.
.TP
.B perspective=x0:y0:x1:y1:x2:y2:x3:y3:t
Korrigiere die Perspektive von Filmen, die nicht lotrecht zum Bildschirm
gefilmt wurden.
.PD 0
.RSs
.IPs <x0>,<y0>,...
Koordinaten der Ecken links oben, rechts oben, links unten, rechts unten
.IPs <t>\ \ 
lineares (0) oder kubisches (1) Resampling
.RE
.PD 1
.
.TP
.B 2xsai\ \ 
Benutzt den 2x-Skalier- und Interpolationsalgorithmus für die Skalierung
und Glättung des Bildes.
.
.TP
.B 1bpp\ \ \ 
Konvertierung von 1bpp-Bitmaps nach YUV/\:BGR 8/\:15/\:16/\:32
.
.TP
.B down3dright[=Zeilen]
Positioniert stereoskopische Bilder neu und ändert deren Größe.
Extrahiert beide Stereofelder und setzt sie nebeneinander.
Dabei wird die Größe so geändert, dass das ursprüngliche Größenverhältnis
beibehalten wird.
.PD 0
.RSs
.IPs <Zeilen>
Anzahl der Zeilen, die von der Mitte des Bildes ausgewählt werden sollen
(Standard: 12)
.RE
.PD 1
.
.TP
.B bmovl=versteckt:opak:fifo
Der Bitmap-Overlay-Filter liest Bitmaps von einem FIFO und zeigt sie oberhalb
des Filmfensters an.
Er erlaubt dabei Transformationen der Bilder.
Ein kleines Beispielprogramm findest du in TOOLS/\:bmovl-test.c.
.PD 0
.RSs
.IPs <versteckt>
Setzt den Standardwert des 'hidden'-Flags (0=sichtbar, 1=unsichtbar).
.IPs <opak>
Setzt den Standardwert des 'opak'-Flags (0=transparent, 1=opak).
.IPs <fifo>
Pfad und Dateiname des FIFOs (eine named pipe, die 'mplayer \-vf bmovl'
mit der kontrollierenden Anwendung verknüpft).
.RE
.PD 1
.sp 1
.RS
Die FIFO-Kommandos sind folgende:
.RE
.PD 0
.RSs
.IPs "RGBA32 Breite Höhe xpos ypos alpha clear"
gefolgt von Breite*Höhe*4 Bytes raw-RGBA32-Daten.
.IPs "ABGR32 Breite Höhe xpos ypos alpha clear"
gefolgt von Breite*Höhe*4 Bytes raw-ABGR32-Daten.
.IPs "RGB24 Breite Höhe xpos ypos alpha clear"
gefolgt von Breite*Höhe*3 Bytes raw-RGB32-Daten.
.IPs "BGR24 Breite Höhe xpos ypos alpha clear"
gefolgt von Breite*Höhe*3 bytes raw-BGR32-Daten.
.IPs "ALPHA Breite Höhe xpos ypos alpha"
Ändert die Alpha-Transparenz für den angegebenen Bereich.
.IPs "CLEAR Breite Höhe xpos ypos"
Löscht den Bereich.
.IPs OPAQUE
Deaktiviert die Alpha-Transparenz.
Schicke "ALPHA 0 0 0 0 0" an den FIFO, um sie wieder zu aktivieren.
.IPs HIDE
Versteckt die Bitmap.
.IPs SHOW
Zeigt die Bitmap an.
.RE
.PD 1
.sp 1
.RS
Die Argumente sind folgende:
.RE
.PD 0
.RSs
.IPs "<Breite>, <Höhe>"
Größe des Bildes/Bereiches.
.IPs "<xpos>, <ypos>"
Starte bei Position x/y.
.IPs <alpha>
Setzt die Alpha-Differenz.
Wenn du den Wert auf -255 setzt, dann kannst du mit einer Sequenz von
ALPHA-Kommandos den Bereich auf -225, -200, -175 etc.\& setzen, um einen netten
Fade-In-Effekt zu erzielen! ;)
.RSss
0:    genau wie bei der Vorlage.
.br
255:  Bedecke alles.
.br
-255: Mache alles transparent.
.REss
.IPs <clear>
Lösche den Framebuffer vor dem "Blitting".
.RSss
0: Das Blitting eines Bildes wird nur über dem vorigen (darunterliegenden)
angewendet, daher brauchst du nicht jedesmal, wenn ein kleiner Teil des
Bildschirms aktualisiert wird, 1,8MB an RGBA32-Daten an den FIFO schicken.
.br
1: löschen
.REss
.RE
.PD 1
.
.TP
.B framestep=I|[i]step
Rendert nur jeden n-ten Frame oder jeden Intraframe (Keyframe).
.sp 1
Rufst du den Filter mit groß geschriebenem I als Parameter auf, so werden
.B nur
Keyframes gerendert.
Für DVDs bedeutet dies im Allgemeinen, dass nur einer von 15/\:12
(IBBPBBPBBPBBPBB) Frames dargestellt wird, bei AVIs wirkt diese Option bei
jedem Szenenwechsel oder jedem keyint-Wert (siehe '\-lavcopts keyint=Wert',
falls du MEncoder zum Encodieren des Videos benutzt).
.sp 1
Wird ein Keyframe gefunden, so wird ein 'I!' gefolgt von einem Zeilenumbruch
ausgegeben, wobei die aktuelle Zeile der Ausgabe von MPlayer/\:MEncoder
auf dem Bildschirm bleibt, da sie die Zeit (in Sekunden) und die
Framenummer des Keyframes enthält.
(Du kannst diese Angabe benutzen, um ein AVI korrekt zu splitten.)
.sp 1
Rufst du den Filter mit einem numerischen Parameter 'step' auf, so wird nur
ein Frame von 'step' vielen angezeigt.
.sp 1
Setzt du ein klein geschriebenes 'i' vor diese Nummer, so wird 'I!' angezeigt
(wie beim Parameter I).
.sp 1
Gibst du nur das i an, so passiert nichts mit den Frames, aber es wird
ein 'I!' für jeden Keyframe ausgegeben.
.
.TP
.B tile=xtiles:ytiles:Ausgabe:Start:delta
Kachelt eine Reihe von Bildern zu einem größeren Bild.
Lässt du einen Parameter weg oder benutzt einen Wert kleiner als 0, so wird
der Standardwert benutzt.
Du kannst aufhören, wenn du zufrieden bist (... \-vf tile=10:5 ...).
Es ist vermutlich eine gute Idee, den Filter scale vor das Kacheln zu
setzen :-)
.sp 1
Die Parameter sind folgende:
.sp 1
.PD 0
.RSs
.IPs <xtiles>
Anzahl der Kacheln auf der X-Achse (Standard: 5)
.IPs <ytiles>
Anzahl der Kacheln auf der Y-Achse (Standard: 5)
.IPs <Ausgabe>
Stelle die Kacheln erst dann dar, wenn <Ausgabe> viele Frames erreicht sind,
wobei <Ausgabe> eine Zahl sein sollte, die kleiner ist als xtile * ytile.
Fehlende Kacheln werden leer gelassen.
Du könntest zum Beispiel nach jeden 50 Frames alle 2 Sekunden bei 25 fps
ein 8 * 7 Kacheln großes Bild erstellen.
.IPs <Start>
Dicke des äußeren Rahmens in Pixeln (Standard: 2)
.IPs <delta>
Dicke des inneren Rahmens in Pixeln (Standard: 2)
.RE
.PD 1
.
.TP
.B delogo[=x:y:b:h:t]
Unterdrückt das Logo eines Fernsehsenders durch einfache Interpolation der
umgebenden Pixel.
Setze einfach ein Rechteck, das das Logo bedeckt, und sieh wie es
verschwindet (und manchmal etwas unschöneres entsteht \- deine Erfahrungen
können variieren).
.PD 0
.RSs
.IPs <x>,<y>
die linke obere Ecke des Logos
.IPs <b>,<h>
Breite und Höhe des bereinigten Rechtecks
.IPs <t>
Dicke des fließenden Übergangs des Rechtecks zum Rest (wird zur Breite und
Höhe addiert).
Auf -1 gesetzt wird ein grünes Rechteck auf den Bildschirm gezeichnet, um das
Finden der richtigen Parameter für x,y,w und h zu erleichtern.
.RE
.PD 1
.
.TP
.B zrmjpeg[=Optionen]
Software-Encoder von YV12 nach MJPEG für die Benutzung des
zr2-Videoausgabetreibers.
.RSs
.IPs maxheight=<h>|maxwidth=<b>
Diese Optionen setzen die maximale Breite und Höhe, die die zr-Karte handhaben
kann (die Filterschicht von MPlayer kann diese momentan nicht abfragen).
.IPs {dc10+,dc10,buz,lml33}-{PAL|NTSC}
Benutze diese Option, um die Werte für maxwidth und maxheight bei einer
bekannten Kombination für Karte/Modus automatisch zu setzen.
Gültige Optionen sind zum Beispiel dc10-PAL und buz-NTSC (Standard: dc10+PAL).
.IPs color|bw
Setze Encodierung auf Farbe oder Schwarz/Weiß.
Schwarz/Weiß-Encodierung ist schneller.
Encodierung in Farbe ist Standard.
.IPs hdec={1,2,4}
Horizontale Dezimierung 1, 2 oder 4.
.IPs vdec={1,2,4}
Vertikale Dezimierung 1, 2 oder 4.
.IPs quality=1\-20
Setze Kompressionsqualität für JPEG [BESTE] 1 \- 20 [SEHR SCHLECHT].
.IPs fd|nofd
Der Standard ist, dass die Dezimierung nur dann ausgeführt wird, wenn die
Zoran Hardware die erzeugten MJPEG-Bilder auf die originale Größe
hochskalieren kann.
Die Option fd weist den Filter an, die geforderte Skalierung immer auszuführen
(hässlich).
.RE
.
.
.
.SH "ALLGEMEINE ENCODING-OPTIONEN (NUR BEI MENCODER)"
.
.TP
.B \-audio-delay <0.0\-...>
Setzt den Header für die Audioverzögerung im Dateikopf.
Standardwert ist 0.0, negative Werte funktionieren nicht.
Diese Option verzögert den Ton nicht während des Encodierens, sondern der
Player wird beim Abspielen den Ton verzögern, sodass du dann nicht mehr
\-delay angeben musst.
.
.TP
.B \-audio-density <1\-50>
Anzahl der Audioblöcke pro Sekunde (Standard ist 2, was in 0.5s langen
Audioblöcken resultiert).
.br
.I ANMERKUNG:
Nur bei CBR (konstanter Bitrate), VBR (variable Bitrate) ignoriert diese
Einstellung, da jedes Paket in einen eigenen Block kommt.
.
.TP
.B \-audio-preload <0.0\-2.0>
Setzt Audiopuffer-Zeitintervall (Standard: 0.5s).
.
.TP
.B \-endpos <[[hh:]mm:]ss[.ms]|Größe[b|kb|mb]> (siehe auch \-ss und \-sb)
Beende das Encodieren nach der angegeben Zeit oder Byteposition.
.br
.I ANMERKUNG:
Die Byteposition ist nicht exakt, da MEncoder nur an Bildgrenzen mit dem
Encodieren aufhören kann.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-endpos 56"
Encodiere nur 56 Sekunden.
.IPs "\-endpos 01:10:00"
Encodiere nur 1 Stunde 10 Minuten.
.IPs "\-endpos 100mb"
Encodiere nur 100 MBytes.
.RE
.PD 1
.
.TP
.B \-ffourcc <fourcc>
Hiermit kann das FourCC-Feld der Ausgabedatei überschrieben werden.
.sp
.I BEISPIEL:
.PD 0
.RSs
.IPs "-ffourcc div3"
Setzt das FourCC-Feld der Ausgabedatei auf 'div3'.
.RE
.PD 1
.
.TP
.B \-force-avi-aspect <0.2\-3.0>
Überschreibe den Aspekt, der im AVI-OpenDML-vprp-Header gespeichert ist.
Dies kann benutzt werden, um den Aspekt mit '\-ovc copy' zu ändern.
.
.TP
.B \-hr-edl-seek (nur bei EDL)
Benutze eine präzisere, jedoch wesentlich langsamere Methode, Bereiche zu
überspringen.
Bereiche, die markiert sind, übersprungen zu werden, werden nicht direkt
übergangen, sondern es werden alle Frames decodiert, aber nur die benötigten
Frames werden encodiert.
Dies erlaubt das Starten in Bereichen zwischen Keyframes.
.br
.I ANMERKUNG:
Es ist nicht garantiert, dass dies mit der Option '\-ovc copy' funktioniert.
.
.TP
.B \-info <Option1:Option2:...> (nur für AVIs)
Gibt die Werte für den Info-Header der resultierenden AVI-Datei an.
.sp 1
Die verfügbaren Optionen sind:
.RSs
.IPs help\ 
Zeigt diese Beschreibung.
.IPs name=<Wert>
Titel oder Thema des Films
.IPs artist=<Wert>
Künstler oder Autor des Originalfilms
.IPs genre=<Wert>
Kategorie oder Genre des Films
.IPs subject=<Wert>
Inhalt der Datei
.IPs copyright=<Wert>
Copyright-Informationen für diese Datei
.IPs srcform=<Wert>
Urpsrungsform des digitalisierten Materials
.IPs comment=<Wert>
allgemeine Kommentare über die Datei oder den thematischen Inhalt
.RE
.
.TP
.B \-noautoexpand
Füge den Filter expand nicht automatisch in die Filterkette von MEncoder ein.
Nützlich, um zu kontrollieren, an welcher Stelle der Filterkette die Untertitel
dargestellt werden, falls Untertitel fest in den Film eincodiert werden.
.
.TP
.B \-noencodedups
Versuche nicht, doppelte Frames doppelt zu encodieren; gib immer
zero-byte-Frames aus, um Duplikate anzudeuten.
Zero-byte-Frames werden sowieso geschrieben, solange kein Filter oder
Encoder geladen wird, der in der Lage ist, doppelte Frames zu encodieren.
Zur Zeit ist der einzige solche Filter harddup.
.
.TP
.B \-noodml (nur bei \-of AVI)
Schreibe keinen OpenDML-Index für AVI-Dateien größer als 1GB.
.
.TP
.B \-noskip
Verwerfe keine Bilder.
.
.TP
.B \-o <Dateiname>
Schreibt in die angegebene Datei anstatt in 'test.avi'.
.
.TP
.B \-oac <Codecname>
Encodiere Audio mit dem angegebenen Audiocodec (kein Standardwert vorhanden).
.br
.I ANMERKUNG:
\-oac help liefert eine Liste der verfügbaren Audiocodecs.
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "-oac copy"
kein Encodieren, sondern nur eine Kopie des Streams
.IPs "-oac pcm"
Encodiere in unkomprimiertes PCM.
.IPs "-oac mp3lame"
Encodiere nach MP3 (mit LAME).
.IPs "\-oac lavc"
Encodiere mit dem libavcodec Codec.
.RE
.PD 1
.
.TP
.B \-of <Format> (BETA\-CODE!)
Gib in dem angegebenen Format aus.
.br
.I ANMERKUNG:
Mit \-of help bekommst du eine Liste vorhandener Containerformate.
.sp 1
.I BEISPIELE:
.PD 0
.RSs
.IPs "\-of avi"
Gib ein AVI aus (Standard).
.IPs "\-of mpeg"
Gib ein MPEG aus.
.IPs "\-of rawvideo"
reiner (raw) Videostream (kein Muxing, nur ein Videostream)
.RE
.PD 1
.
.TP
.B \-ofps <fps>
Setzt die Anzahl der Bilder pro Sekunde (fps) für die Ausgabedatei, die
unterschiedlich zu der der Quelldatei sein kann.
Diese Option muss gesetzt werden, wenn eine Quelldatei mit
variabler Framerate (ASF, einige MOV) oder ein progressiver Film (30000/1001
fps telecined MPEG) encodiert wird.
.
.TP
.B \-ovc <Codecname>
Encodiere Video mit dem angegebenen Codec.
.br
.I ANMERKUNG:
Mit \-ovc help erhälst du eine Liste verfügbarer Codecs (kein Standardwert
vorhanden).
.sp 1
.I BEISPIEL:
.PD 0
.RSs
.IPs "\-ovc copy"
kein Encodieren, sondern nur eine Kopie des Videostreams
.IPs "\-ovc divx4"
Encodiere zu DivX4/\:DivX5.
.IPs "\-ovc raw"
Encodiere zu einem frei wählbaren Format (benutze '\-vf format', um dieses
auszuwählen).
.IPs "\-ovc lavc"
Encodiere mit einem libavcodec Codec.
.RE
.PD 1
.
.TP
.B \-passlogfile <Dateiname>
Wenn mit zwei Durchgängen encodiert wird, dann schreibt MEncoder die
Informationen des ersten Durchgangs in die angegebene Datei und nicht 
nach divx2pass.log.
.
.TP
.B \-skiplimit <Wert>
Maximale Anzahl ausgelassener Bilder nach einem nicht ausgelassenen
(mit \-noskiplimit gibt es ein solches Limit nicht).
.
.TP
.B \-vobsubout <Basisname>
Gibt den Basisnamen für die Ausgabe der .idx- und .sub-Dateien an.
Damit wird das Rendern der Untertitel im encodierten Film deaktiviert, und
die Untertitel werden statt dessen in eine VOBsub-Datei umgeleitet.
.
.TP
.B \-vobsuboutid <Sprach-ID>
Gibt den zweibuchstabigen Sprachcode der Untertitel an.
Dieser Wert überschreibt, was von der DVD oder der .ifo-Datei gelesen wurde.
.
.TP
.B \-vobsuboutindex <Index>
Gibt den Index der ausgegebenen VOBsub-Untertitel an (Standardwert: 0).
.
.
.
.SH "CODEC-SPEZIFISCHE ENCODING-OPTIONEN (NUR BEI MENCODER)"
Für die Encodierung kannst du Codec-spezifische Parameter angeben, indem du
folgende Syntax benutzt:
.
.TP
.B \-<Codec>opts <Option1[=Wert1],Option2,...>
.
.PP
Wobei <Codec> einer der folgenden sein kann: lavc, xvidenc, divx4, lame,
toolame, twolame, faac, x264enc und mpeg.
.
.
.SS divx4 (\-divx4opts)
DivX4 ist überholt und wird nur der Vollständigkeit halber unterstützt.
Für Details zu den DivX4-Optionen musst du den Quellcode lesen, die meisten
Optionen werden hier nicht vorgestellt.
.
.TP
.B help\ \ \ 
Gibt einen Hilfstext aus.
.
.TP
.B br=<Wert>
Gibt die Bitrate an.
.RSs
.IPs 4\-16000
(in kbit)
.IPs 16001\-24000000
(in bit)
.RE
.
.TP
.B key=<Wert>
maximale Anzahl der Bilder zwischen zwei Keyframes (Schlüsselbildern)
.
.TP
.B deinterlace
Aktiviert Deinterlacing (vermeide dies, da es bei DivX4 fehleranfällig ist).
.
.TP
.B q=<1\-5>
Qualitätslevel (1 \- am schnellsten, 5 \- am besten)
.
.TP
.B min_quant=<1\-31>
minimaler Quantisierungsparameter
.
.TP
.B max_quant=<1\-31>
maximaler Quantisierungsparameter
.
.TP
.B rc_period=<Wert>
Bitratenkontrollzeitrahmen
.
.TP
.B rc_reaction_period=<Wert>
Reaktionszeitrahmen für die Bitratenkontrolle
.
.TP
.B rc_reaction_ratio=<Wert>
Reaktionsverhältnis für die Bitratenkontrolle
.
.TP
.B crispness=<0\-100>
Gibt Schärfe/\:Glätte an.
.
.TP
.B pass=<1\-2>
Mit dieser Option können DivX4-Dateien im two-pass-Modus erstellt werden.
Zuerst encodierst du mit pass=1, dann mit denselben Parametern und pass=2
anstelle von pass=1.
.
.TP
.B vbrpass=<0\-2>
Überschreibt den pass-Parameter und benutzt die VBR-Bibliothek von XviD
anstelle der von DivX4.
Verfügbare Optionen sind:
.RSs
.IPs 0
Encodieren in einem Durchlauf (als ob pass überhaupt nicht verwendet würde)
.IPs 1
Analyse bzw. erster Durchlauf im two-pass-Modus.
Das erstellte AVI kann nach /dev/\:null umgeleitet werden.
.IPs 2
Finaler (zweiter) Durchlauf im two-pass-Modus.
.RE
.
.
.SS lame (\-lameopts)
.
.TP
.B help\ \ \ 
Liefert einen Hilfstext.
.
.TP
.B vbr=<0\-4>
zu verwendender Bitratenmodus
.PD 0
.RSs
.IPs 0
CBR
.IPs 1
MT
.IPs 2
RH (Standard)
.IPs 3
ABR
.IPs 4
MTRH
.RE
.PD 1
.
.TP
.B abr\ \ \ \ 
durchschnittliche (average) Bitrate
.
.TP
.B cbr\ \ \ \ 
konstante Bitrate
Dies erzwingt den CBR-Modus auch bei ABR-Presets.
.
.
.TP
.B br=<0\-1024>
Bitrate in kBit/s (nur bei CBR und ABR)
.
.TP
.B q=<0\-9>
Qualität (0 \- höchste, 9 \- niedrigste) (nur bei VBR)
.
.TP
.B aq=<0\-9>
Qualität des Algorithmus (0 \- am besten/langsamsten, 9 \- am
schlechtesten/schnellsten)
.
.TP
.B ratio=<1\-100>
Kompressionsverhältnis
.
.TP
.B vol=<0\-10>
Audioeingangsverstärkung
.
.TP
.B mode=<0\-3>
(Standard: automatisch)
.PD 0
.RSs
.IPs 0
stereo
.IPs 1
joint-stereo
.IPs 2
dualchannel
.IPs 3
mono
.RE
.PD 1
.
.TP
.B padding=<0\-2>
.PD 0
.RSs
.IPs 0
kein Padding
.IPs 1
alles
.IPs 2
automatische Anpassung
.RE
.PD 1
.
.TP
.B fast\ \ \ 
Aktiviert schnelles Encodieren bei nachfolgenden VBR-Presets.
Etwas schlechtere Qualität und höhere Bitraten sind die Nachteile.
.
.TP
.B highpassfreq=<Frequenz>
Setzt die Frequenz für Highpass-Filterung in Hz.
Frequenzen unterhalb der angegebenen werden abgeschnitten.
Ein Wert von -1 deaktiviert die Filterung, ein Wert von 0 lässt LAME die Werte
für die Frequenz automatisch wählen.
.
.TP
.B lowpassfreq=<Frequenz>
Setzt die Frequenz für Lowpass-Filterung in Hz.
Frequenzen oberhalb der angegebenen werden abgeschnitten.
Ein Wert von -1 deaktiviert die Filterung, ein Wert von 0 lässt LAME die Werte
für die Frequenz automatisch wählen.
.
.TP
.B preset=<Wert>
Werte für verschiedene Presets
.RSs
.IPs help\ 
Gibt Informationen über die Presets und über weitere Optionen aus.
.IPs medium
VBR-Encodierung, gute Qualität, Bitrate im Rahmen von ca. 150\-180 kBit/s
.IPs standard
VBR-Encodierung, hohe Qualität, Bitrate im Rahmen von ca. 170\-210 kBit/s
.IPs extreme
VBR-Encodierung, sehr hohe Qualität, Bitrate im Rahmen von ca. 200\-240 kBit/s
.IPs instane
CBR-Encodierung, Preset mit der besten Qualität, Bitrate 320 kBit/s
.IPs <8-320>
ABR-Encodierung mit der gegebenen Bitrate im Mittel
.RE
.sp 1
.RS
.I BEISPIELE:
.RE
.PD 0
.RSs
.IPs fast:preset=standard
Für die meisten Leute reicht das aus und bietet schon ziemlich gute Qualität.
.IPs cbr:preset=192
Encodiere mit ABR-Preset bei erzwungener konstanter Bitrate von 172 kBit/s.
.IPs preset=172
Encodiere mit ABR-Preset bei einer durchschnittlichen Bitrate von 172 kBit/s.
.IPs preset=extreme
Für Menschen mit einem sehr guten Gehör und entsprechender HiFi-Ausstattung.
.RE
.PD 1
.
.
.SS toolame und twolame (\-toolameopts und \-twolameopts respektive)
.
.TP
.B br=<32\-384>
Im CBR-Modus gibt dieser Parameter die Bitrate in kbps an, im VBR-Modus ist er
die minimal erlaubte Bitrate pro Frame.
VBR funktioniert nicht mit einem Wert unter 112.
.TP
.B vbr=<-50\-50> (nur bei VBR)
Bereich für Abweichungen; falls negativ verlagert der Encoder die
durchschnittliche Bitrate zum unteren Limit, wenn positiv zum höheren.
Auf 0 gesetzt wird CBR benutzt (Standard).
.TP
.B maxvbr=<32\-384> (VBR only)
maximal erlaubte Bitrate pro Frame, in kpbs
.TP
.B mode=<stereo  |  jstereo  |  mono  |  dual>
(Standard: mono bei 1-Kanal-Audio, sonst stereo)
.TP
.B psy=<-1\-4>
psychoakustisches Modell (Standard: 2)
.TP
.B errprot=<0 | 1>
Füge Fehlerkorrektur hinzu.
.TP
.B debug=<0\-10>
Debugging-Level
.RE
.PD 1
.
.
.SS faac (\-faacopts)
.
.TP
.B br=<Bitrate>
mittlere Bitrate in kbps (schließt Option quality aus)
.TP
.B quality=<1\-1000>
Qualitätsmodus, je höher desto besser (schließt Option br aus)
.TP
.B object=<0\-3>
Komplexität des Objekttyps
.PD 0
.RSs
.IPs 0
MAIN (Standard)
.IPs 1
LOW
.IPs 2
SSR
.IPs 3
LTP (extrem langsam)
.RE
.PD 1
.TP
.B mpeg=<2|4>
MPEG-Version (Standard: 4)
.TP
.B tns\ \ \ \ 
Aktiviert temporäre Rauschanpassung.
.TP
.B cutoff=<0\-Samplerate/2>
Frequenz, ab der abgeschnitten wird (Standard: <Samplerate>/2)
.TP
.B raw\ \ \ \ 
Speichert den Bitstream als reine Arbeitsdaten mit Extrainformationen im
Header des Containers (Standard: 0, entspricht ADTS).
Setze diese Option nicht, wenn du sie nicht unbedingt brauchst, sonst wirst
du den Audiostream später nicht verwenden können.
.RE
.PD 1
.
.
.SS lavc (\-lavcopts)
Viele Optionen von libavcodec (kurz lavc) sind nur knapp dokumentiert.
Lies die Sourcen für alle Details.
.PP
.I BEISPIEL:
.PD 0
.RSs
.IPs vcodec=msmpeg4:vbitrate=1800:vhq:keyint=250
.RE
.PD 1
.
.TP
.B acodec=<Wert>
Audiocodec (Standard: mp2)
.PD 0
.RSs
.IPs mp2\ \ 
MPEG Layer 2
.IPs mp3\ \ 
MPEG Layer 3
.IPs ac3\ \ 
AC3
.IPs adpcm_ima_wav
IMA Adaptive PCM (4 Bits pro Sample, 4:1-Kompression)
.RE
.PD 1
.
.TP
.B abitrate=<Wert>
Audiobitrate in kbps (Standard: 224)
.
.TP
.B atag=<Wert>
Benutze die angegebene Windows-Audioformatkennung (z.B.\& atag=0x55).
.
.TP
.B bit_exact
Benutze nur bitgenaue Algorithmen (außer (I)DCT).
Zusätzlich deaktiviert bit_exact mehrere Optimierungen und sollte daher
nur für Regressionstests verwendet werden, die binär identische Dateien
benötigen, selbst wenn sich die Version des Encoders ändert.
Dies unterdrückt in MPEG-4-Streams außerdem den user_data-Header.
Benutze diese Option nicht, wenn du nicht genau weißt, was du tust.
.
.TP
.B threads=<1\-8>
Maximale Anzahl der zu benutzenden Threads (Standard: 1).
Kann einen leicht negativen Effekt auf die Bewegungsabschätzung haben.
.RE
.
.TP
.B vcodec=<Wert>
Verwende den angegebenen Codec (Standard: mpeg4).
.PD 0
.RSs
.IPs mjpeg
Motion-JPEG
.IPs ljpeg
Verlustfreies (lossless) JPEG
.IPs h263\ 
H.263
.IPs h263p
H.263+
.IPs mpeg4
MPEG-4 (DivX 4/5)
.IPs msmpeg4
DivX 3
.IPs msmpeg4v2
MS MPEG4v2
.IPs wmv1\ 
Windows Media Video, Version 1 (WMV7)
.IPs wmv2\ 
Windows Media Video, Version 2 (WMV8)
.IPs rv10\ 
ein alter RealVideo-Codec
.IPs mpeg1video
MPEG-1-Video
.IPs mpeg2video
MPEG-2-Video
.IPs huffyuv
HuffYUV
.IPs ffvhuff (siehe auch: vstrict)
nicht-standardkonformes, 20% kleineres HuffYUV, benutzt YV12
.IPs asv1\ 
ASUS Video v1
.IPs asv2\ 
ASUS Video v2
.IPs ffv1 (siehe auch: vstrict)
FFmpegs verlustfreier Videocodec
.RE
.PD 1
.
.TP
.B vqmin=<1\-31>
minimaler Quantisierungsparameter (Durchlauf 1/\:2)
.RSs
.IPs 1
Nicht empfohlen (viel größere Datei, geringer Qualitätsunterschied und
seltsame Seiteneffekte: msmpeg4 und h263 werden eine sehr geringe Qualität
liefern und die Bitratenkontrolle wird verwirrt sein, was auch eine geringere
Qualität zur Folge hat; manche Decoder werden es nicht abspielen können).
.IPs 2
Empfohlen für normales Encodieren mit mpeg4/\:mpeg1video (Standard).
.IPs 3
Empfohlen für h263(p)/\:msmpeg4.
Der Grund dafür, 3 dem Wert 2 vorzuziehen ist, dass 2 zu Overflows führen kann.
(Dies wird zukünftig für h263(p) korrigiert werden, indem der
Quantisierungsparameter pro Macro-Block geändert wird; msmpeg4 kann nicht
korrigiert werden, da es dies nicht unterstützt.)
.RE
.
.TP
.B lmin=<0.01\-255.0>
Minimaler Lagrange-Multiplikator für die Bitratenkontrolle, du möchtest
wahrscheinlich einen Wert, der kleiner oder gleich vqmin ist (Standard: 2.0).
.RE
.
.TP
.B lmax=<0.01\-255.0>
Maximaler Lagrange-Multiplikator für die Bitratenkontrolle (Standard: 31.0)
.RE
.
.TP
.B vqscale=<1\-31>
Encodierung mit konstantem Quantisierungsparameter bzw.\& konstanter Qualität
(wählt den 'fixed quantizer'-Modus).
Ein kleinerer Wert bedeutet bessere Qualität bei größeren Dateien (Standard: 0
(deaktiviert)).
Der Wert 1 wird nicht empfohlen (siehe vqmin für Details).
.
.TP
.B vqmax=<1\-31>
Maximaler Quantisierungsparameter (Durchlauf 1/\:2), Werte im Bereich 10\-31
sollten vernünftig sein (Standard: 31).
.
.TP
.B mbqmin=<1\-31>
veraltet, benutze vqmin
.
.TP
.B mbqmax=<1\-31>
veraltet, benutze vqmax
.
.TP
.B vqdiff=<1\-31>
maximaler Unterschied der Quantisierungsparameter zwischen
aufeinanderfolgenden Intra- und P-Frames (Durchlauf 1/\:2) (Standard: 3)
.
.TP
.B vmax_b_frames=<0\-4>
maximale Anzahl der B-Frames zwischen nicht-B-Frames
.PD 0
.RSs
.IPs 0
keine B-Frames (Standard)
.IPs 0\-2
vernünftiger Bereich für MPEG-4
.RE
.PD 1
.
.TP
.B vme=<0\-5>
Verfahren für die Bewegungsabschätzung.
Verfügbare Modi sind die folgenden:
.PD 0
.RSs
.IPs 0
keine (sehr geringe Qualität)
.IPs 1
volle (langsam, momentan nicht gewartet und deaktiviert)
.IPs 2
log (langsam, momentan nicht gewartet und deaktiviert)
.IPs 3
phods (langsam, momentan nicht gewartet und deaktiviert)
.IPs 4
EPZS: Größe=1 diamond, Größe kann mit den *dia-Optionen angepasst werden
(Standard).
.IPs 5
X1 (experimentell, verweist momentan nur auf EPZS)
.RE
.PD 1
.sp 1
.RS
.br
.I ANMERKUNG:
0\-3 ignorieren momentan den Umfang der gebrauchten Bits, die Qualität
kann daher gering sein.
.RE
.
.TP
.B me_range=<0\-9999>
Umfang der Bewegungsabschätzung (Standard: 0 (unbegrenzt))
.
.TP
.B mbd=<0\-2>
Macroblock decision algorithm: Entscheidungsalgorithmus für Macro-Blocks (hohe
Qualitätsstufe), encodiert jeden Macro-Block in allen Modi und wählt den
besten aus.
Dies ist zwar langsam, ist aber hinsichtlich Qualität und Dateigröße besser.
.PD 0
.RSs
.IPs 0
Benutze mbcmp (Standard).
.IPs 1
Wählt denjenigen Modus für einen Macro-Block, der die wenigsten Bits benötigt
(entspricht vhq).
.IPs 2
Wählt den Modus für einen Macro-Block mit der geringsten Verzerrung.
.RE
.PD 1
.
.TP
.B vhq\ \ \ \ 
Bewirkt das gleiche wie mbd=1, wird aus Kompatibilitätsgründen beibehalten.
.
.TP
.B v4mv\ \ \ 
Erlaubt 4 Motion-Vectors pro Macro-Block (leicht verbesserte Qualität).
Arbeitet besser in Verbindung mit mbd > 0.
.
.TP
.B obmc\ \ \ 
Bewegungskompensation überlappender Blöcke (H.263+)
.
.TP
.B loop\ \ \ 
Loop-Filter (H.263+)
Beachte, dass diese Option nicht funktioniert.
.
.TP
.B inter_threshold <-1000\-1000>
Bewirkt zur Zeit gar nichts.
.
.TP
.B keyint=<0\-300>
Maximale Anzahl von Bildern zwischen zwei Keyframes (Standard: 250, was einem
Keyframe alle zehn Sekunden bei einem 25fps-Film entspricht).
Keyframes werden für das Spulen in Filmen gebraucht, da nur ein Sprung zu
Keyframes möglich ist; Keyframes jedoch benötigen mehr Platz als andere Frames,
daher bedeutet ein höherer Wert hier geringfügig kleinere Dateien und damit
weniger genaues Spulen.
0 ist gleichbedeutend mit 1, was jeden Frame zu einem Keyframe macht.
Werte > 300 werden nicht empfohlen, da die Qualität abhängig von Decoder,
Encoder und Glück schlecht sein kann.
Für eine strikte Einhaltung von MPEG-1/2/4 müsste dieser Wert <=132 sein.
.
.TP
.B sc_threshold=<-1000000\-1000000>
Schwellenwert für die Erkennung eines Szenenwechsels.
libavcodec fügt einen Keyframe ein, wenn er einen Szenenwechsel entdeckt.
Mit dieser Option kannst du die Sensitivität dieser Erkennung bestimmen.
-1000000 bedeutet, dass mit jedem Frame ein Szenenwechsel erkannt wird;
1000000 bedeutet, dass gar keine Szenenwechsel erkannt werden (Standard: 0).
.
.TP
.B vb_strategy=<0\-1>
Strategie, mit der zwischen I-/\:P-/\:B\-Frames gewählt wird (beim ersten
Durchlauf):
.
.PD 0
.RSs
.IPs 0
Benutzt immer die maximale Anzahl B-Frames (Standard).
.IPs 1
Vermeide B-Frames in schnell bewegten Szenen.
.RE
.PD 1
.
.TP
.B vpass=<1\-3>
Aktiviert den internen Modus für zwei (oder mehr) Durchläufe.
Gib diese Option nur an, wenn du mit zwei (oder mehr) Durchläufen encodieren
möchtest.
.PD 0
.RSs
.IPs 1
erster Durchlauf (siehe auch turbo)
.IPs 2
zweiter Durchlauf
.IPs 3
N-ter Durchlauf (zweiter und weiterer Durchläufe beim N-pass-Modus)
.RE
.RS
Hier also wie es funktioniert und benutzt wird:
.br
Der erste Durchlauf (vpass=1) schreibt eine Datei mit Statistiken.
Du möchtest vielleicht ein paar CPU-intensive Optionen wie "turbo"
deaktivieren.
.br
Im two-pass-Modus (vpass=2) wird im zweiten Durchlauf die Statistikdatei
gelesen, und die Bitratenkontrolle fällt dementsprechende Entscheidungen.
.br
Im N-pass-Modus (vpass=3, kein Druckfehler) wird beides getan: Erst
werden die Statistiken eingelesen, dann überschrieben.
Wenn die Möglichkeit besteht, dass du diesen Vorgang abbrechen musst, solltest
du die Datei divx2pass.log vorher sichern.
Du kannst alle Encodierungsoptionen verwenden, außer sehr CPU-lastigen
wie "qns".
.br
Du kannst denselben Durchlauf wiederholt durchführen, um die Encodierung zu
verfeinern.
Jeder folgende Durchlauf wird die Statistiken des vorigen benutzen, um die
Ergebnisse zu verbessern.
Der letzte Durchlauf kann beliebige CPU-intensive Optionen beinhalten.
.br
Wenn du 2-pass-Encodierung möchtest, benutze zuerst vpass=1 und dann vpass=2.
.br
Wenn du 3- oder mehrfach-Encodierung möchtest, benutze vpass=1 für den ersten
Durchlauf, dann vpass=3 und dann vpass=3 immer wieder, bis du mit dem Ergebnis
zufrieden bist.
.RE
.PD 1
.sp 1
.RS
huffyuv:
.RE
.PD 0
.RSs
.IPs "pass 1"
Speichert Statistiken.
.IPs "pass 2"
Encodiert mit einer optimalen Huffman-Tabelle, basierend auf den Statistiken
des ersten Durchlaufs.
.RE
.PD 1
.
.TP
.B turbo (nur im two-pass-Modus)
Erhöht die Geschwindigkeit des ersten Durchgangs drastisch, indem schnellere
Algorithmen benutzt und CPU-intensive Optionen deaktiviert werden
Dies wird den PSNR-Wert im Ganzen wahrscheinlich ein wenig (etwa
0.01dB) und Typ und PSNR-Wert einzelner Frames ein wenig mehr (bis zu
0.03db) verringern.
.
.TP
.B aspect=<x/\:y>
Speichere den Filmaspekt intern, wie bei MPEG-Dateien.
Dies ist eine viel elegantere Lösung als den Film neu zu skalieren, da die
Qualität nicht verringert wird.
MPlayer und ein paar weitere Player werden diese Dateien korrekt wiedergeben,
andere werden das Größenverhältnis falsch darstellen.
Der Parameter für das Verhältnis kann als Bruch oder Fließkommawert angegeben
werden.
.sp 1
.RS
.I BEISPIEL:
.RE
.RSs
.PD 0
.IPs "aspect=16/\:9 oder aspect=1.78"
.PD 1
.RE
.
.TP
.B autoaspect
Das gleiche wie die Option aspect, wobei jedoch das Verhältnis automatisch
berechnet wird.
Veränderungen in der Filterkette wie crop/\:expand/\:scale/\:etc.\& werden
dabei berücksichtigt.
Diese Option verursacht keine Performanceeinbußen, du kannst sie also getrost
immer aktivert lassen.
.
.TP
.B vbitrate=<Wert>
Gibt die Bitrate an (Durchlauf 1/\:2) (Standard: 800).
.br
.I WARNUNG:
1kBit = 1000 Bits
.PD 0
.RSs
.IPs 4\-16000
(in kBit)
.IPs 16001\-24000000
(in Bit)
.RE
.PD 1
.
.TP
.B vratetol=<Wert>
ungefähre Dateigrößentoleranz in kBit.
Werte im Bereich 1000\-100000 sind vernünftig.
(Warnung: 1kBit = 1000 Bits)
(Standard: 8000)
.br
.I ANMERKUNG:
vratetol sollte im zweiten Durchlauf nicht zu groß sein, es kann sonst in
Verbindung mit vrc_(min|max)rate zu Problemen kommen.
.
.TP
.B vrc_maxrate=<Wert>
maximale Bitrate in kbit/\:Sek (Durchlauf 1/\:2)
(Standard: 0, unbegrenzt)
.
.TP
.B vrc_minrate=<Wert>
minimale Bitrate in kbit/\:Sek (Durchlauf 1/\:2)
(Standard: 0, unbegrenzt)
.
.TP
.B vrc_buf_size=<Wert>
Puffergröße in kbit (Durchlauf 1/\:2).
Für MPEG-1/\:2-Dateien setzt dies außerdem die vbv-Puffergröße; benutze 327
für VCDs, 917 für SVCDs und 1835 für DVDs.
.
.TP
.B vrc_buf_aggressivity
momentan nutzlos
.
.TP
.B vrc_strategy
Platzhalter, reserviert für zukünftige Benutzung.
.
.TP
.B vb_qfactor=<-31.0\-31.0>
Quantisierungsparameter zwischen B- und Nicht-B-Frames (Durchlauf 1/\:2)
(Standard: 1.25)
.
.TP
.B vi_qfactor=<-31.0\-31.0>
Quantisierungsparameter zwischen Intra- und Nicht-Intraframes (Durchlauf 1/\:2)
(Standard: 0.8)
.
.TP
.B vb_qoffset=<-31.0\-31.0>
Offset des Quantisierungsparameters zwischen B- und Nicht-B-Frames (Durchlauf
1/\:2)
(Standard: 1.25)
.
.TP
.B vi_qoffset=<-31.0\-31.0>
Offset des Quantisierungsparameters zwischen Intra- und Nicht-Intraframes
(Durchlauf 1/\:2)
(Standard: 0.0)
.br
if v{b|i}_qfactor > 0
.br
Intra-/\:B-Frame-Quantisierungsparameter = P-Frame-Quantisierungsparameter *
v{b|i}_qfactor + v{b|i}_qoffset
.br
else
.br
benutze die normale Bitratenkontrolle (lege den nächsten
P-Frame-Quantisierungsparameter nicht fest) und setze
q= -q * v{b|i}_qfactor + v{b|i}_qoffset
.br
.I TIP:
Für Encodierung mit unterschiedlichen aber konstanten Quantisierungsparametern
für Intra-/P- und B-Frames kannst du folgendes benutzen:
lmin= <ip_quant>:lmax= <ip_quant>:vb_qfactor= <b_quant/\:ip_quant>.
.
.TP
.B vqblur=<0.0\-1.0> (Durchlauf 1)
Glättung des Quantisierungsparameters (Standard: 0.5); größere Werte bilden den
Durchschnitt über mehr Frames (langsamerer Wechsel).
.PD 0
.RSs
.IPs 0.0
Glättung des Quantisierungsparameters deaktiviert.
.IPs 1.0
Bildet für den Quantisierungsparameter den Durchschnitt aller vorangegangenen
Frames.
.RE
.PD 1
.
.TP
.B vqblur=<0.0\-99.0> (Durchlauf 2)
Gaußsche Unschärfe des Quantisierungsparameters (Standard: 0.5); größere Werte
bilden den Durchschnitt über mehr Frames (langsamerer Wechsel).
.
.TP
.B vqcomp=<Wert>
Kompression des Quantisierungsparameters, vrc_eq hängt davon ab (Durchlauf
1/\:2) (Standard: 0.5).
Sei beispielsweise angenommen, dass die Standard-Bitratenkontrollgleichung
benutzt wird, so wird die Bitratenkontrolle bei vqcomp=1.0 für jeden Frame so
viele Bits reservieren, dass sie alle mit dem selben Quantisierungsparameter
encodiert werden können.
Bei vqcomp=0.0 reserviert die Bitratenkontrolle für jeden Frame dieselbe
Anzahl Bits, also striktes CBR.
.I ANMERKUNG:
Dies sind extreme Einstellungen und sollten nie benutzt werden.
Die wahrgenommene Qualität ist optimal zwischen diesen beiden Extremen.
.
.TP
.B vrc_eq=<Gleichung>
Hauptsächlich verwendete Gleichung für die Bitratenkontrolle (Durchlauf 1/\:2):
.RE
.RSs
.IPs 1\ \ \ \ 
konstante Bitrate
.IPs tex\ \ 
konstante Qualität
.IPs 1+(tex/\:avgTex-1)*qComp
ungefähr die Gleichung der alten Bitratenkontrolle
.IPs tex^qComp
wobei qcomp = 0.5 oder ein ähnlicher Wert (Standard)
.RE
.PP
.RS
Infixoperatoren:
.RE
.RSs
.IPs +,-,*,/,^
.RE
.PP
.RS
Variablen:
.RE
.RSs
.IPs tex\ \ 
Texturkomplexität
.IPs iTex,pTex
Intra- und Nicht-Intra-Texturkomplexität
.IPs avgTex
durchschnittliche Texturkomplexität
.IPs avgIITex
durchschnittliche Intra-Texturkomplexität bei Intraframes
.IPs avgPITex
durchschnittliche Intra-Texturkomplexität bei P-Frames
.IPs avgPPTex
durchschnittliche Nicht-Intra-Texturkomplexität bei P-Frames
.IPs avgBPTexaverage
durchschnittliche Nicht-Intra-Texturkomplexität bei B-Frames
.IPs mv\ \ \ 
für Motion-Vectors verwendete Bits
.IPs fCode
maximale Länge der Motion-Vectors in log2-Skalierung
.IPs iCount
Anzahl der Intra-Macroblöcke / Anzahl der Macroblöcke
.IPs var\ \ 
räumliche Komplexität
.IPs mcVar
zeitliche Komplexität
.IPs qComp
auf der Kommandozeile angegebener Wert für qcomp
.IPs "isI, isP, isB"
Ist 1 bei einem Bildtyp von I/\:P/\:B, sonst 0.
.IPs Pi,E\ 
Schau in dein Lieblingsmathebuch.
.RE
.PP
.RS
Funktionen:
.RE
.RSs
.IPs max(a,b),min(a,b)
Maximum / Minimum
.IPs gt(a,b)
(greater than) ist 1 falls a>b, sonst 0
.IPs lt(a,b)
(less than) ist 1 falls a<b, sonst 0
.IPs eq(a,b)
(equals) ist 1 falls a==b, sonst 0
.IPs "sin, cos, tan, sinh, cosh, tanh, exp, log, abs"
.RE
.
.TP
.B vrc_override=<Optionen>
Benutzerdefinierte Qualität für bestimmte Abschnitte
(Ende, Abspann, ...) (Durchlauf 1/\:2).
Die Optionen haben folgenden Aufbau: <Startframe>, <Endframe>,
<Qualität>[/\:<Startframe>, <Endframe>, <Qualität>[/\:...]]:
.PD 0
.RSs
.IPs "Qualität (2\-31)"
Quantisierungsparameter
.IPs "Qualität (-500\-0)"
Qualitätskorrektur in %
.RE
.PD 1
.
.TP
.B vrc_init_cplx=<0\-1000>
anfängliche Komplexität (Durchlauf 1)
.
.TP
.B vqsquish=<0|1>
Gibt an, wie die Quantisierungsparameter zwischen qmin und qmax gehalten werden
(Durchlauf 1/\:2):
.PD 0
.RSs
.IPs 0
Benutze Clipping.
.IPs 1
Benutzt eine schöne ableitbare Funktion (Standard).
.RE
.PD 1
.
.TP
.B vlelim=<-1000\-1000>
Schwelle für die Eliminierung von einzelnen Koeffizienten beim
Helligkeitsanteil.
Bei negativen Werten werden auch die DC-Koeffizienten betrachtet (sollte
mindestens -4 or niedriger sein, wenn mit quant=1 encodiert wird):
.PD 0
.RSs
.IPs 0
deaktiviert (Standard)
.IPs -4
JVT-Empfehlung
.RE
.PD 1
.
.TP
.B vcelim=<-1000\-1000>
Schwelle für die Eliminierung von einzelnen Koeffizienten beim
Farbanteil.
Bei negativen Werten werden auch die DC-Koeffizienten betrachtet (sollte
mindestens -4 or niedriger sein, wenn mit quant=1 encodiert wird):
.PD 0
.RSs
.IPs 0
deaktiviert (Standard)
.IPs 7
JVT-Empfehlung
.RE
.PD 1
.
.TP
.B vstrict=<-2|-1|0|1>
.PD 0
.RSs
.IPs 0
deaktiviert
.IPs 1
Nur empfehlenswert, wenn die Ausgabe mit einem MPEG-4-Referenzdecoder
decodiert werden soll.
.IPs -1
Erlaubt die Benutzung libavcodec-spezifischer Erweiterungen (Standard).
.IPs -2
Erlaubt die Benutzung experimenteller Codecs und Features, die von zukünftigen
Versionen von MPlayer möglicherweise nicht abspielbar sein werden (snow,
ffvhuff, ffv1).
.RE
.PD 1
.
.TP
.B vdpart\ 
Datenpartitionierung.
Fügt zwei Bytes pro Videopaket hinzu und erhöht die Fehlerresistenz beim
Transfer über unzuverlässige Kanäle (z.B.\& Streaming über das Internet).
Jedes Videopaket wird in drei separate Partitionen aufgeteilt:
.PD 0
.RSs
.IPs "1. MVs"
Bewegungen
.IPs "2. DC-Koeffizienten"
niedrig aufgelöstes Bild
.IPs "3. AC-Koeffizienten"
Details
.RE
.PD 1
.RS
MV und DC sind am wichtigsten, sie zu verlieren bedeutet ein viel schlechteres
Bild als der Verlust von AC und der ersten oder zweiten Partition.
MV und DC sind viel kleiner als die dritte (AC) Partition, was bedeutet, dass
auftretende Fehler die AC-Partition viel häufiger treffen wird als die MV- und
DC-Partitionen.
Daher sieht das Bild mit Partitionierung viel besser aus, denn ohne eine
solche würde ein Fehler AC/\:DC/\:MV in gleichem Umfang zerstören.
.RE
.
.TP
.B vpsize=<0\-10000> (siehe auch vdpart)
Videopaketgröße, erhöht die Fehlerresistenz.
.PD 0
.RSs
.IPs 0\ \ \ \ 
deaktiviert (Standard)
.IPs 100\-1000
gute Wahl
.RE
.PD 1
.
.TP
.B ss\ \ \ \ \ 
slice-structured- (anteilig strukturierter) Modus für H.263+
.
.TP
.B gray\ \ \ 
Encodierung zu Graustufenbildern (schneller)
.
.TP
.B vfdct=<0\-10>
DCT-Algorithmus (diskrete Cosinustransformation)
.PD 0
.RSs
.IPs 0
automatische Wahl (Standard)
.IPs 1
schneller Integer-Algorithmus
.IPs 2
genauer Integer-Algorithmus
.IPs 3
MMX
.IPs 4
mlib
.IPs 5
AltiVec
.IPs 6
Fließkomma-AAN
.RE
.PD 1
.
.TP
.B idct=<0\-99>
IDCT-Algorithmus (inverse diskrete Cosinustransformation)
.br
.I ANMERKUNG:
All diese IDCT-Algorithmen bestehen die IEEE1180-Tests.
.PD 0
.RSs
.IPs 0
automatische Wahl (Standard)
.IPs 1
JPEG-Referenzalgorithmus (Integer)
.IPs 2
simple
.IPs 3
simplemmx
.IPs 4
libmpeg2mmx (ungenau, benutze ihn nicht mit einem keyint > 100)
.IPs 5
ps2
.IPs 6
mlib
.IPs 7
arm
.IPs 8
AltiVec
.IPs 9
sh4
.RE
.PD 1
.
.TP
.B lumi_mask=<0.0\-1.0>
Helligkeitsmaskierung ist eine 'psychosensorische' Einstellung, die die
Tatsache nutzen soll, dass das menschliche Auge dazu neigt, in sehr hellen
Teilen eines Bildes weniger Details zu erkennen.
Helligkeitsmaskierung komprimiert sehr helle Stellen stärker als
durchschnittlich helle, so dass ein paar Bits eingespart werden, die dann auf
andere Frames verwendet werden können, was die subjektive Qualität im Ganzen
erhöht und den PSNR-Wert möglicherweise reduziert.
.br
.I WARNUNG:
Sei vorsichtig! Zu große Werte können katastrophale Ergebnisse liefern.
.br
.I WARNUNG:
Große Werte mögen auf einigen Monitoren gut aussehen, können auf anderen aber
auch schrecklich aussehen.
.PD 0
.RSs
.IPs 0.0\ \ 
deaktiviert (Standard)
.IPs 0.0\-0.3
sinnvoller Bereich
.RE
.PD 1
.
.TP
.B dark_mask=<0.0\-1.0>
Dunkelheitsmaskierung ist eine 'psychosensorische' Einstellung, die die
Tatsache nutzen soll, dass das menschliche Auge dazu neigt, in sehr dunklen
Teilen eines Bildes weniger Details zu erkennen.
Dunkelheitsmaskierung komprimiert sehr dunkle Stellen stärker als
durchschnittlich dunkle, so dass ein paar Bits eingespart werden, die dann auf
andere Frames verwendet werden können, was die subjektive Qualität im Ganzen
erhöht und den PSNR-Wert möglicherweise reduziert.
.br
.I WARNUNG:
Sei vorsichtig!
Zu große Werte können katastrophale Ergebnisse liefern.
.br
.I WARNUNG:
Große Werte mögen auf einigen Monitoren gut aussehen, können auf anderen
Monitoren/dem Fernseher/\:TFTs aber auch schrecklich aussehen.
.PD 0
.RSs
.IPs 0.0\ \ 
deaktiviert (Standard)
.IPs 0.0\-0.3
sinnvoller Bereich
.RE
.PD 1
.
.TP
.B tcplx_mask=<0.0\-1.0>
Maskierung der zeitlichen Komplexität (Standard: 0.0 (deaktiviert)).
Stell dir eine Szene mit einem Vogel vor, der durch die ganze Szene fliegt;
tcplx_mask wird die Quantisierungsparameter der zum Vogel gehörenden
Macroblöcke erhöhen (und so deren Qualität verringern), da das menschliche
Auge normalerweise nicht die Zeit hat, alle Details des Vogels wahrzunehmen.
Sei gewarnt, dass es für kurze Zeit schrecklich aussieht, wenn das Objekt
anhält (z.B.\& bei der Landung des Vogels), bis der Encoder bemerkt, dass das
Objekt angehalten hat und die Blöcke neu definiert werden müssen.
Die eingesparten Bits werden auf andere Teile des Videos verwendet, was die
subjektiv wahrgenommene Qualität erhöhen kann \- vorausgesetzt, tcplx_mask ist
sorgfältig gewählt.
.
.TP
.B scplx_mask=<0.0\-1.0>
Gebietsbezogene Maskierung der Komplexität.
Größere Werte helfen bei Blockartefakten, falls kein Deblocking-Filter
beim Decodieren benutzt wird, was vielleicht keine gute Idee ist.
.br
Stell die eine Szene vor mit Gras (was üblicherweise eine hohe gebietsbezogene
Komplexität hat), einem blauen Himmel und einem Haus; scplx_mask wird die
Quantisierungsparameter der zum Gras gehörenden Macroblöcke erhöhen, was deren
Qualität verringert, um mehr Bits auf den Himmel und das Haus zu verwenden.
.br
.I TIP:
Schneide alle schwarzen Balken komplett ab, da sie die Qualität der
Macroblöcke verringern (gilt auch ohne scplx_mask).
.PD 0
.RSs
.IPs 0.0\ \ 
deaktiviert (Standard)
.IPs 0.0\-0.5
sinnvoller Bereich
.RE
.PD 1
.sp 1
.RS
.I ANMERKUNG:
Diese Einstellung hat nicht denselben Effekt wie die Benutzung einer
benutzerdefinierten Matrix, die hohe Frequenzen stärker komprimieren würde, da
scplx_mask die Qualität nur bei Änderung des DC-Koeffizienten verringert.
Das Ergebnis mit scplx_mask wird vermutlich nicht so gut aussehen.
.RE
.
.TP
.B p_mask=<0.0\-1.0> (siehe auch vi_qfactor)
Verringert die Qualität von Interblöcken.
Dies ist das Äquivalent zum Erhöhen der Qualität der Intrablöcke, da dieselbe
mittlere Bitrate von der Bitratenkontrolle zur ganzen Videosequenz zugeteilt
wird (Standard: 0.0 (deaktiviert)).
p_mask=1.0 verdoppelt die Anzahl der jedem Intrablock zugeteilten Bits.
.
.TP
.B border_mask=<0.0\-1.0>
Randbearbeitung (border processing) bei MPEG-ähnlichen Encodern.
Randbearbeitung erhöht den Quantisierungsparameter für Makroblöcke, die
weniger als ein Fünftel der Framebreite/\:-höhe vom Rand des Frames entfernt
sind, da sie visuell oft weniger bedeutsam sind.
.
.TP
.B naq\ \ \ \ 
Normalisierte adaptive Quantisierung (experimentell).
Wenn adaptive Quantisierung benutzt wird (*_mast), dann wird der
durchschnittliche Quantisierungsparameter pro Macroblock eventuell
nicht mehr dem geforderten Quantisierungsparameter auf Framelevel entsprechen.
NAQ versucht dann, den pro Macroblock verwendeten Quantisierungsparameter
anzupassen, um den geforderten Durchschnitt beizubehalten.
.
.TP
.B ildct\ \ 
Benutze die interlaced DCT.
.
.TP
.B ilme\ \ \ 
Benutze interlaced Bewegungsabschätzung (schließt qpel gegenseitig aus).
.
.TP
.B alt\ \ \ \ 
Benutzt eine alternative Suchtabelle.
.
.TP
.B top=<-1\-1>\ \ \ 
.PD 0
.RSs
.IPs -1
automatisch
.IPs 0
bottom field first (unteres Feld zuerst)
.IPs 1
top field first (oberes Feld zuerst)
.RE
.PD 1
.
.TP
.B format=<Wert>
.PD 0
.RSs
.IPs YV12\ 
Standard
.IPs 444P\ 
für ffv1
.IPs 422P\ 
für HuffYUV, verlustfreies JPEG und ffv1
.IPs 411P,YVU9
für verlustfreies JPEG und ffv1
.IPs BGR32
für verlustfreies JPEG und ffv1
.RE
.PD 1
.
.TP
.B pred\ \ \ 
(für HuffYUV)
.PD 0
.RSs
.IPs 0
linke Vorhersage
.IPs 1
Vorhersage der Ebene/\:des Gradienten
.IPs 2
Medianvorhersage
.RE
.PD 1
.
.TP
.B pred\ \ \ 
(für verlustfreies JPEG)
.PD 0
.RSs
.IPs 0
linke Vorhersage
.IPs 1
obere Vorhersage
.IPs 2
linke obere Vorhersage
.IPs 3
Vorhersage der Ebene/\:des Gradienten
.IPs 6
Durchschnittsvorhersage
.RE
.PD 1
.
.TP
.B coder\ \ 
(für ffv1)
.PD 0
.RSs
.IPs 0
vlc-Codierung (Golomb-Rice)
.IPs 1
arithmetische Codierung (CABAC)
.RE
.PD 1
.
.TP
.B context
(für ffv1)
.PD 0
.RSs
.IPs 0
Modell zu kleinem Kontext
.IPs 1
Modell zu großem Kontext
.RE
.PD 1
.sp 1
.RS
(für ffvhuff)
.RE
.PD 0
.RSs
.IPs 0
vorbestimmte Huffman-Tabellen (eingebaut oder two-pass)
.IPs 1
adaptive Huffman-Tabellen
.RE
.PD 1
.
.TP
.B qpel\ \ \ 
Benutze "quarter pel"-Bewegungsabschätzung (schließt ilme gegenseitig aus).
.br
.I ANMERKUNG:
Dies scheint nur für Encodierung mit hohen Bitraten sinnvoll zu sein.
.
.TP
.B mbcmp=<0\-2000>
Setzt die Vergleichsfunktion für Macroblockentscheidungen, wird nur bei mbd=0
benutzt.
.PD 0
.RSs
.IPs "0 (SAD)"
Summe der absoluten Differenzen, schnell (Standard)
.IPs "1 (SSE)"
Summe der quadrierten Fehler
.IPs "2 (SATD)"
Summe der absoluten Hadamard-transformierten Differenzen
.IPs "3 (DCT)"
Summe der absoluten DCT-transformierten Differenzen
.IPs "4 (PSNR)"
Summe der quadratischen Quantisierungsfehler (zu vermeiden, niedrige Qualität)
.IPs "5 (BIT)"
Anzahl der für den Block benötigten Bits
.IPs "6 (RD)"
rate distortion (Ratenverzerrung) optimal, langsam
.IPs "7 (ZERO)"
0
.IPs "8 (VSAD)"
Summe der absoluten vertikalen Differenzen
.IPs "9 (VSSE)"
Summe der quadrierten vertikalen Differenzen
.IPs "10 (NSSE)"
Rauschen beibehaltende Summe der quadrierten Differenzen
.IPs +256\ 
Benutze auch die Farbinformation, funktioniert momentan nicht (korrekt) mit
B-Frames.
.RE
.PD 1
.
.TP
.B ildctcmp=<0\-2000>
Setzt die Vergleichsfunktion für interlaced DCT-Entscheidungen (siehe mbcmp
für eine Liste der verfügbaren Vergleichsfunktionen).
.
.TP
.B precmp=<0\-2000>
Setzt die Vergleichsfunktion für "pre pass"-Bewegungsabschätzung (siehe mbcmp
für eine Liste der verfügbaren Vergleichsfunktionen) (Standard: 0).
.
.TP
.B cmp=<0\-2000>
Setzt die Vergleichsfunktion für "full pel"-Bewegungsabschätzung (siehe mbcmp
für eine Liste der verfügbaren Vergleichsfunktionen) (Standard: 0).
.
.TP
.B subcmp=<0\-2000>
Setzt die Vergleichsfunktion für "sub pel"-Bewegungsabschätzung (siehe mbcmp
für eine Liste der verfügbaren Vergleichsfunktionen) (Standard: 0).
.
.TP
.B nssew=<0\-100>
Diese Einstellung kontrolliert die NSSE-Gewichtung, wobei eine höhere
Gewichtung stärkeres Rauschen erzeugt.
NSSE 0 ist identisch mit SSE.
Vielleicht findest du dies nützlich, wenn du die Beibehaltung von etwas
Rauschen in deinem encodierten Video besser findest als es vor dem Encodieren
herauszufiltern.
.
.TP
.B predia=<-99\-6>
Rautentyp und -größe für "pre pass"-Bewegungsabschätzung
.
.TP
.B dia=<\-99\-6>
Rautentyp und -größe für die Bewegungsabschätzung.
Bewegungsabschätzung ist ein iterativer Prozess.
Eine kleine Raute zu benutzen begrenzt die Suche nicht auf das Auffinden von
kleinen Motion-Vectors.
Es ist nur irgendwie wahrscheinlicher, dass die Suche anhält, bevor der beste
Motion-Vector gefunden wurde \- vor allem, wenn Rauschen involviert ist.
Größere Rauten erlauben eine ausgedehntere Suche nach dem besten
Motion-Vector, welche daher langsamer ist, dafür aber zu einem besseren
Ergebnis führt.
.br
Große normale Rauten sind qualitativ besser als "shape adaptive" (Gestalt
anpassende) Rauten.
.br
Shape adaptive Rauten sind ein guter Kompromiss zwischen Geschwindigkeit
und Qualität.
.br
.I ANMERKUNG:
Die Größen von normalen und "shape adaptive"-Rauten haben unterschiedliche
Bedeutung.
.RSs
.IPs -3
shape adaptive (schnell) Raute der Größe 3
.IPs -2
shape adaptive (schnell) Raute der Größe 2
.IPs -1
etwas speziell: Kann langsamer und/oder besser sein als dia=-2.
.IPs  1
Normale Raute der Größe 1 (Standard), entspricht einer Raute des Typs EPZS.
.nf
.ne
      0
     000
      0
.fi
.IPs 2
normale Raute der Größe 2
.nf
.ne
      0
     000
    00000
     000
      0
.fi
.RE
.
.TP
.B trell\ \ 
Trellis-Quantisierung.
Hiermit wird die optimale Encodierung für jeden 8x8-Block gefunden.
Die Trellis-Quantisierung ist bei gegenseitiger Abschätzung von PSNR-Wert gegen
die Bitrate optimal (unter der Annahme, dass durch die IDCT keine
Rundungsfehler ins Spiel kommen \- was natürlich nicht der Fall ist).
Sie findet einfach einen Block für das Minimum von Fehler und lambda * bits.
.PD 0
.RSs
.IPs lambda
vom Quantisierungsparameter (QP) abhängige Konstante
.IPs bits\ 
Menge der für die Encodierung eines Blocks benötigten Bits
.IPs error
Summe der quadrierten Quantisierungsfehler
.RE
.PD 1
.
.TP
.B cbp\ \ \ \ 
Ratenverzerrtes optimal codiertes Blockmuster (coded block pattern).
Wird dasjenige codierte Blockmuster auswählen, das Verzerrung + lambda*rate
minimiert.
Dies kann nur zusammen mit der Trellis-Quantisierung benutzt werden.
.
.TP
.B mv0\ \ \ \ 
Versuche jeden Macroblock mit Motion-Vector=<0,0> zu encodieren und wähle
den besseren.
Dies hat keinen Effekt, falls mbd=0.
.
.TP
.B qprd (nur mit mbd=2)
Ratenverzerrter optimaler Quantisierungsparameter bei gegebenem lambda für
jeden Macroblock
.
.TP
.B last_pred=<0\-99>
Menge der Bewegungsvorhersagen vom vorigen Frame
.PD 0
.RSs
.IPs 0
(Standard)
.IPs a
Benutzt ein 2a+1 x 2a+1 Macroblockquadrat von Motion-Vector-Vorhersagen vom
vorigen Frame.
.RE
.PD 1
.
.TP
.B preme=<0\-2>
"pre-pass"-Bewegungsabschätzung
.PD 0
.RSs
.IPs 0
deaktiviert
.IPs 1
nur nach Intraframes (Standard)
.IPs 2
immer
.RE
.PD 1
.
.TP
.B subq=<1\-8>
"subpel refinement"-Qualität (für qpel) (Standard: 8 (hohe Qualität))
.br
.I ANMERKUNG:
Diese Einstellung hat signifikante Auswirkung auf die Geschwindigkeit.
.
.TP
.B psnr\ \ \ 
Gibt den maximalen Signal-zu-Rauschabstand (peak signal to noise ratio) für
das komplette Video nach dem Encodieren aus und speichert die PSNR-Werte für
jedes Bild in einer Datei der Form 'psnr_hhmmss.log'.
Ausgegebene Werte haben die Einheit dB (Dezibel), je höher desto besser.
.
.TP
.B mpeg_quant
Benutze MPEG-Quantisierungsparameter anstelle von H.263.
.
.TP
.B aic\ \ \ \ 
AC-Vorhersage (advanced intra prediction, verbesserte Intra-Vorhersage für
H.263+)
.br
.I ANMERKUNG:
vqmin sollte 8 oder höher sein für H.263+ AIC.
.
.TP
.B aiv\ \ \ \ 
alternativer "inter vlc" für H.263+
.
.TP
.B umv\ \ \ \ 
unbegrenzte Motion-Vectors (unlimited MVs) (nur bei H.263+)
.br
Erlaubt die Encodierung von beliebig langen Motion-Vectors.
.
.TP
.B ibias=<-256\-256>
Intra-Quantisierungsverzerrung (256 entspricht 1.0,
MPEG-Quantisierungsstandard: 96, H.263-Quantisierungsstandard: 0)
.br
.I ANMERKUNG:
Die H.263-MMX-Quantisierung kann positive Verzerrungen nicht verarbeiten
(setze vfdct=1 oder 2), die MPEG-MMX-Quantisierung kann negative Verzerrungen
nicht verarbeiten (setze vfdct=1 oder 2).
.
.TP
.B pbias=<-256\-256>
Inter-Quantisierungsverzerrung (256 entspricht 1.0,
MPEG-Quantisierungsstandard: 0, H.263-Quantisierungsstandard: -64)
.br
.I ANMERKUNG:
Die H.263-MMX-Quantisierung kann positive Verzerrungen nicht verarbeiten
(setze vfdct=1 oder 2), die MPEG-MMX-Quantisierung kann negative Verzerrungen
nicht verarbeiten (setze vfdct=1 oder 2).
.br
.I TIP:
Eine eher positive Verzerrung (-32 bis -16 anstelle -64) scheint den
PSNR-Wert zu verbessern.
.
.TP
.B nr=<0\-100000>
Rauschunterdrückung (noise reduction), 0 bedeutet deaktiviert.
.
.TP
.B qns=<0\-3>
"Quantizer noise shaping", Rauschanpassung des Quantisierungsparameters.
Anstatt die Quantisierung so zu wählen, dass dem Quellvideo im Sinne von PSNR
am besten entsprochen wird, wählt die Rauschanpassung die Quantisierung so,
dass Rauschen (normalerweise Ringbildungen) durch ähnlichfrequenten Inhalt im
Bild maskiert wird.
Größere Werte sind langsamer, können aber zu besserer Qualität führen.
Dies kann und sollte zusammen mit der Trellis-Quantisierung benutzt werden, in
welchem Falle diese (optimal für konstante Gewichtung) als Einstiegspunkt für
die iterative Suche benutzt wird.
.PD 0
.RSs
.IPs 0
deaktiviert (Standard)
.IPs 1
Verringere nur die absoluten Werte der Koeffizienten.
.IPs 2
Ändere Koeffizienten nur vor dem letzten von 0 verschiedenen Koeffizient + 1.
.IPs 3
Versuche alle.
.RE
.PD 1
.
.TP
.B inter_matrix=<kommaseparierte Matrix>
Benutze eine eigene Intermatrix.
Braucht eine kommaseparierte Zeichenkette von 64 Integerwerten.
.
.TP
.B intra_matrix=<kommaseparierte Matrix>
Benutze eine eigene Intramatrix.
Braucht eine kommaseparierte Zeichenkette von 64 Integerwerten.
.
.TP
.B vqmod_amp
experimentelle Modulation des Quantisierungsparameters
.
.TP
.B vqmod_freq
experimentelle Modulation des Quantisierungsparameters
.
.TP
.B dc\ \ \ \ \ 
Intra-DC-Genauigkeit in Bits (Standard: 8).
Wenn du vcodec=mpeg2video angibst, kann dieser Wert 8, 9, 10 oder 11 sein.
.
.TP
.B cgop\ \ \ 
Schließt alle GOPs.
Funktioniert momentan nicht.
.
.
.SS nuv (\-nuvopts)
.
NuppelVideo basiert auf RTJPEG und LZO.
Normalerweise werden Frames zuerst mit RTJPEG encodiert und dann mit LZO
komprimiert; es ist jedoch möglich, entweder einen oder beide Durchgänge zu
deaktivieren.
Als Ergebnis kannst du also tatsächlich raw i420, LZO-komprimiertes i420,
RTJPEG, oder normales LZO-komprimiertes RTJPEG ausgeben.
.br
.I ANMERKUNG:
Die nuvrec-Dokumentation enthält einige Anweisungen und Beispiele zu
Einstellungen, die für die meisten TV-Encodierungen genutzt werden können.
.
.TP
.B c=<0\-20>
Chrominanzschwellenwert (Standard: 1)
.
.TP
.B l=<0\-20>
Helligkeitsschwellenwert (Standard: 1)
.
.TP
.B lzo\ \ \ \ 
Aktiviert LZO-Kompression (Standard).
.
.TP
.B nolzo\ \ 
Deaktiviert LZO-Kompression.
.
.TP
.B q=<3\-255>
Qualitätslevel (Standard: 255)
.
.TP
.B raw \ \ \ 
Deaktiviert RTJPEG-Encodierung.
.
.TP
.B rtjpeg\ 
Aktiviert RTJPEG-Encodierung (Standard).
.
.
.SS xvidenc (\-xvidencopts)
.
Es sind drei Modi verfügbar: konstante Bitrate (CBR), feste
Quantisierungsparameter und Encodieren in zwei Durchläufen (two-pass).
.
.TP
.B pass=<1|2>
Gibt die Nummer des Durchgangs im two-pass-Modus an.
.
.TP
.B bitrate=<Wert>
Setzt die zu benutzende Bitrate in kbit/s an, wenn der Wert < 16000 ist, oder
in bit/s, wenn der Wert > 16000 ist.
Ist <Wert> negativ, so benutzt XviD dessen absoluten Wert als Zielgröße des
Videos (in kBytes) und berechnet die zugehörige Bitrate automagisch.
(nur bei CBR oder bei zwei Durchläufen, Standardwert: 687 kbit/\:s)
.
.TP
.B fixed_quant=<1\-31>
Aktiviert den Modus mit festen Quantisierungsparametern und legt den zu
benutzenden Quantisierungsparameter fest.
.
.TP
.B me_quality=<0\-6>
Diese Option kontrolliert das Bewegungsabschätzungssubsystem.
Je höher der Wert, desto genauer sollte die Abschätzung sein (Standard: 6).
Je genauer die Abschätzung ist, desto mehr Bits können eingespart werden.
Die Präzision wird auf Kosten der CPU-Zeit erreicht; benutze also niedrigere
Werte, falls du Encodierung in Echtzeit brauchst.
.
.TP
.B (no)interlacing
Encodiert die Felder von interlaced Videomaterial.
Schalte diese Option bei interlaced Inhalten ein.
.br
.I ANMERKUNG:
Solltest du das Video anders skalieren, brauchst du einen Skalierer, der
interlaced Material bemerkt; du kannst einen solchen mit '-vf
scale=<Breite>:<Höhe>:1' aktivieren.
.
.TP
.B 4mv\ \ \ \ 
Benutzt vier Motion-Vectors pro Makroblock, was eine bessere Kompression
auf Kosten der Encodiergeschwindigkeit bringen kann.
.br
.I WARNUNG:
Seit Version 1.0.x von XviD ist diese Option nicht mehr separat verfügbar,
die Funktionalität wurde in die Option me_quality integriert.
Bei me_quality > 4 wird 4mv aktiviert.
.
.TP
.B rc_reaction_delay_factor=<Wert>
Dieser Parameter kontrolliert die Anzahl der Frames, die die
CBR-Bitratenkontrolle wartet, bevor sie auf Änderungen der Bitrate reagiert
und sie anpasst, um in einer durchschnittlich großen Spanne von Frames eine
konstante Bitrate zu erhalten.
.
.TP
.B rc_averaging_period=<Wert>
Eine wirklich konstante Bitrate ist nur schwer zu erreichen.
Abhängig vom Videomaterial kann die Bitrate variabel und schwer vorauszusagen
sein.
Daher benutzt der XviD-Encoder einen durchschnittlichen Zeitraum, für den er
eine gegebene Anzahl Bits garantiert (minus einer kleinen Schwankung).
Diese Option setzt die Anzahl der Frames, über denen XviD die Bitrate mittelt,
um eine konstante Bitrate zu erreichen.
.
.TP
.B rc_buffer=<Wert>
Größe des Bitratenkontrollpuffers
.
.TP
.B quant_range=<1\-31>\-<1\-31>[/\:<1\-31>\-<1\-31>]
CBR-Modus: minimaler und maximaler Quantisierungsparameter für alle Frames
(Standard: 2\-31)
.br
Two-pass-Modus: minimaler und maximaler Quantisierungsparameter für
I/\:P-Frames (Standard: 2\-31/\:2\-31)
.br
.I WARNUNG:
Seit Version 1.0.x von XviD ist diese Option ersetzt durch die
Optionen [min|max]_[i|p|b]quant.
.
.TP
.B min_key_interval=<Wert>
minimale Anzahl Frames zwischen zwei Keyframes (Standard: 0, nur im
two-pass-Modus)
.
.TP
.B max_key_interval=<Wert>
maximale Anzahl Frames zwischen zwei Keyframes (Standard: 10*fps)
.
.TP
.B mpeg_quant
Benutze die MPEG-Quantisierung anstelle von H.263.
Bei hohen Bitraten wirst du meinen, dass die MPEG-Quantisierung mehr Details
behält.
Bei niedrigen Bitraten wird die Glättung von H.263 weniger Blockartefakte
liefern.
Bei der Benutzung eigener Matrizen muss die MPEG-Quantisierung benutzt werden.
.br
.I WARNUNG:
Seit XviD 1.0.x ist diese Option durch die Option quant_type ersetzt.
.
.TP
.B mod_quant
Entscheide für jedes Bild, ob MPEG- oder H.263-Quantisierung zu verwenden
ist (nur im two-pass-Modus).
.br
.I WARNUNG:
Dies erzeugt einen unerlaubten Bitstream, der höchstwahrscheinlich von keinem
Decoder außer libavcodec oder XviD dekodiert werden kann.
.br
.I WARNUNG:
Seit Version 1.0.x von XviD ist diese Version nicht länger verfügbar.
.
.TP
.B keyframe_boost=<0\-1000>
Diese Option verlagert einige Bits aus dem Vorrat anderer Frametypen zu
Intraframes, so dass die Qualität von Keyframes verbessert wird. (Standard: 0,
nur im two-pass-Modus)
.
.TP
.B kfthreshold=<Wert>
(Standard: 10, nur im two-pass-Modus)
.
.TP
.B kfreduction=<0-\100>
Die oberen beiden Einstellungen können genutzt werden, um die Größe von
Keyframes anzupassen, die du für zu nah (hintereinander) zum ersten hältst.
Kfthreshold setzt den Bereich, in dem Keyframes reduziert werden, und
kfreduction bestimmt die Reduktion der Bitrate, die angewendet wird.
Der letzte Intraframe wird normal behandelt.
(Standard: 30, nur im two-pass-Modus)
.
.TP
.B divx5bvop
Generiere DivX5-kompatible B-Frames (Standard: aktiviert).
Dies scheint für alte Versionen des DivX-Decoders notwendig zu sein.
.br
.I WARNUNG:
Seit XviD 1.0.x ist diese Option durch die Option closed_gop ersetzt.
.
.TP
.B (no)greyscale
Sorge dafür, dass XviD die Chrominanzebenen verwirft, so dass das encodierte
Video schwarz/weiß wird.
Beachte, dass dies den Encodierungsvorgang nicht beschleunigt, es werden in
der letzten Stufe der Encodierung einfach keine Farbdaten geschrieben.
.
.TP
.B debug\ \ 
Speichert Statistiken für jeden einzelnen Frame in ./xvid.dbg.
(Dies ist nicht das Logfile des two-pass-Modus.)
.RE
.
.PP
.sp 1
Die folgenden Optionen sind nur für die neuesten stabilen Versionen von XviD
1.0.x (api4) verfügbar.
.
.TP
.B (no)packed
Diese Option ist dazu gedacht, Probleme mit der Framereihenfolge zu lösen bei
der Encodierung in Containerformate wie AVI, die mit out-of-order-Frames nicht
umgehen können.
In der Praxis können die meisten (sowohl Software- als auch Hardware-) Decoder
die Framereihenfolge richtig handhaben, es kann sie sogar verwirren, wenn
diese Option aktiviert ist.
Du kannst sie also mit Sicherheit weglassen; aktiviere sie nur, wenn du genau
weißt, was du tust.
.br
.I WARNUNG:
Dies erzeugt einen unerlaubten Bitstream, der höchstwahrscheinlich von keinem
Decoder außer DivX/\:libavcodec/\:XviD dekodiert werden kann.
.br
.I WARNUNG:
Dies wird außerdem eine vorgetäuschte DivX-Version in der Datei speichern,
welche die Fehlerkorrekturmechanismen mancher Decoder verwirren kann.
.
.TP
.B max_bframes=<0\-4>
Maximale Anzahl der B-Frames, die zwischen I- und P-Frames gesetzt wird
(Standard: 0).
.
.TP
.B bquant_ratio=<0\-1000>
Verhältnis von B-Frames zu nicht-B-Frames bei der Quantisierung, 150=1.50
(Standard: 150).
.
.TP
.B bquant_offset=<-1000\-1000>
Offset von B-Frames zu nicht-B-Frames bei der Quantisierung, 100=1.00
(Standard: 100).
.
.TP
.B bf_threshold=<-255\-255>
Manchmal sehen B-Frames nicht gut aus und führen zu Artefakten, wenn der
größte Teil des Bildes still steht und nur kleine Bereiche viel Bewegung
beinhalten (in einer ruhigen Szene mit einem sprechenden Mann wird dessen Mund
wahrscheinlich schlecht aussehen, wenn die Umgebung komplett still steht).
Diese Option erlaubt dir, die Priorität für die Benutzung von
B-Frames anzugeben.
Je höher der Wert, desto wahrscheinlicher wird ein B-Frame benutzt.
(Standard: 0)
.
.TP
.B (no)closed_gop
Diese Option weist XviD an, jede GOP (Group Of Pictures, Gruppe von Bildern,
die von zwei I-Frames begrenzt sind) zu schließen, was die GOPs unabhängig
voneinander macht.
Dies bedeutet lediglich, dass der letzte Frame einer GOP entweder ein P- oder
ein N-Frame ist, nicht aber ein B-Frame.
Es ist normalerweise sinnvoll, diese Option zu aktivieren (Standard:
aktiviert).
.
.TP
.B frame_drop_ratio=<0\-100> (nur mit max_bframes=0)
Diese Einstellung erlaubt die Erstellung von Videostreams mit variabler
Bitrate.
Der Wert dieser Einstellung gibt den Schwellenwert an, ab dem ein Frame nicht
encodiert wird, wenn nämlich die Differenz des folgenden zum vorigen Frame
kleiner oder gleich diesem Schwellenwert ist (ein sogenanntes n-vop wird in
den Stream geschrieben).
Bei der Wiedergabe wird bei Erreichen eines n-vop der vorige Frame dargestellt.
.br
.I WARNUNG:
Rumspielen mit dieser Einstellung kann zu ruckelnden Videos führen, benutze
sie also auf eigenes Risiko!
.
.TP
.B (no)qpel
MPEG-4 benutzt normalerweise eine Präzision halber Pixel für die
Bewegungsabschätzung.
Der Standard schlägt einen Modus vor, in dem es Encodern erlaubt ist, eine
Präzision von einem Viertel Pixel zu verwenden.
Dies führt gewöhnlicherweise zu einem schärferen Bild.
Nachteilig ist, dass dies einen großen Einfluss auf die Bitrate hat, und
manchmal verhindert dies auch ein besseres Bild bei fester Bitrate.
Es ist besser, im Einzelfall zu entscheiden, ob es sich lohnt, diese Option zu
aktivieren.
.
.TP
.B (no)gmc
Aktiviert 'Global Motion Compensation', welche XviD spezielle Frames
(GMC-frames) generieren lässt, die sich gut für Pan/\:Zoom/\:Drehung von
Bildern eignen.
Ob das Benutzen dieser Option Bits einspart, hängt sehr vom Quellmaterial ab.
.
.TP
.B (no)trellis
Die Trellis-Quantisierung ist eine Art adaptive Quantisierungsmethode, die Bits
einspart, indem sie die Quantisierungskoeffizienten so verändert, dass sie vom
Entropie-Encoder stärker komprimiert werden können.
Der Einfluss auf die Qualität ist gut, und falls VHQ für dich zu viel
CPU-Leistung braucht, kann diese Option eine gute Möglichkeit sein, mit
weniger Aufwand als bei VHQ ein paar Bits einzusparen (und bei fester Bitrate
die Qualität zu erhöhen) (Standard: aktiviert).
.
.TP
.B (no)cartoon
Aktiviere diese Option, wenn die zu encodierende Sequenz ein Anime/Cartoon ist.
Sie modifiziert ein paar XviD-interne Schwellenwerte, so dass XviD bei
Frametypen und Motion-Vectors für flach aussehende Cartoons bessere
Entscheidungen trifft.
.
.TP
.B quant_type=<h263|mpeg>
Bestimmt die zu benutzende Quantisierungsmethode.
Bei hohen Bitraten wirst du meinen, dass die MPEG-Quantisierung mehr Details
behält.
Bei niedrigen Bitraten wird die Glättung von H.263 weniger Blockartefakte
liefern.
Bei der Benutzung eigener Matrizen
.B muss
die MPEG-Quantisierung benutzt werden.
.
.TP
.B (no)chroma_me
Normalerweise benutzt der Algorithmus für die Bewegungsabschätzung nur
Helligkeitsinformationen, um den besten Motion-Vector zu finden.
Für manches Videomaterial jedoch kann die Benutzung der Chrominanzebenen
helfen, bessere Resultate zu finden.
Diese Einstellung (de)aktiviert die Benutzung der Chrominanzebenen für die
Bewegungsabschätzung (Standard: aktiviert).
.
.TP
.B (no)chroma_opt
Aktiviert einen Vorfilter für die Farbtonoptimierung.
Er wird ein paar Tricks auf die Farbinformationen anwenden, um Kammeffekte an
Kanten zu minimieren.
Er wird die Qualität auf Kosten der Zeit für die Encodierung verbessern.
Naturgemäß verringert er PSNR (Peak Signal to Noise Ratio), da die
mathematische Abweichung zum Originalbild größer wird, aber der subjektive
Eindruck wird ein besserer sein.
Da er Farbinformationen benutzt, solltest du ihn bei Encodierung im
Schwarz/\:Weiß-Modus abschalten.
.br
PSNR ist ein Maß für die wahrgenommene Qualität des Videos.
.
.TP
.B (no)hq_ac
Aktiviert die 'High Quality AC coefficient prediction', also die Vorhersage
von Koeffizienten von benachbarten Blöcken.
.
.TP
.B vhq=<0\-4>
Der Algorithmus für die Bewegungsabschätzung basiert auf der Suche im
normalen Farbraum und versucht, einen Motion-Vector zu finden, der die
Differenz zwischen dem ursprünglichen und dem encodierten Frame minimiert.
Ist diese Option aktiviert, benutzt XviD außerdem den Frequenzbereich
(frequency domain, DCT), um nach einem Motion-Vector zu suchen, der nicht nur
den Unterschied in einem bestimmten Gebiet, sondern außerdem die encodierte
Länge eines Blocks minimiert.
Vom schnellsten zum langsamsten:
.PD 0
.RSs
.IPs 0
aus
.IPs 1
Entscheidung des Modus (Inter-/\:Intra-Macro-Block) (Standard)
.IPs 2
begrenzte Suche
.IPs 3
mittlere Suche
.IPs 4
ausgiebige Suche
.RE
.PD 1
.
.TP
.B min_iquant=<0\-31>
minimaler Wert für den Quantisierungsparameter für I-Frames (Standard: 2)
.
.TP
.B max_iquant=<0\-31>
maximaler Wert für den Quantisierungsparameter für I-Frames (Standard: 2)
.
.TP
.B min_pquant=<0\-31>
minimaler Wert für den Quantisierungsparameter für P-Frames (Standard: 2)
.
.TP
.B max_pquant=<0\-31>
maximaler Wert für den Quantisierungsparameter für P-Frames (Standard: 31)
.
.TP
.B min_bquant=<0\-31>
minimaler Wert für den Quantisierungsparameter für B-Frames (Standard: 2)
.
.TP
.B max_bquant=<0\-31>
minimaler Wert für den Quantisierungsparameter für B-Frames (Standard: 31)
.
.TP
.B quant_intra_matrix=<Dateiname>
Lädt eine Datei mit einer eigenen Intra-Matrix.
Du kannst eine solche mit dem Matrixeditor xvid4conf erstellen.
.
.TP
.B quant_inter_matrix=<Dateiname>
Lädt eine Datei mit einer eigenen Inter-Matrix.
Du kannst eine solche mit dem Matrixeditor xvid4conf erstellen.
.
.TP
.B curve_compression_high=<0\-100>
Diese Einstellung erlaubt XviD, einen gewissen Teil der Bits weg von Szenen
mit hohen Bitraten zu nehmen und dem allgemeinen Vorrat für Bits hinzuzufügen.
Du kannst diese Option benutzen, falls du einen Film mit so vielen schnell
bewegten Szenen hast, dass die Szenen mit geringeren Bitraten anfangen,
schlecht auszusehen (Standard: 0).
.
.TP
.B curve_compression_low=<0\-100>
Diese Einstellung erlaubt XviD, einen gewissen Teil der allgemein verfügbaren
Bits den Szenen zuzuteilen, die mit niedrigen/niedrigeren Bitraten codiert
werden, wobei dafür dem ganzen Video ein paar Bits weggenommen werden.
Die kann sich nützlich erweisen, wenn du ein paar Szenen mit eigentlich
niedriger Bitrate hast, die trotzdem Blockeffekte zeigen (Standard: 0).
.
.TP
.B overflow_control_strength=<0\-100>
Während des ersten Durchlaufs der two-pass-Encodierung wird eine skalierte
Kurve berechnet.
Die Differenz zwischen dieser erwarteten Kurve und dem bei der Encodierung
erzielten Resultat wird Overflow genannt.
Offensichtlich wird beim zweiten Durchlauf versucht, diesen Overflow zu
kompensieren, indem er über die nächsten Frames verteilt wird.
Diese Einstellung kontrolliert, wie stark ein Overflow für jeden neuen
Frame verteilt wird.
Niedrige Werte erlauben eine lässige Kontrolle des Overflows, so dass sehr
hohe Bitraten langsamer abgefangen werden (was bei kurzen Clips die
Präzision verringern kann).
Hohe Werte machen Änderungen der Bit-Verteilung abrupter, wahrscheinlich sogar
zu abrupt, wenn du zu hohe Werte wählst, was zu Artefakten führen kann
(Standard: 5).
.br
.I ANMERKUNG:
Diese Einstellung hat großen Einfluss auf die Qualität, spiele damit also nur
vorsichtig!
.
.TP
.B max_overflow_improvement=<0\-100>
Während der Zuteilung von Bits für Frames kann die Kontrolle für den Overflow
die Größe eines Frames erhöhen.
Dieser Parameter bestimmt den maximalen Anteil, um den dieser Kontrolle
erlaubt wird, die Größe eines Frames im Vergleich zu der idealen Kurve zu
erhöhen (Standard: 5).
.
.TP
.B max_overflow_degradation=<0\-100>
Während der Zuteilung von Bits für Frames, kann die Kontrolle für den Overflow
die Größe eines Frames verringern.
Dieser Parameter bestimmt den maximalen Anteil, um den dieser Kontrolle
erlaubt wird, die Größe eines Frames im Vergleich zu der idealen Kurve zu
verringern (Standard: 5).
.
.TP
.B container_frame_overhead=<0...>
Gibt den mittleren Frame-Overhead pro Frame in Bytes an.
Meistens geben Benutzer die Zielbitrate für ein Video an, ohne dabei den
Overhead des Videocontainers zu beachten.
Dieser kleine aber (meistens) konstante Overhead kann dazu führen, dass die
gewünschte Dateigröße überschritten wird.
XviD erlaubt Benutzern, den Anteil des Overheads anzugeben, der pro Frame
erzeugt wird (gib nur einen Durchschnittswert pro Frame an).
Die Null hat eine spezielle Bedeutung, sie lässt XviD eigene Standardwerte
wählen (Standard: 24 \- durchschnittlicher Overhead für AVIs).
.
.TP
.B par=<Modus>
Gibt den Modus für die Pixel Aspect Ratio (PAR) an, also dem Größenverhältnis
der Pixel (nicht zu verwechseln mit dem Aspekt auf dem Bildschirm).
PAR ist das Verhältnis von Breite zu Höhe eines einzelnen Pixels.
Beide Verhältnisse stehen also in folgendem Zusammenhang: DAR = PAR *
(Breite/Höhe).
.br
MPEG-4 definiert 5 verschiedene Pixel-Aspekte sowie einen erweiterten, der es
erlaubt, einen eigenen spezifischen Pixel-Aspekt anzugeben.
Fünf Standardmodi können angegeben werden:
.PD 0
.RSs
.IPs vga11
Das ist der normale PAR für Inhalte auf dem PC.
Pixel sind hierbei einheitliche Quadrate.
.IPs pal43
PAL-Standard 4:3 PAR.
Pixel sind Rechtecke.
.IPs pal169
das gleiche wie oben
.IPs ntsc43
das gleiche wie oben
.IPs ntsc169
das gleiche wie oben erwähnt (Vergiss nicht, das genaue Verhältnis anzugeben)
.IPs ext\ \ 
Erlaubt dir, einen eigenen Aspekt (PAR) mit par_width und par_height anzugeben.
.RE
.PD 1
.RS
.I ANMERKUNG:
Normalerweise ist das Setzen der Optionen aspect und autoaspect ausreichend.
.RE
.
.TP
.B par_width=<1\-255> (nur bei par=ext)
Gibt die Breite des Pixel-Größenverhältnisses an.
.
.TP
.B par_height=<1\-255> (nur bei par=ext)
Gibt die Höhe des Pixel-Größenverhältnisses an.
.
.TP
.B aspect=<x/\:y | f (Fließkommazahl)>
Speichere den Filmaspekt intern, wie bei MPEG-Dateien.
Dies ist eine viel elegantere Lösung als den Film neu zu skalieren, da die
Qualität nicht verringert wird.
MPlayer und ein paar andere Player werden diese Dateien korrekt wiedergeben,
andere werden das Größenverhältnis falsch darstellen.
Der Parameter für das Verhältnis kann als Bruch oder Fließkommawert angegeben
werden.
.
.TP
.B (no)autoaspect
Das gleiche wie die Option aspect, wobei jedoch das Verhältnis automatisch
berechnet wird.
Veränderungen in der Filterkette wie crop/\:expand/\:scale/\:etc.\& werden
dabei berücksichtigt.
.
.TP
.B psnr\ \ \ 
Gib den PSNR-Wert (Peak Signal to Noise Ratio) des kompletten Films nach dem
Encodieren aus und speichere ihn für jeden einzelnen Frame in einer Datei der
Form 'psnr_hhmmss.log' im aktuellen Verzeichnis.
Die angegebenen Werte haben die Einheit dB (Dezibel), je höher desto besser.
.
.PP
.sp 1
Die folgende Option ist nur in den Entwicklerversionen von XviD 1.1.x
verfügbar.
.
.TP
.B bvhq=<0|1>
Diese Einstellung erlaubt mögliche Auswahlen des Encodierungsvorgangs für
B-Frames, einen Raten-störungsoptimierten Operator verwenden, was für
P-Frames mit der Option vhq getan wird.
Dies liefert besser aussehende B-Frames, während fast keine
Performance-Einbußen auftreten (Standard: 1).
.
.
.SS x264enc (\-x264encopts)
.
.TP
.B bitrate=<Wert>
Setzt die durchschnittlich zu benutzende Bitrate in kbits/\:Sekunde (Standard:
deaktiviert).
Da eine lokale Bitrate variieren kann, kann dieser Durchschnitt für sehr kurze
Videos ungenau sein (siehe ratetol).
Konstante Bitrate kann erreicht werden, indem diese Option mit vbv_maxrate
kombiniert wird, was jedoch die Qualität signifikant verringert.
.
.TP
.B qp_constant=<1\-51>
Dies wählt die zu benutzende Quantisierung für P-Frames.
Intra- und B-Frames haben von diesem Wert einen Offset von ip_factor und
pb_factor respektive.
20\-40 ist ein brauchbarer Bereich (Standard: 26).
Niedrigerere Werte resultieren in besserer Wiedergabetreue aber höheren
Bitraten.
Beachte, dass Quantisierung in H.264 unterschiedlich zu MPEG-1/2/4
funktioniert:
Quantisierungsparameter (QP) von H.264 werden logarithmisch skaliert.
Das Mapping beträgt ungefähr H264QP = 12 + 6*log2(MPEGQP).
Zum Beispiel ist MPEG bei QP=2 äquivalent zu H.264 bei QP=18.
.
.TP
.B pass=<1\-3>
Aktiviert 2- oder 3-pass-Modus.
Es wird empfohlen, immer im 2- oder 3-pass-Modus zu encodieren, da es zu einer
besseren Zuteilung der Bits führt und die Qualität im Ganzen verbessert.
.PD 0
.RSs
.IPs 1
erster Durchlauf
.IPs 2
zweiter Durchlauf (bei Encodierung im two-pass-Modus)
.IPs 3
Nter Durchlauf (zweiter und dritter Durchlauf der three-pass-Encodierung)
.RE
.RS
Hier also wie es funktioniert und anzuwenden ist:
.br
Der erste Durchlauf (pass=1) sammelt Statistiken über das Video und schreibt
sie in eine Datei.
Du möchtest vielleicht manche CPU-intensive Optionen deaktivieren, abgesehen
von denen, die als Standardeinstellung aktiviert sind.
.br
Im Modus mit zwei Durchläufen liest der zweite Durchlauf (pass=2) die
Statistiken und steuert dementsprechend Entscheidungen der Bitratenkontrolle.
.br
Im Modus mit drei Durchläufen tut der zweite Durchlauf (pass=3, kein
Rechtschreibfehler) beides: Er liest zuerst die Statistiken und überschreibt
sie dann.
Du kannst alle Optionen für die Encodierung verwenden, außer den sehr
CPU-intensiven.
.br
Der dritte Durchlauf (pass=3) ist dasselbe wie der zweite, außer, dass er die
Statistiken des zweiten Durchlaufs zur Grundlage hat.
Du kannst alle Optionen für die Encodierung verwenden, auch die sehr
CPU-intensiven.
.br
Der erste Durchlauf kann entweder durchschnittlich Bitrate oder konstanten
Quantisierungsparameter verwenden.
ABR wird empfohlen, da er nicht darauf angewiesen ist, einen
Quantisierungsparameter zu ermitteln.
Aufeinanderfolgende Durchläufe sind ABR und müssen eine Bitrate angeben.
.br
.I ANMERKUNG:
Die Unterstützung für die Encodierung in drei Durchläufen für x264 ist neu in
MEncoder, wir freuen uns daher über jegliches Feedback, das du geben kannst
hinsichtlich guten Kombinationen von x264-Optionen, die sowohl schnell sind als
auch gute Qualität liefern.
.REss
.
.TP
.B qcomp=<0\-1> (ABR oder two-pass)
Kompression des Quantisierungsparameters (Standard: 0.6).
Ein niedrigerer Wert macht die Bitrate konstanter, während ein höherer Wert
die Quantisierungsparameter konstanter macht.
.
.TP
.B direct_pred=<0\-2>
Bestimmt den Typ der Bewegungsabschätzung, die in B-Frames für direkte
Macroblöcke benutzt wird.
.PD 0
.RSs
.IPs 0
Keiner: direkte Macroblöcke werden nicht benutzt.
.IPs 1
Regional: Motion-Vectors werden von benachbarten Blöcken extrapoliert.
.IPs 2
Zeitlich: Motion-Vectors werden vom folgenden P-Frame extrapoliert (Standard).
.RE
.PD 1
Regional und zeitlich sind ungefähr gleich schnell und haben einen ähnlichen
PSNR-Wert, zeitlich sieht jedoch oft besser aus.
direct_pred=0 ist langsamer und liefert schlechtere Qualität.
.
.TP
.B (no)weight_b
Benutze gewichtete Vorhersage für B-Frames.
Ohne diese Option liefern bidirektional gerichtete Makroblöcke jedem
Referenzframe das gleiche Gewicht.
Mit dieser Option wird die Gewichtung durch Bestimmung der zeitlichen Position
eines B-Frames zu seinen Referenzen bestimmt.
Benötigt bframes > 1.
.
.TP
.B me=<1\-3>
Wählt Vollpixel-Bewegungsabschätzungsalgorithmus (me = motion estimation).
.PD 0
.RSs
.IPs 1
Diamantsuche, Radius 1 (schnell).
.IPs 2
Hexagonsuche, Radius 2 (Standard).
.IPs 3
Erschöpfende Suche, kontrolliert von me_range (sehr langsam).
.RE
.PD 1
.
.TP
.B me_range=<4\-64>
Radius der Erschöpfenden Bewegungssuche (Standard: 16).
.
.TP
.B subq=<1\-5>
Passt die Qualität der subpel-Verfeinerung an.
Dieser Parameter kontrolliert den Ausgleich von Qualität und Geschwindigkeit
beim Prozess der Bewegungsabschätzung.
subq=5 kann bis zu 10% besser komprimieren als subq=1.
.RSs
1: Startet Vollpixel-Präzisions-Bewegungsabschätzung für alle in Frage
kommenden Makroblock-Typen und wählt dann den besten aus.
Dann verfeinert er die Bewegung dieses Typs zu einer schnellen
Viertelpixel-Präzision (am schnellsten).
.br
2: Wie 1, benutzt aber eine langsamere Viertelpixel-Verfeinerung.
.br
3: Startet Halbpixel-Präzisions-Bewegungsabschätzung für alle in Frage
kommenden Makroblock-Typen und wählt dann den besten aus.
Dann verfeinert er die Bewegung dieses Typs zu einer Viertelpixel-Präzision.
.br
4: Startet schnelle Viertelpixel-Präzisions-Bewegungsabschätzung für alle in
Frage kommenden Makroblock-Typen, wählt den besten aus und beendet die
Viertelpixel-Verfeinerung für diesen Typ.
.br
5: Startet Viertelpixel-Präzisions-Bewegungsabschätzung in der höchsten
Qualitätsstufe für alle in Frage kommenden Makroblock-Typen, bevor er den
besten Typ auswählt (am besten, Standard).
.REss
Oben beschriebene "alle in Frage kommenden Makroblock-Typen" bedeut nicht alle
möglichen Typen:
4x4, 4x8, 8x4 werden nur probiert, wenn 8x8 besser ist als 16x16.
.
.TP
.B keyint=<Wert>
Setzt das maximale Intervall zwischen IDR-Frames (Standard: 250).
Größere Werte sparen Bits und erhöhen so die Qualität, dies geht aber auf
Kosten der Genauigkeit beim Spulen.
Im Gegensatz zu MPEG-1/2/4, leidet H.264 bei großen Werten für keyint nicht
am DCT-Drift.
.
.TP
.B keyint_min=<1\-keyint/\:2>
Setzt das minimale Intervall zwischen IDR-Frames (Standard: 25).
Sollten Szenenwechsel innerhalb dieses Intervalls vorkommen, so werden sie als
Intraframes encodiert und nicht als Beginn einer neuen GOP.
Bei H.264 sind Intraframes nicht notwendigerweise an eine geschlossene GOP
gebunden.
Denn es ist für einen P-Frame möglich, von mehr als einem vorigen Frame aus
vorhergesagt zu werden (siehe auch frameref).
Daher läßt sich durch Intraframes nicht notwendigerweise spulen.
IDR-Frames schränken aufeinanderfolgende P-Frames insofern ein, dass sie auf
keinen Frame, der vor der IDR-Frame liegt, verweisen.
.
.TP
.B (no)chroma_me
Benutzt Chrominanzinformationen bei der Subpixel-Bewegungsabschätzung
(Standard: aktiviert).
Benötigt subq=5.
.
.TP
.B chroma_qp_offset=<-12\-12>
Benutzt einen anderen Quantisierungsparameter für Chrominanz im Vergleich zur
Helligkeit.
Brauchbare Werte liegen im Bereich <-2\-2> (Standard: 0).
.
.TP
.B level_idc=<10\-51>
Setzt das Level des Bitstreams wie in Anhang A des H.264-Standard definiert
Standard: 40 (Level 4.0).
Dies wird benutzt, um dem Decoder mitzuteilen, welche Fähigkeiten dieser
unterstützen muß.
Benutze diesen Parameter nur, wenn du weißt, was er bedeutet, und du ihn
wirklich setzen mußt.
.
.TP
.B log=<-1\-3>
Passt an, wieviele Logging-Informationen ausgegeben werden.
.RSs
-1: keine
.br
 0: Gib nur Fehler aus.
.br
 1: Warnungen
.br
 2: PSNR und andere Statistiken der Analyse, wenn die Encodierung fertig ist
(Standard)
.br
 3: PSNR, QP, Frametyp, Größe und andere Statistiken für jeden Frame
.REss
.
.TP
.B scenecut=<-1\-100>
Steuert, wie energisch Intraframes extra eingefügt werden (Standard: 40).
Bei geringen Werten für scenecut erzwingt der Codec häufig einen Intraframe,
wenn dies den Wert für keyint überschreiten würde.
Gute Werte für scenecut können eine bessere Positionierung für Intraframes
finden.
Hohe Werte verwenden mehr Intraframes als nötig, was Bits verschwendet.
-1 deaktiviert die Erkennung von Szenenwechseln, so dass Intraframes nur alle
keyint Frames eingefügt werden, selbst wenn ein Szenenwechsel schon früher
stattfindet.
Dies wird nicht empfohlen und verschwendet Bits, da Szenenwechsel, die als
P-Frames codiert werden, genauso groß sind wie Intraframes, den Zähler für
keyint aber nicht zurücksetzen.
.
.TP
.B frameref=<1\-16>
Anzahl der vorigen Frames, die für die Vorhersage in B- und P-Frames verwendet
werden (Standard: 1).
Dies is effektiv in Animes, bei Material mit Live-Action aber nehmen die
Verbesserungen bei mehr als ca.\& 6 Referenzframes schnell ab.
Dies hat keinen Effekt auf die Geschwindigkeit der Decodierung, es erhöht nur
den dafür nötigen Speicherbedarf.
Manche Decoder sind nicht in der Lage, mehr als 15 Referenzframes zu
verarbeiten.
.
.TP
.B bframes=<0\-16>
maximale Anzahl aufeinanderfolgender B-Frames zwischen Intra- und P-Frames
(Standard: 0)
.
.TP
.B (no)b_adapt
Entscheidet automatisch, wann und wie viele B-Frames benutzt werden, bis zum
oben definierten Maximum (Standard: aktiviert).
Wenn diese Option deaktiviert ist, wird die maximale Anzahl B-Frames benutzt.
.
.TP
.B b_bias=<-100\-100>
Steuert die von b_adapt getroffene Entscheidung.
Ein höherer b_bias-Wert bewirkt mehr B-Frames (Standard: 0).
.
.TP
.B (no)b_pyramid
Erlaubt B-Frames, als Referenz für die Vorhersage von anderen Frames zu dienen.
Betrachte zum Beispiel drei aufeinanderfolgende B-Frames: I0 B1 B2 B3 P4.
Ohne diese Option würden B-Frames dem selben Muster folgen wie MPEG-[124].
Also werden sie in der Reihenfolge I0 P4 B1 B2 B3 codiert, und alle B-Frames
werden von I0 und P4 vorhergesagt.
Mit dieser Option werden sie als I0 P4 B2 B1 B3 kodiert.
B2 ist der gleiche wie oben, aber B1 wird von I0 und B2 vorhergesagt, und B3
wird von B2 und P4 vorhergesagt.
Dies bewirkt normalerweise eine leicht verbesserte Kompression, bei fast keinen
Kosten für die Geschwindigkeit.
Dies ist trotzdem eine experimentelle Option: Sie ist nicht völlig abgestimmt
und wird nicht immer helfen.
Benötigt bframes >= 2.
Nachteil: Verzögert eine Decodierungsverzögerung um 2 Frames.
.
.TP
.B (no)deblock
Benutze einen Deblocking-Filter (Standard: aktiviert).
Da es sehr wenig Zeit kostet verglichen mit dem Gewinn von Qualität, wird nicht
empfohlen, ihn zu deaktivieren.
.
.TP
.B deblockalpha=<-6\-6>
AlphaC0-Parameter des Deblocking-Filters (Standard: 0).
Dieser passt Schwellenwerte für den In-loop-Deblocking-Filter von H.264 an.
Zuerst passt dieser Parameter den maximalen Wert an, um den dieser Filter
einen Pixel verändern darf.
Als zweites beeinflusst dieser Parameter den Schwellenwert für die Differenz
jenseits der Kante, die gefiltert wird.
Ein positiver Wert reduziert Blockartefakte stärker, wird jedoch Details
verschmieren.
.br
Das Standardverhalten des Filters erreicht fast immer optimale Qualität, daher
ist es am besten, die Werte nicht zu ändern oder nur geringe Änderungen
vorzunehmen.
Wenn dein Quellmaterial aber doch schon Blöcke oder Rauschen enthält, die du
entfernen möchtest, kann es eine gute Idee sein, ihn etwas zu erhöhen.
.
.TP
.B deblockbeta=<-6\-6>
Beta-Parameter des Deblocking-Filters (Standard: 0).
Beeinflusst den Schwellenwert für Details.
Sehr detaillierte Blöcke werden nicht gefiltert, da das Weichzeichnen des
Filters stärker auffallen würde als Blocking-Effekte des Originals.
.
.TP
.B (no)cabac
Benutze CABAC (Context-Adaptive Binary Arithmetic Coding) (Standard:
aktiviert)
Verlangsamt Encodierung und Decodierung leicht, sollte aber 10-15%
Bitrate sparen.
Wenn du nicht gerade nach Decodiergeschwindigkeit suchst, solltest du dies
nicht deaktivieren.
.
.TP
.B qp_min=<1\-51> (ABR oder two-pass)
minimaler Quantisierungsparameter, 10\-30 scheint ein brauchbarer Bereich zu
sein Standard: 10).
.
.TP
.B qp_max=<1\-51> (ABR oder two-pass)
maximaler Quantisierungsparameter (Standard: 51)
.
.TP
.B qp_step=<1\-50> (ABR oder two-pass)
maximaler Wert, um den der Quantisierungsparameter zwischen
Frames erhöht/erniedrigt werden darf (Standard: 2)
.
.TP
.B ratetol=<0.1\-100.0> (ABR oder two-pass)
erlaubte Abweichung der durchschnittlichen Bitrate (keine bestimmten
Einheiten) (Standard: 1.0)
.
.TP
.B vbv_maxrate=<Wert> (ABR oder two-pass)
maximale lokale Bitrate in kbits/\:Sekunde (Standard: deaktiviert)
.
.TP
.B vbv_bufsize=<Wert> (ABR oder two-pass)
Intervall für vbv_maxrate, über die gemittelt wird in kbits (Standard: keiner,
muss angegeben werden, wenn vbv_maxrate aktiviert wird)
.
.TP
.B vbv_init=<0.0\-1.0> (ABR oder two-pass)
initiale Bufferbelegung als Bruchteil von vbv_bufsize (Standard: 0.9)
.
.
.SS MPEG Muxer (\-mpegopts)
.
Der MPEG Muxer kann 5 verschiedene Streamtypen generieren, wovon jeder
sinnvolle Standardparameter hat, die der Benutzer überschreiben kann.
Beim Generieren von MPEG-Dateien ist es generell sinnvoll, den Frame-skip Code
von MEncoder zu benutzen (siehe \-noskip, \-mc sowie die Videofilter harddup
und softskip).
.br
.
.TP
.B format=<mpeg1 | mpeg2 | xvcd | xsvcd | dvd>
Streamformat (Standard: mpeg2)
.
.TP
.B size=<bis zu 65535>
Paketgröße in Bytes; verändere diese nicht, wenn du nicht genau weißt, was du
tust (Standard: 2048).
.
.TP
.B muxrate=<int>
Nominale Mux-Rate in kbit/s, die in den Paket-Headern benutzt wird (Standard:
1800 kb/s).
Wird aktualisiert, wenn nötig, im Falle 'format=mpeg1' oder 'mpeg2'.
.
.TP
.B tsaf\ \ \ 
Setzt Zeitstempel (timestamps) bei allen Frames, wenn möglich.
.
.TP
.B (no)reorder
Aktiviert Code für Neuanordnung von Frames.
Frames werden in Decodierungs- (und nicht Anzeige-) reihenfolge gespeichert
(Standard: deaktiviert).
Benutze dies nur, wenn du glaubst, dass Videoframes im originalen Stream nicht
korrekt gespeichert wurden.
Funktioniert nur mit MPEG-1/2-Video.
.
.TP
.B init_vpts=<100\-700>
initiales Video pts in Millisekunden (Standard: 200)
.
.TP
.B init_apts=<100\-700>
initiales Audio pts in Millisekunden (Standard: 200)
.
.
.TP
.B vdelay=<1\-32760>
Initiale Zeit, um die das Video verzögert wird, in Millisekunden (Standard:
0), benutze dies, um Video in bezug zu Audio zu verzögern.
.
.TP
.B drop\ \ \ 
Bei Benutzung mit init_adelay verwirft der Muxer den Teil der Audiospur, die
angepasst wurde.
.
.
.TP
.B vwidth, vheight=<1\-4095>
Setzt Videobreite und -höhe, wenn das Video MPEG-1/2 ist.
.
.
.TP
.B vpswidth, vpsheight=<1\-4095>
Setzt Videobreite und -höhe bei Pan-und-Scan-Video bei MPEG-2.
.
.
.TP
.B vaspect=<1 | 4/3 | 16/9 | 221/100>
Setzt den Aspekt für MPEG-1/2-Video.
.
.
.TP
.B vbitrate=<int>
Setzt die Videobitrate in kbit/s für MPEG-1/2-Video.
.
.
.TP
.B vframerate=<24000/1001 | 24 | 25 | 30000/1001 | 30 | 50 | 60000/1001 | 60 >
Setzt die Framerate bei MPEG-1/2-Video.
Diese Option wird ignoriert, wenn sie zusammen mit der Option telecine benutzt
wird.
.
.TP
.B telecine
Aktiviert Soft-telecine-Modus: Der Muxer wird tricksen, so dass der
Videostream wie mit 29.97 oder 30 fps encodiert aussieht; das funktioniert nur
mit MPEG-2-Video, wenn die Framerate der Ausgabe, eventuell konvertiert
mit \-ofps, entweder 23.976 oder 24 fps beträgt.
Jede andere Framerate ist mit dieser Option nicht kompatibel.
.
.
.\" --------------------------------------------------------------------------
.\" Dateien
.\" --------------------------------------------------------------------------
.
.SH DATEIEN
.TP
/usr/\:local/\:etc/\:mplayer/\:mplayer.conf
systemweite Einstellungen
.
.TP
~/.mplayer/\:config
Benutzereinstellungen
.
.TP
~/.mplayer/\:input.conf
Eingabebelegungen (siehe '\-input keylist' für eine vollständige Auflistung
aller Tastennamen)
.
.TP
~/.mplayer/\:gui.pl
Playlist für die GUI
.
.TP
~/.mplayer/\:font/
Schriftartenverzeichnis (es müssen sich eine Datei font.desc und Dateien mit
der Erweiterung .RAW in dem Verzeichnis befinden)
.
.TP
~/.mplayer/\:DVDkeys/
zwischengespeicherte CSS-Schlüssel
.
.TP
Angenommen, dass /Pfad/\:zum/\:film.avi abgespielt wird,
sucht MPlayer nach Untertiteldateien in folgender Reihenfolge:
.RS
/Pfad/\:zum/\:film.sub
.br
~/.mplayer/\:sub/\:film.sub
.br
~/.mplayer/\:default.sub
.RE
.PD 1
.
.
.\" --------------------------------------------------------------------------
.\" Beispiele
.\" --------------------------------------------------------------------------
.
.SH BEISPIELE ZUM GEBRAUCH VON MPLAYER
.
.TP
.B Schnellstart für das Abspielen einer DVD:
mplayer dvd://1
.
.TP
.B Audio auf Japanisch mit englischen Untertiteln:
mplayer dvd://1 \-alang ja \-slang en
.
.TP
.B Spiele nur die Kapitel 5, 6, 7:
mplayer dvd://1 \-chapter 5-7
.
.TP
.B Spiele nur die Titel 5, 6, 7:
mplayer dvd://5-7
.
.TP
.B bei einer DVD mit mehreren Kameraperspektiven:
mplayer dvd://1 \-dvdangle 2
.
.TP
.B Abspielen von einem anderen DVD-Gerät:
mplayer dvd://1 \-dvd-device /dev/\:dvd2
.
.TP
.B Spiele DVD-Videos direkt aus einem Verzeichnis mit VOB-Dateien:
mplayer dvd://1 \-dvd-device /Pfad/\:zum/\:Verzeichnis/
.
.TP
.B Kopiere den Titel einer DVD auf die Festplatte, speichere die Datei unter dem Namen "title1.vob":
mplayer dvd://1 \-dumpstream \-dumpfile title1.vob
.
.TP
.B Streaming per HTTP:
mplayer http://mplayer.hq/\:example.avi
.
.TP
.B Streaming mit RTSP:
mplayer rtsp://server.example.com/\:streamName
.
.TP
.B Konvertiere Untertitel in das MPsub-Format:
mplayer dummy.avi \-sub source.sub \-dumpmpsub
.
.TP
.B Konvertiere Untertitel in das MPsub-Format, ohne dabei das Video anzuschauen:
mplayer /dev/\:zero \-rawvideo on:pal:fps=xx \-vc null \-vo null \-noframedrop
\-benchmark \-sub source.sub \-dumpmpsub
.
.TP
.B Lies vom Standard-V4L-Gerät:
mplayer tv:// \-tv driver=v4l:width=640:height=480:outfmt=i420 \-vc rawi420
\-vo xv
.
.TP
.B Wiedergabe auf Zoran-Karten (alte Bauweise, veraltet):
mplayer \-vo zr \-vf scale=352:288 Datei.avi
.
.TP
.B Wiedergabe auf Zoran-Karten (neue Bauweise):
mplayer \-vo zr2 \-vf scale=352:288,zrmjpeg Datei.avi
.
.TP
.B Spiele eine 6-kanalige AAC-Datei mit nur zwei Lautsprechern ab:
mplayer \-rawaudio on:format=0xff \-af pan=6:.32:.39:.06:.17:-.17:.33:.32:.06:.39:-.17:.17:.33 adts_he-aac160_51.aac
.br
Du könntest etwas mit den Werten für pan experimentieren (z.B.\& mit einem
Wert multiplizieren), um die Lautstärke zu erhöhen oder Abschneiden von Sound
zu vermeiden.
.
.SH BEISPIELE ZUM GEBRAUCH VON MENCODER
.
.TP
.B Encodiere Titel Nr. 2 der DVD, aber nur ausgewählte Kapitel:
mencoder dvd://2 \-chapter 10-15 \-o title2.avi \-oac copy \-ovc
lavc \-lavcopts vcodec=mpeg4
.
.TP
.B Encodiere Titel Nr. 2 der DVD und skaliere auf 640x480:
mencoder dvd://2 \-vf scale=640:480 \-o title2.avi \-oac copy \-ovc
lavc \-lavcopts vcodec=mpeg4
.
.TP
.B Encodiere Titel Nr. 2 der DVD und skaliere auf 512xHHH unter Beibehaltung des Höhen-/Breitenverhältnisses:
mencoder dvd://2 \-vf scale \-zoom \-xy 512 \-o title2.avi \-oac
copy \-ovc lavc \-lavcopts vcodec=mpeg4
.
.TP
.B Das gleiche, aber mit einer Bitrate von 1800kBit und optimierten Makroblocks:
mencoder dvd://2 \-o title2.avi \-oac copy \-ovc
lavc \-lavcopts vcodec=mpeg4:mbd=1:vbitrate=1800
.
.TP
.B Das gleiche, aber mit MJPEG-Kompression:
mencoder dvd://2 \-o titel2.avi \-ovc lavc \-lavcopts
vcodec=mjpeg:mbd=1:vbitrate=1800 \-oac copy
.
.TP
.B Encodiere alle .jpg-Dateien im aktuellen Verzeichnis:
mencoder "mf://*.jpg" \-mf fps=25 \-o output.avi \-ovc lavc \-lavcopts
vcodec=mpeg4
.
.TP
.B Encodiere aus einem Fernsehsignal (gib ein Format mit \-vf format an):
mencoder \-tv driver=v4l:width=640:height=480 tv:// \-o tv.avi \-ovc raw
.
.TP
.B Encodiere aus einer Pipe:
rar p test-SVCD.rar | mencoder \-ovc lavc \-lavcopts
vcodec=mpeg4:vbitrate=800 \-ofps 24 -
.
.
.\" --------------------------------------------------------------------------
.\" Fehler, Autoren, Haftungsausschluss
.\" --------------------------------------------------------------------------
.
.SH FEHLER/\:BUGS
Berichte uns davon, wenn du einen findest, sei aber sicher, dass Du vorher die
ganze Dokumentation gelesen hast.
Viele Fehler sind das Resultat eines fehlerhaften Setups oder falscher
Benutzung der Parameter.
Die Sektion über Fehlerberichterstattung in der Dokumentation
(DOCS/de/bugreports.html) beschreibt, wie man nutzbringende Fehlerberichte
erstellt.
.
.
.
.SH AUTOREN
MPlayer wurde ursprünglich von Arpad Gereöffy geschrieben.
Siehe Datei AUTHORS für eine Liste einiger der vielen anderen Beitragenden.
.PP
MPlayer is (C) 2000\-2005 The MPlayer Team
.PP
Diese Manpage wurde zum größten Teil von Gabucino, Diego Biurrun und
Jonas Jermann geschrieben und von Moritz Bunkus und Sebastian Krämer
ins Deutsche übersetzt.
Sie wird gepflegt von Sebastian Krämer.
Schicke Mails die Manpage betreffend bitte an die MPlayer-DOCS-Mailingliste.
.\" Ende der Datei
