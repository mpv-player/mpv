Video Filters
=============

Video filters are plugin-like code modules implementing the interface
defined in vf.h.

Basically it means video output manipulation, i.e. these plugins can
modify the image and the image properties (size, colorspace etc) between
the video decoders (vd.h) and the output layer (libvo or video encoders).

The actual API is a mixture of the video decoder (vd.h) and libvo
(video_out.h) APIs.

main differences:
- vf plugins may be "loaded" multiple times, with different parameters
  and context - it's new in MPlayer, old APIs weren't reentrant.
- vf plugins don't have to implement all functions - all functions have a
  'fallback' version, so the plugins only override these if wanted.
- Each vf plugin has its own get_image context, and they can interchange
  images/buffers using these get_image/put_image calls.

API details:
-- TO DO --  (see vf.h for API and vf_*.c for examples)

Current plugins:
================

-vf crop[=w:h:x:y]
    Simple cropping plugin.
    w,h (cropped width,height) defaults to original width,height
    x,y (position of cropped subimage on the original image) defaults to center
    MPI: EXPORT only, using stride manipulation

-vf expand[=w:h:x:y:o]
    Expanding _and_ (optional) OSD rendering plugin.
    w,h (expanded width,height) defaults (-1) to original width,height
    x,y (position of original image on the expanded image) defaults (-1) to center
    o   (0=disable/1=enable SUB/OSD rendering) defaults (0) to disabled
    MPI: DR (if possible) or copy
    Special: mpcodecs core uses it to solve stride restrictions between filters
	     MEncoder uses (autoload) it to render SUB/OSD

-vf flip
    Flips image upside-down (vertical mirroring)
    No parameters.
    MPI: DR (if possible) or EXPORT, using stride manipulation
    Special: dec_video autoloads it when flipping is required and libvo can't do

-vf mirror
    Horizontal mirroring
    No parameters.
    MPI: TEMP

-vf rectangle[=w:h:x:y]
    Draw a rectangle.  Useful for testing crop plugin parameters.
    w,h (rectangle's width and height) defaults (-1) to maximum
        possible width while keeping the boundaries visible.
    x,y (rectangle's top left corner position) defaults (-1) to upper
        left most position.
    The plugin responds to the input.conf directive "change_rectangle"
    that takes two parameters.  The first parameter can be 0 for w, 1
    for h, 2 for x or 3 for y.  The second parameter is the amount to
    change the designated rectangle boundary.
    MPI: TEMP, accepts stride

-vf rotate[=x]
    Rotate image +/- 90 degrees
    Optional 'x' parameter (0..3) controls horizontal and vertical mirroring
    MPI: TEMP

-vf scale[=w:h[:c[:p]]]
    Software scaling (zoom) _and_ yuv<->rgb colorspace conversion
    w,h (new width/height after scaling) defaults to original width,height
	Note: If -zoom is used, and underlying filters (including libvo) are
	incapable of scaling, then it defaults to d_width/d_height!
	note 2: w/h values -1 means original width/height, 0 means scaled
	d_width/d_height. -2/-3 means calculating w or h using the other
	dimension and the original (-3) or prescaled (-2) aspect ratio.
    c   chroma skipping
	0 -> use all available input lines for chroma
	1 -> use only every 2. input line for chroma
	2 -> use only every 4. input line for chroma
	3 -> use only every 8. input line for chroma
    p	scaling parameter (depends upon the scaling method used)
	for -sws 2 (bicubic)  it is sharpness (0 (soft) - 100 (sharp))
	for -sws 7 (gaussian) it is sharpness (0 (soft) - 100 (sharp))
	for -sws 9 (lanczos)  it is filter length (1 - 10)
    MPI: TEMP, accepts stride
    Special: dec_video and mpcodecs core autoloads it for colorspace conv.

-vf yuy2
    Forced software YV12/I420 -> YUY2 conversion
    (useful for video cards/drivers with slow YV12 but fast YUY2 support)
    MPI: TEMP, accepts stride

-vf rgb2bgr[=swap]
    RGB 24/32 <-> BGR 24/32 colorspace conversion (default) or
    RGB 24/32 <-> RGB 24/32 conversion with R<->B swapping ('swap' option)
    MPI: TEMP, accepts stride

-vf palette
    RGB/BGR 8 -> RGB/BGR 15/16/24/32 colorspace conversion using palette
    MPI: TEMP, accepts stride
    
-vf format[=fourcc]
    _restrict_ the list of supported colorspaces (query-format()) to a single,
    given fourcc. The 'fourcc' option defaults to 'yuy2', but may be any
    format name, like rgb15, bgr24, yv12 etc...
    Note again that it does NOT do any conversion, it just limits the format
    list for the _next_ plugin.
    MPI: passthru

-vf pp=[<filterName>[:<option>[:<option>...]][/[-]<filterName>[:<option>...]]...]
    postprocessing filter.  (useful for codecs without built-in
    postprocessing, like libmpeg12 or libavcodec)
    see `mplayer -vf pp=help`
    MPI: DR (if possible) or TEMP
    Special: dec_video autoloads it if -pp option is used but codec can't do pp.

-vf lavc[=quality:fps]
    Fast software YV12->MPEG1 conversion, useful for DXR3/DVB drivers
    It uses libavcodec. Currently faster and better quality than -vf fame!
    Param quality: fixed qscale (1<=quality<32) or bitrate (32<=quality KBits)
    Param fps: force output fps (float value). If not give, or 0, it's
    autodetected based on height (240,480->29.97fps, others -> 25fps)
    MPI: EXPORT special

-vf fame
    Fast software YV12->MPEG1 conversion, useful for DXR3/DVB drivers
    It uses libfame.
    MPI: EXPORT special

-vf dvbscale[=aspect]
    Setup scaling to the optimal values for the DVB card.
    (use HW for X-scaling, calc sw Y scaling to keep aspect)
    The 'aspect' parameter controls aspect ratio, it should be calculated
    as aspect=DVB_HEIGHT*ASPECTRATIO, default is 576*(4/3)=768
    (for 16:9 TV set it to 576*(16/9)=1024)
    It's only useful together with expand+scale:
	-vf dvbscale,scale=-1:0,expand=-1:576:-1:-1:1,lavc
    MPI: passthru

-vf cropdetect[=limit]
    It's a special filter, it doesn't alter the image itself, but detects
    (using some kind of heuristics) the black borders/bands of the image,
    and prints the optimal -vf crop= parameters to the stdout/console.
    It calculates the average value of pixel luminances for a line, and
    depending on the result it's either black band (result<=limit) or
    picture (result>limit). Optional parameter 'limit' defaults to 24.
    MPI: EXPORT

-vf test[=first frame number]
    generate various test patterns
    MPI: TEMP, accepts stride

-vf noise[=lumaNoise[u][t|a][h]:chromaNoise[u][t|a][h]
    add noise
    0<= lumaNoise, chromaNoise <=100
    u uniform noise (gaussian otherwise)
    t temporal noise (noise pattern changes between frames)
    a averaged temporal (smoother, but a lot slower)
    h high quality (slightly better looking, slightly slower)
    p mix random noise with a (semi)regular pattern
    MPI: DR (if possible) or TEMP, accepts stride

-vf eq[=brightness:contrast]
    software equalizer, for use with cards that don't support
    brightness and contrast controls in hardware. It might also be
    useful with MEncoder, either for fixing poorly captured movies, or
    for slightly reducing contrast to mask artifacts and get by with
    lower bitrates. Initial values in the range -100..100 may be
    given on the command line, and the eq filter is controllable
    interactively just like with normal hardware equalizer controls.

-vf eq2[=gamma:contrast:brightness:saturation:r_gamma:g_gamma:b_gamma]
    advanced software equalizer, for use with cards that don't support
    brightness/contrast/saturation and channel gamma controls in hardware.
    Initial values in the range -2.0 .. 2.0 may be given on the command line,
    and the eq2 filter is controllable interactively just like with normal
    hardware equalizer controls or -vf eq. Defaults: 1:1:0:1:1:1:1
    This filter uses MMX only if available and all gamma == 1.0, otherwise
    LUT (look-up table) is being used.

-vf unsharp=l|cWxH:amount[:l|cWxH:amount]
    unsharp mask / gaussian blur.
        l   apply effect on luma component
        c   apply effect on chroma components
      WxH   width and height of the matrix, odd sized in both directions
            min = 3x3, max = 13x11 or 11x13
            usually you will use something between 3x3 and 7x7
    amount  relative amount of sharpness / blur to add to the image
            amount < 0 = blur, amount > 0 = sharpen
            usually you will use something between -1.5 and 1.5
    MPI: DR (if possible) or TEMP, accepts stride

-vf swapuv
    swap U & V plane
    MPI: EXPORT
    
-vf il=[d|i][s][:[d|i][s]]
    (de)interleaves lines
    d deinterleave
    i interleave
    s swap fields (exchange even & odd lines)
    The goal of this filter is to add the ability to process interlaced images 
    pre-field without deinterlacing them. You can filter your interlaced DVD
    and play it on a TV without breaking the interlacing. 
    While deinterlacing (with the postprocessing filter) removes interlacing
    permanently (by smoothing, averaging, etc) deinterleaving splits the 
    frame into 2 fields (so called half pictures), so you can process (filter)
    them independently and then re-interleave them.
    MPI: TEMP, accepts stride

-vf boxblur=radius:power[:radius:power]
    radius size of the filter
    power  how often the filter should be applied
    MPI: TEMP, accepts stride

-vf sab=radius:prefilter:colorDiff[:radius:prefilter:colorDiff]
    radius	blur filter strength (~0.1-4.0) (slower if larger)
    prefilter	prefilter strength (~0.1-2.0)
    colorDiff	how different the pixels are allowed to be considered (~0.1-100.0)

-vf smartblur=radius:stregth:threshold[:radius:stregth:threshold]
    radius	blur filter strength (~0.1-5.0) (slower if larger)
    strength	(0.0-1.0) -> blur, (-1.0-0.0) -> sharpen
    threshold	0 -> filter all, (0-30) -> filter flat areas, (-30-0) -> filter edges

-vf perspective=x0:y0:x1:y1:x2:y2:x3:y3:t
    x0,y0,...	coordinates of the top left, top right, bottom left, bottom right corners
    t		0-> linear, 1->cubic resampling

-vf denoise3d=[luma:chroma:time]
    luma	spatial luma strength (default = 4)
    chroma	spatial chroma strength (default = 3)
    time	temporal strength (default = 6)
    This filter aims to reduce image noise producing smooth images and
    making still images really still. (it should enhance compressibility)
    Can be given from 0 to 3 parameters. Parameters not given will be
    inferred from the given ones. (i.e. providing only one of them acts as a
    "scale factor")
