<?xml version="1.0" encoding="utf-8"?>
<!-- synced with r27770 -->
<chapter id="video">
<title>Dispositivi di uscita video</title>

<sect1 id="mtrr">
<title>Impostare gli MTRR</title>

<para>
Si consiglia vivamente di controllare che i registri MTRR siano impostati
correttamente, al fine di migliorare molto le prestazioni.
</para>

<para>
Fai un <command>cat /proc/mtrr</command>:
<screen>
<prompt>--($:~)--</prompt> cat /proc/mtrr
reg00: base=0xe4000000 (3648MB), size=  16MB: write-combining, count=9
reg01: base=0xd8000000 (3456MB), size= 128MB: write-combining, count=1<!--
--></screen>
</para>

<para>
E' giusto, mostra la mia Matrox G400 con 16MB di memoria. L'ho fatto da
XFree 4.x.x, che imposta i registri MTRR automaticamente.
</para>

<para>
Se non ha funzionato, devi farlo a mano. Per prima cosa, devi trovare
l'indirizzo di base. Hai 3 modi per trovarlo:

<orderedlist>
<listitem><para>
  dai messaggi di avvio di X11, per esempio:
  <screen>
(--) SVGA: PCI: Matrox MGA G400 AGP rev 4, Memory @ 0xd8000000, 0xd4000000
(--) SVGA: Linear framebuffer at 0xD8000000<!--
  --></screen>
</para></listitem>
<listitem><para>
  da <filename>/proc/pci</filename> (usa il comando
  <command>lspci -v</command>):
  <screen>
01:00.0 VGA compatible controller: Matrox Graphics, Inc.: Unknown device 0525
Memory at d8000000 (32-bit, prefetchable)<!--
  --></screen>
</para></listitem>
<listitem><para>
  dai messaggi del driver del kernel mga_vid (usa <command>dmesg</command>):
  <screen>mga_mem_base = d8000000</screen>
</para></listitem>
</orderedlist>
</para>

<para>
Ora troviamo la dimensione della memoria. Questo è molto facile, converti
semplicemente la video RAM in esadecimale, o usa questa tabella:
<informaltable frame="none">
<tgroup cols="2">
<tbody>
  <row><entry>1 MB</entry><entry>0x100000</entry></row>
  <row><entry>2 MB</entry><entry>0x200000</entry></row>
  <row><entry>4 MB</entry><entry>0x400000</entry></row>
  <row><entry>8 MB</entry><entry>0x800000</entry></row>
  <row><entry>16 MB</entry><entry>0x1000000</entry></row>
  <row><entry>32 MB</entry><entry>0x2000000</entry></row>
</tbody>
</tgroup>
</informaltable>
</para>

<para>
Ora che sai l'indirizzo di base e la dimensione della memoria, impostiamo i
registri MTRR!
Per esempio, per la scheda Matrox suddetta (<literal>base=0xd8000000</literal>)
con 32MB di ram (<literal>size=0x2000000</literal>) esegui semplicemente:
<screen>
echo "base=0xd8000000 size=0x2000000 type=write-combining" &gt; /proc/mtrr
</screen>
</para>

<para>
Non tutte le CPU hanno gli MTRR. Per esempio le CPU K6-2 più vecchie (intorno
ai 266MHz, stepping 0) non hanno degli MTRR, ma gli stepping 12 invece sì
(esegui <command>cat /proc/cpuinfo</command> per verificarlo).
</para>
</sect1>


<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->


<sect1 id="xv">
<title>Xv</title>

<para>
In XFree86 4.0.2 o successivi, puoi utilizzare le funzioni YUV hardware della
tua scheda usando l'estensione XVideo. Questo è quello che fa l'opzione
<option>-vo xv</option>. Inoltre, il driver supporta l'impostazione di
luminosità/contrasto/tonalità/etc (a meno che tu non usi il vecchio e
lento codec DirectShow DivX, che le supporta ovunque), vedi la pagina man.
</para>

<para>
In order to make this work, be sure to check the following:
Per far sì che funzioni, assicurati di controllare le seguenti:

<orderedlist>
<listitem><para>
  Che tu usi XFree86 4.0.2 o superiore (le versioni precedenti non hanno XVideo)
</para></listitem>
<listitem><para>
  Che la tua scheda supporti l'accelerazione hardware (le schede moderne
  la supportano)
</para></listitem>
<listitem><para>
  Che X carichi l'estensione XVideo, è un qualcosa del genere:
  <programlisting>(II) Loading extension XVideo</programlisting>
  in <filename>/var/log/XFree86.0.log</filename>
  <note><para>
   Questo carica solo l'estensione per XFree86. In una buona installazione
   viene sempre caricata, e non significa che il supporto per l'XVideo della
   <emphasis role="bold">scheda</emphasis> sia presente!
  </para></note>
</para></listitem>
<listitem><para>
  Che la tua scheda abbia il supporto Xv sotto Linux. Per controllare, prova con
  <command>xvinfo</command>, è parte della distribuzione di XFree86. Dovrebbe
  mostrarti un lungo testo, simile al seguente:
  <screen>
X-Video Extension version 2.2
screen #0
  Adaptor #0: "Savage Streams Engine"
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
(...)
    Number of image formats: 7
      id: 0x32595559 (YUY2)
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        type: YUV (packed)
      id: 0x32315659 (YV12)
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
(...etc...)<!--
--></screen>
  Deve supportare i formati pixel YUY2 packed e YV12 planar per poter essere
  utilizzabile con <application>MPlayer</application>.
</para></listitem>
<listitem><para>
  E infine, controlla che <application>MPlayer</application> sia stato compilato
  col supporto per 'xv'. Lancia un <command>mplayer -vo help | grep xv </command>.
  Se il supporto per 'xv' è compilato, dovrebbe uscire una linea come la
  seguente:
  <screen>  xv      X11/Xv</screen>
</para></listitem>
</orderedlist>
</para>


<sect2 id="tdfx">
<title>Schede 3dfx</title>

<para>
I vecchi driver 3dfx avevano notoriamente dei problemi con l'accelerazione
XVideo, non erano compatibili con gli spazi colore YV12 e YUY2. Verifica di
avere XFree86 4.2.0 o superiore, può gestire YV12 e YUY2, mentre le versioni
precedenti, 4.1.0 incluso,
<emphasis role="bold">vanno in crash con YV12</emphasis>. Se hai degli strani
risultati usando <option>-vo xv</option>, prova SDL (anch'essa ha XVideo) e vedi
se aiuta. Controlla la sezione su <link linkend="sdl">SDL</link> per i dettagli.
</para>

<para>
<emphasis role="bold">OPPURE</emphasis>, prova il NUOVO driver
<option>-vo tdfxfb</option>! Vedi la sezione
<link linkend="tdfxfb">tdfxfb</link>
</para>
</sect2>


<sect2 id="s3">
<title>Schede S3</title>

<para>
Le S3 Savage3D dovrebbero funzionare bene, ma per le Savage4, usa XFree86 4.0.3
o superiore (nel caso tu abbia problemi di immagini, prova a 16bpp). Per le
S3 Virge invece: c'è il supporto per xv, ma la scheda in sé è molto lenta,
per cui ti conviene venderla.
</para>

<para>
Non c'è un driver framebuffer nativo per le schede S3 Virge simile a tdfxfb.
Configura il tuo framebuffer (per es. aggiungi
"<option>vga=792 video=vesa:mtrr</option>" alla riga di avvio del kernel) e usa
<option>-vo s3fb</option> (<option>-vf yuy2</option> e <option>-dr</option>
aiutano).
</para>

<note><para>
Non è ben chiaro il perché i modelli Savage non abbiano il supporto YV12 e
facciano la conversione con il driver (lento). Se pensi sia colpa della scheda,
cerca un driver più recente, o chiedi gentilmente di un driver abilitato
MMX/3DNow! sulla mailing list MPlayer-users.
</para></note>
</sect2>


<sect2 id="nvidia">
<title>Schede nVidia</title>

<para>
nVidia non è sempre una scelta molto buona sotto Linux... Il driver
open-source di XFree86 supporta la maggior parte di queste schede, ma in alcuni
casi, dovrai usare il driver proprietario a sorgenti chiusi di nVidia,
disponibile sul
<ulink url="http://www.nvidia.com/object/linux.html">sito nVidia</ulink>.
Ti servirà sempre questo driver anche se vuoi l'accelerazione 3D.
</para>

<para>
Le schede Riva128 non hanno il supporto XVideo con il driver nVidia di
XFree86 :(
Lamentati con nVidia.
</para>

<para>
Tuttavia, <application>MPlayer</application> contiene un driver
<link linkend="vidix">VIDIX</link> per la maggior parte delle schede nVidia.
Attualmente è a livello di sviluppo beta e ha alcuni problemi. Per
ulteriori informazioni, vedi la sezione
<link linkend="vidix-nvidia">VIDIX nVidia</link>.
</para>
</sect2>


<sect2 id="ati">
<title>Schede ATI</title>

<para>
Il <ulink url="http://gatos.sf.net">driver GATOS</ulink>
(che dovresti usare a meno che tu non abbia una Rage128 o una Radeon) di
default ha il VSYNC abilitato. Ciò significa che la velocità di decodifica
(!) è sincronizzata alla frequenza di aggiornamento del monitor. Se la
riproduzione ti pare lenta, prova a disabilitare in qualche modo VSYNC, o ad
impostare la frequenza di aggiornamento a n*(fps del film) Hz.
</para>

<para>
Read the <link linkend="vidix">VIDIX</link> section.
Radeon VE - se ti serve X, per questa scheda usa XFree86 4.2.0 o superiore.
Il TV out non è supportato. Ovviamente con <application>MPlayer</application>
puoi felicemente avere un display <emphasis role="bold">accelerato</emphasis>,
con o senza l'<emphasis role="bold">uscita TV</emphasis>, e non servono
librerie né X.
Leggi la sezione <link linkend="vidix">VIDIX</link>.
</para>
</sect2>


<sect2 id="neomagic">
<title>Schede NeoMagic</title>

<para>
Queste schede si possono trovare in molti portatili. Devi usare XFree86 4.3.0 o
superiore, o alternativamente usare i
<ulink url="http://www.mplayerhq.hu/MPlayer/contrib/NeoMagic-driver/">driver con Xv</ulink>
di Stefan Seyfried.
Scegli semplicemente quello che ti serve in base alla tua versione di XFree86.
</para>

<para>
XFree86 4.3.0 include il supporto per Xv, caomunque Bohdan Horst ha postato
una piccola <ulink url="http://www.mplayerhq.hu/MPlayer/contrib/NeoMagic-driver/neo_driver.patch">patch</ulink> ai sorgenti di XFree86 che velocizza fino a
quattro volte le operazioni sul framebuffer (quindi XVideo).
La patch è stata poi incorporata in XFree86 CVS e dovrebbe esserci nei rilasci
successivi al 4.3.0.
</para>

<para>
Per permettere la riproduzione di contenuti della dimensione DVD, modifica il
tuo XF86Config in questo modo:
<programlisting>
Section "Device"
    [...]
    Driver "neomagic"
    <emphasis>Option "OverlayMem" "829440"</emphasis>
    [...]
EndSection<!--
--></programlisting>
</para>
</sect2>


<sect2 id="trident">
<title>Schede Trident</title>

<para>
Se vuoi usare Xv con una scheda Trident, assunto il fatto che con 4.1.0 non
funziona, intalla Xfree 4.2.0. Il 4.2.0 aggiunge il supporto per Xv a schermo
intero con la scheda Cyberblade XP.
</para>

<para>
Alternativamente, <application>MPlayer</application> contiene un driver
<link linkend="vidix">VIDIX</link> per le schede Cyberblade/i1.
</para>
</sect2>


<sect2 id="kyro">
<title>Schede Kyro/PowerVR</title>

<para>
Se vuoi usare Xv con una scheda basata su Kyro (per esempio la Hercules
Prophet 4000XT), dovresti scaricare i driver dal
<ulink url="http://www.powervr.com/">sito di PowerVR</ulink>.
</para>
</sect2>


<sect2 id="intel">
<title>Schede Intel</title>

<para>
Queste schede si possono trovare in molti portatili. Si consiglia un Xorg
recente.
</para>

<para>
Per permettere la riproduzione di contenuti a dimensione DVD (o superiore)
modifica il tuo file di configurazione XF86Config/xorg.conf nel modo seguente:
<programlisting>
Section "Device"
    [...]
    Driver "intel"
    <emphasis>Option "LinearAlloc" "6144"</emphasis>
    [...]
EndSection
</programlisting>
L'assenza di questa opzione di solito porta a un errore del tipo
<screen>X11 error: BadAlloc (insufficient resources for operation)</screen>
quando si cerca di usare <option>-vo xv</option>.
</para>
</sect2>
</sect1>

<!-- ********** -->

<sect1 id="dga">
<title>DGA</title>

<formalpara>
<title>PREAMBOLO</title>
<para>
Questa documento cerca di spiegare in poche parole cosa sia DGA e cosa possa
fare (e cosa no) il driver di uscita video DGA di
<application>MPlayer</application>.
</para>
</formalpara>

<formalpara>
<title>COS'E' DGA</title>
<para>
<acronym>DGA</acronym> è il nome breve di <emphasis>Direct Graphics
Access</emphasis> (accesso grafico diretto) ed è un modo per fa sì
che un programma scavalchi l'X server e modifichi direttamente la memoria
del framebuffer. In termini tecnici la memoria del framebuffer viene
rimappata nello spazio di memoria del tuo processo.
Questo è permesso dal kernel solo se hai provilegi di superutente. Puoi averli
o autenticandoti come <systemitem class="username">root</systemitem> o
impostando il bit SUID sull'eseguibile di <application>MPlayer</application>
(<emphasis role="bold">sconsigliato</emphasis>).
</para>
</formalpara>
<para>
Ci sono due versioni di DGA: DGA1 usato da XFree 3.x.x e DGA2 che è stato
introdotto con XFree 4.0.1.
</para>

<para>
DGA1 fornisce solamente accesso diretto al framebuffer come descritto sopra.
Per modificare la risoluzione del segnale video devi affidarti all'estensione
XVidMode.
</para>

<para>
DGA2 include le funzionalità dell'estensione XVidMode e inoltre permette la
modifica della profondità di colore del display. Così, anche se stai facendo
girare un X server con profondità di 32 bit, puoi passare a una di 15 e
viceversa.
</para>

<para>
Tuttavia DGA ha dei punti deboli. Sembra sia in qualche modo dipendente dal
chip grafico utilizzato e dall'implementazione del driver video dell'X server
che controlla tale chip. Per cui non funziona su tutti i sistemi...
</para>

<formalpara>
<title>INSTALLARE IL SUPPORTO PER DGA IN MPLAYER</title>

<para>
Per prima cosa assicurati che X carichi l'estensione DGA, guarda in
<filename>/var/log/XFree86.0.log</filename>:

<programlisting>(II) Loading extension XFree86-DGA</programlisting>

Attenzione, si <emphasis role="bold">consiglia vivamente </emphasis>
XFree86 4.0.x o superiore!
Il driver DGA di <application>MPlayer</application> viene rilevato
automaticamente da <filename>./configure</filename>, ovvero puoi forzarlo
con <option>--enable-dga</option>.
</para>
</formalpara>

<para>
Se il driver non è riuscito a reimpostare una risoluzione inferiore, fai delle
prove con le opzioni <option>-vm</option> (solo con X 3.3.x),
<option>-fs</option>, <option>-bpp</option>, <option>-zoom</option> per trovare
una modalità video in cui ci stia il film. Per ora non c'è un convertitore :(
</para>

<para>
Diventa <systemitem class="username">root</systemitem>. A DGA serve l'accesso
da root per essere in grado di scrivere direttamente sulla memoria video. Se
vuoi eseguirlo come utente, allora installa <application>MPlayer</application>
SUID root:

<screen>
chown root <replaceable>/usr/local/bin/mplayer</replaceable>
chmod 750 <replaceable>/usr/local/bin/mplayer</replaceable>
chmod +s <replaceable>/usr/local/bin/mplayer</replaceable>
</screen>

Ora funziona anche da utente normale.
</para>

<caution>
<title>Rischi di sicurezza</title>
<para>
Questo porta un <emphasis role="bold">grosso</emphasis> rischio di sicurezza!
Non farlo <emphasis role="bold">mai</emphasis> su un server o su un computer
che può essere utilizzato da altre persone, perché si possono ottenere
privilegi di root attraverso <application>MPlayer</application> SUID root.
</para>
</caution>

<para>
Ora usa l'opzione <option>-vo dga</option>, e sei a cavallo! (speralo:)
Potresti anche provare se ti funziona l'opzione
<option>-vo sdl:driver=dga</option>!
E' molto più veloce!
</para>


<formalpara id="dga-modelines">
<title>MODIFICARE LA RISOLUZIONE</title>

<para>
Il driver DGA permette la modifica della risoluzione del segnale di uscita.
Questo evita la necessità di eseguire un (lento) ridimensionamento software e
allo stesso tempo fornisce un'immagine a schermo pieno. Idealmente dovrebbe
ridimensionarsi alla risoluzione precisa (rispettando il rapporto di aspetto)
dei dati video, ma l'X server permette solo di impostare le risoluzioni
precedentemente definite in <filename>/etc/X11/XF86Config</filename>
(<filename>/etc/X11/XF86Config-4</filename> per XFree 4.X.X).
Queste ultime sono conosciute come "modelines" e dipendono dalle potenzialità
del tuo hardware video. Il server X legge questo file di configurazione
all'avvio e disabilita le modelines incompatibili col tuo hardware.
Puoi scoprire quali modalità ti restano attraverso il file di log di X11.
Si può trovare qui: <filename>/var/log/XFree86.0.log</filename>.
</para>
</formalpara>

<para>
Queste modalità si sa che funzionano correttamente con un chip Riva128,
usando il driver nv.o del server X.
</para>

<para><programlisting>
Section "Modes"
  Identifier "Modes[0]"
  Modeline "800x600"  40     800 840 968 1056  600 601 605 628
  Modeline "712x600"  35.0   712 740 850 900   400 410 412 425
  Modeline "640x480"  25.175 640 664 760 800   480 491 493 525
  Modeline "400x300"  20     400 416 480 528   300 301 303 314 Doublescan
  Modeline "352x288"  25.10  352 368 416 432   288 296 290 310
  Modeline "352x240"  15.750 352 368 416 432   240 244 246 262 Doublescan
  Modeline "320x240"  12.588 320 336 384 400   240 245 246 262 Doublescan
EndSection
</programlisting></para>


<formalpara>
<title>DGA &amp; MPLAYER</title>
<para>
DGA is used in two places with <application>MPlayer</application>: The SDL
driver can be made to make use of it (<option>-vo sdl:driver=dga</option>) and
within the DGA driver (<option>-vo dga</option>). The above said is true
for both; in the following sections I'll explain how the DGA driver for
<application>MPlayer</application> works.
DGA viene usato con <application>MPlayer</application> in due posti: può
essere usato attraverso il driver SDL (<option>-vo sdl:driver=dga</option>) e
con il driver DGA (<option>-vo dga</option>). Quanto detto sopra è valido per
entrambi; nei paragrafi seguenti viene spiegato come il driver DGA funziona per
<application>MPlayer</application>.

</para>
</formalpara>


<formalpara>
<title>CARATTERISTICHE</title>

<para>
Il driver DGA viene utilizzato specificando <option>-vo dga</option> sulla riga
comando. Il comportamento di default è di passare ad una risoluzione il più
vicino possibile a quella originaria del video. Ignora volutamente le opzioni
<option>-vm</option> e <option>-fs</option> (abilitazione ridimensionamento
video e schermo intero) - cerca sempre di coprire la più vasta area possibile
dello schermo reimpostando la modalità video, evitando così di sprecare cicli
della CPU per ridimensionare l'immagine. Se la modalità video selezionata non
ti piace, puoi forzarlo a scegliere la modalità più prossima alla risoluzione
specificata con <option>-x</option> e <option>-y</option>. Impostando l'opzione
<option>-v</option>, il driver DGA emetterà, tra una sacco ci altre cose,
un'elenco delle risoluzioni supportate dal tuo file
<filename>XF86Config</filename>. Se hai DGA2, puoi anche forzarlo ad utilizzare
una data profondità usando l'opzione <option>-bpp</option>. Profondità
valide sono 15, 16, 24 e 32. Se queste profondità siano supportate nativamente
oppure se debba venir effettuata una conversione (eventualmente lenta), dipende
dal tuo hardware.
</para>
</formalpara>
<para>
Se dovessi essere abbastanza fortunato da avere sufficiente memoria fuori dalla
visualizzazione per poterci far stare un'immagine intera, il driver DGA userà
un buffering doppio, fornendo una riproduzione più fluida. Ti dirà quando il
doppio buffering sarà abilitato o no.
</para>

<para>
"Doppio buffering" significa che il fotogramma successivo del video viene
disegnato nella memoria fuori dello schermo, mentre il fotogramma corrente
viene mostrato. Quando il fotogramma successivo è pronto, il chip grafico
rivece solo l'indirizzo in memoria del nuovo fotogramma e semplicemente prende
da là i dati da mostrare. Nel frattempo l'altro buffer di memoria viene
riempito con altri dati video.
</para>

<para>
Il doppio buffering può venir abilitato usando l'opzione
<option>-double</option> e disabilitato con <option>-nodouble</option>.
L'opzione attuale di default è di disabilitarlo. Usando il driver DGA, la
visualizzazione dati su schermo (OSD, onscreen display) funziona solo con il
doppio buffering abilitato. In ogni caso, abilitare il doppio buffering può
portare una pesante penalizzazione della velocità (sul mio K6-II+ 525 usa
un ulteriore 20% di tempo di CPU) in dipendenza dall'implementazione per DGA
del tuo hardware.
</para>


<formalpara>
<title>PROBLEMI DI VELOCITA'</title>

<para>
In generale, l'accesso DGA al framebuffer dovrebbe essere almeno veloce quanto
utilizzare il driver X11, con il beneficio aggiunto di ottenere un'immagine a
schermo intero. I valori di velocità percentuale emessi da
<application>MPlayer</application> devono essere interpretati con un po' di
attenzione, dato che per esempio con il driver X11 non includono il tempo usato
dal server X per il disegno effettivo. Attacca un terminale sulla seriale della
tua macchina e lancia <command>top</command> per vedere cosa stia davvero
succedendo.
</para>
</formalpara>

<para>
In linea di massima, l'aumento di velocità usando DGA rispetto all'utilizzo
'normale' di X11 dipende fortemente dalla tua scheda video e da quanto bene il
relativo modulo del server X sia ottimizzato.
</para>

<para>
Se hai un sistema lento, è meglio usare una profondità di 15 o 16 bit, visto
che richiedono solo la metà della banda di memoria di una visualizzazion a
32 bit.
</para>

<para>
Usare una profondità di 24 è una buona idea anche se la tua scheda supporta
nativamente solo quella a 32 bit, dato che trasferisce il 25% dei dati in meno
rispetto alla modalità a 32/32.
</para>

<para>
Ho visto alcuni file AVI riprodotti su Pentium MMX 266. Le CPU AMD K6-2 possono
lavorare a 400 MHz e oltre.
</para>


<formalpara>
<title>PROBLEMI/BACHI CONOSCIUTI</title>

<para>
Bene, secondo gli sviluppatori di XFree, DGA è quasi una bestia. Ti dicono che
è meglio non usarla. La sua implementazione non è sempre perfetta con tutti i
driver dei chip per XFree che ci sono là fuori.
</para>
</formalpara>

<itemizedlist>
<listitem><para>
  Con XFree 4.0.3 e <filename>nv.o</filename> c'è un baco che porta ad avere
  strani colori.
</para></listitem>
<listitem><para>
  I driver ATI hanno bisogno che la modalità sia reimpostata più di una
  volta dopo aver utilizzato DGA.
</para></listitem>
<listitem><para>
  Alcuni driver semplicemente non riescono a tornare alla risoluzione normale
  (Usa
  <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap><keycap>Keypad +</keycap></keycombo>
  e
  <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap><keycap>Keypad -</keycap></keycombo>
  per cambiarla manualmente).
</para></listitem>
<listitem><para>
  Alcuni driver semplicemente mostrano strani colori.
</para></listitem>
<listitem><para>
  Alcuni driver mentono riguardo alla memoria che mappano nello spazio
  indirizzi del processo, perciò vo_dga non usa il doppio buffering (SIS?).
</para></listitem>
<listitem><para>
  Alcuni driver sembra che falliscano nel fornire almeno una modalità valida.
  In questo caso il driver DGA andrà in crash raccontandoti di una modalità
  senza senso tipo 100000x100000 o qualcosa di simile.
</para></listitem>
<listitem><para>
  L'OSD funziona solo col doppio buffering abilitato (altrimenti sfarfalla).
</para></listitem>
</itemizedlist>

</sect1>

<!-- ********** -->

<sect1 id="sdl">
<title>SDL</title>

<para>
<acronym>SDL</acronym> (Simple Directmedia Layer) è praticamente un'interfaccia
unificata audio/video. I programmi che la usano non sanno che driver video o
audio SDL usi davvero, ma conoscono solo l'interfaccia. Per esempio un porting
di Doom che usi SDL può girara sopra a svgalib, aalib, X, fbdev e altro, devi
semplicemente specificare (per esempio) il driver video da usare attraverso la
variabile d'ambiente <envar>SDL_VIDEODRIVER</envar>. In teoria, perlomeno.
</para>

<para>
Con <application>MPlayer</application>, usiamo la sua potenzialità di
ridimensionamento via software del driver di X11 per le schede che non
gestiscono XVideo, fino a quando non faremo il nostro (più veloce, più bello)
ridimensionatore software. Abbiamo anche usato la sua uscita per aalib, ma ora
abbiamo la nostra che è più comoda. La sua modalità per DGA era migliore
della nostra fino a poco tempo fa. Hai capito, no? :)
</para>

<para>
Aiuta anche con alcuni driver/schede bacate, se il video è scattoso (non per
problemi di sistema lento) oppure l'audio è saltellante.
</para>

<para>
L'uscita video SDL supporta la visualizzazione dei sottotitoli sotto al filmato
ovvero sulla striscia nera (se presente).
</para>
</sect1>

<!-- ********** -->

<sect1 id="svgalib">
<title>SVGAlib</title>

<formalpara>
<title>INSTALLAZIONE</title>
<para>
Affinché <application>MPlayer</application> compili il suo driver per SVGAlib
(autorilevato, ma può essere forzato), devi installare svgalib e il suo
pacchetto di sviluppo e non dimenticare di modificare
<filename>/etc/vga/libvga.config</filename> in modo che corrisponda alla tua
scheda e al tuo monitor.
</para>
</formalpara>

<note><para>
Assicurati di non usare l'opzione <option>-fs</option>, dato che attiva
l'utilizzo del ridimensionatore software, ed è lento. Se davvero ti serve, usa
l'opzione <option>-sws 4</option>, che porterà una bassa qualità, ma è in
qualche modo più veloce.
</para></note>

<formalpara>
<title>SUPPORTO PER EGA (4BPP)</title>
<para>
SVGAlib include EGAlib, e <application>MPlayer</application> ha la possibilità
di mostrare qualsiasi filmato in 16 colori, utilizzabile in queste situazioni:
</para>
</formalpara>

<itemizedlist>
<listitem><para>
  Scheda EGA con monitor EGA: 320x200x4bpp, 640x200x4bpp, 640x350x4bpp
</para></listitem>
<listitem><para>
  Scheda EGA con monitor CGA: 320x200x4bpp, 640x200x4bpp
</para></listitem>
</itemizedlist>

<para>
Il valore dei bpp (bit per pixel) deve essere impostato a 4 manualmente:
<option>-bpp 4</option>
</para>

<para>
Il filmato probabilmente deve essere rimpicciolito per starci nella modalità
EGA:
<screen>-vf scale=640:350</screen>
or
<screen>-vf scale=320:200</screen>
</para>

<para>
Per questo ci serve una funzione di ridimensionamento veloce ma a bassa
qualità:
<screen>-sws 4</screen>
</para>

<para>
Forse la correzione automatica dell'aspetto va disattivata:
<screen>-noaspect</screen>
</para>

<note><para>
Secondo la mia esperienza la qualità migliore dell'immagine su schermi EGA
può essere ottenuta diminuendo un pochino la luminosità:
<option>-vf eq=-20:0</option>. Sul mio sistema ho anche bisogno di abbassare
la frequenza audio, dato che era rovinata a 44kHz:
<option>-srate 22050</option>.
</para></note>

<para>
Puoi abilitare l'OSD e i sottotitoli solo con il filtro <option>expand</option>,
vedi la pagina man per i parametri precisi.
</para>
</sect1>

<!-- ********** -->

<sect1 id="fbdev">
<title>Uscita su framebuffer (FBdev)</title>

<para>
Se compilare l'uscita FBdev o no viene rilevato automaticamente da
<filename>./configure</filename>. Leggi nei sorgenti del kernel la
documentazione sul framebuffer (<filename>Documentation/fb/*</filename>) per
ulteriori informazioni.
</para>

<para>
Se la tua scheda non supporta lo standard VBE 2.0 (vecchie schede ISA/PCI, come
la S3 Trio64), ma solo VBE 1.2 (o precedente?): bene, c'è ancora VESAfb, ma
ddovrai caricare SciTech Display Doctor (conosciuto precedentemente come UniVBE)
prima di avviare Linux. Usa un disco di avvio DOS o qualcosa del genere. E non
dimenticare di registrare il tuo UniVBE ;))
</para>

<para>
L'uscita su FBdev richiede principalmente alcuni parametri addizionali:
</para>

<variablelist>
<varlistentry>
  <term><option>-fb</option></term>
  <listitem><para>
    specifica il dispositivo framebuffer da usare (default:
    <filename>/dev/fb0</filename>)
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-fbmode</option></term>
  <listitem><para>
    nome della modalità da usare (come in <filename>/etc/fb.modes</filename>)
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-fbmodeconfig</option></term>
  <listitem><para>
    file di configirazione delle modalità (default:
    <filename>/etc/fb.modes</filename>)
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-monitor-hfreq</option></term>
  <term><option>-monitor-vfreq</option></term>
  <term><option>-monitor-dotclock</option></term>
  <listitem><para>
    valori <emphasis role="bold">importanti</emphasis>, vedi
    <filename>example.conf</filename>
  </para></listitem>
</varlistentry>
</variablelist>

<para>
Se vuoi passare a una modalità particolare, allora usa
<screen>
mplayer -vm -fbmode <replaceable>nome_modalità</replaceable> <replaceable>nomefile</replaceable>
</screen>
</para>

<itemizedlist>
<listitem><para>
  <option>-vm</option> da sola può scegliere la modalità più adatta da
  <filename>/etc/fb.modes</filename>. Può essere usata anche insieme con le
  opzioni <option>-x</option> e <option>-y</option>. L'opzione
  <option>-flip</option> è supportata solo se il formato pixel del film
  corrisponde al formato pixel della modalità video. Stai attento al valore
  di bpp, il driver fbdev cerca di usare prima quello corrente, poi quello che
  indichi tramite l'opzione <option>-bpp</option> option.
</para></listitem>
<listitem><para>
  l'opzione <option>-zoom</option> non è supportata
  (usa <option>-vf scale</option>). Non puoi usare modalità a 8bbp (o meno).
</para></listitem>
<listitem><para>
  Probabilmente vuoi disabilitare il cursore:
  <screen>echo -e '\033[?25l'</screen>
  o
  <screen>setterm -cursor off</screen>
  e il salvaschermo:
  <screen>setterm -blank 0</screen>
  Per riabilitare il cursore:
  <screen>echo -e '\033[?25h'</screen>
  o
  <screen>setterm -cursor on</screen>
</para></listitem>
</itemizedlist>

<note><para>
La modifica della modalità video di FBdev <emphasis>non funziona</emphasis>
con il framebuffer VESA, e non chiederla, visto che non è una limitazione di
<application>MPlayer</application>.
</para></note>
</sect1>

<!-- ********** -->

<sect1 id="mga_vid">
<title>Framebuffer Matrox (mga_vid)</title>

<para>
<systemitem>mga_vid</systemitem> è un'incrocio di un driver di uscita video e
di un modulo del kernel, che utilizza il ridimensionatore e l'overlay video
delle Matrox G200/G400/G450/G550 per effettuare una conversione dello spazio
colore YUV->RGB e un ridimensionamento video arbitrario.
<systemitem>mga_vid</systemitem> ha un supporto hardware per VSYNC con triplo
buffering. Funziona sia in una console su framebuffer che dentro X, ma solo con
Linux 2.4.x.
</para>

<para>
Per una versione del driver per Linux 2.6.x controlla
<ulink url="http://attila.kinali.ch/mga/"/> oppure butta un occhio sul
repository Subversion esterno di mga_vid, che si può ottenere tramite

<screen>
svn checkout svn://svn.mplayerhq.hu/mga_vid
</screen>
</para>

<procedure>
<title>Installazione:</title>
<step><para>
  Per usarlo devi innanzitutto compilare <filename>drivers/mga_vid.o</filename>:
  <screen>
cd drivers
make drivers<!--
--></screen>
</para></step>
<step><para>
  Poi esegui (come <systemitem class="username">root</systemitem>)
  <screen>make install-drivers</screen>
  che dovrebbe installare il modulo e creare per te il nodo del dispositivo.
  Carica il driver con
  <screen>insmod mga_vid.o</screen>
</para></step>
<step><para>
  Dovresti verificare il rilevamento della dimensione della memoria usando il
  comando <command>dmesg</command>. Se è errato, usa l'opzione
  <option>mga_ram_size</option> (prima fai <command>rmmod mga_vid</command>),
  indicando in MB la dimensione della memoria della scheda:
  <screen>insmod mga_vid.o mga_ram_size=16</screen>
</para></step>
<step><para>
  Per far sì che venga caricato/scaricato quando serve, prima inserisci la
  riga seguente alla fine di <filename>/etc/modules.conf</filename>:

  <programlisting>alias char-major-178 mga_vid</programlisting>
</para></step>
<step><para>
  Ora devi (ri)compilare <application>MPlayer</application>,
  <command>./configure</command> rileverà <filename>/dev/mga_vid</filename> e
  compilerà il driver 'mga'. Si potrà usare da
  <application>MPlayer</application> con <option>-vo mga</option> se sei su una
  console matroxfb, oppure <option>-vo xmga</option> se sei sotto XFree86 3.x.x
  o 4.x.x.
</para></step>
</procedure>

<para>
Il driver mga_vid collabora con Xv.
</para>

<para>
Si può leggere il file del dispositivo <filename>/dev/mga_vid</filename> per
alcune informazioni, per esempio facendo
<screen>cat /dev/mga_vid</screen>
e ci si può scrivere per modificare la luminosità:
<screen>echo "brightness=120" &gt; /dev/mga_vid</screen>
</para>

<para>
Nella stessa directory c'è un'applicazione di test che si chiama
<command>mga_vid_test</command>. Se tutto funziona bene, dovrebbe disegnare
immagini di 256x256 sullo schermo.
</para>

</sect1>

<!-- ********** -->

<sect1 id="tdfxfb" xreflabel="3Dfx YUV support (tdfxfb)">
<title>Supporto YUV per 3Dfx</title>

<para>
Questo driver usa il driver tdfx del kernel per il framebuffer per riprodurre
filmati con accelerazione YUV. Ti serve un kernel con supporto per tdfxfb e
ricompilare con
<screen>./configure --enable-tdfxfb</screen>
</para>
</sect1>

<!-- ********** -->

<sect1 id="tdfx_vid">
<title>tdfx_vid</title>

<para>
Questo è un'incrocio di un driver di uscita video e di un modulo del kernel,
simile a <link linkend="mga_vid">mga_vid</link>. Ti serve un kernel 2.4.x con
il driver <systemitem>agpgart</systemitem>, visto che
<systemitem>tdfx_vid</systemitem> usa AGP. Passa
<option>--enable-tdfxfb</option> a <command>configure</command> per compilare
il driver di uscita video e compila il module del kernel con le istruzioni
seguenti.
</para>

<procedure>
<title>Installare il modulo del kernel tdfx_vid.o:</title>
<step><para>
  Compila <filename>drivers/tdfx_vid.o</filename>:
  <screen>
cd drivers
make drivers</screen>
</para></step>
<step><para>
  Poi esegui (come <systemitem class="username">root</systemitem>)
  <screen>make install-drivers</screen>
  che dovrebbe installare il modulo e creare per te il nodo del dispositivo.
  Carica il driver con
  <screen>insmod tdfx_vid.o</screen>
</para></step>
<step><para>
  Per far sì che venga caricato/scaricato quando serve, prima inserisci la
  riga seguente alla fine di <filename>/etc/modules.conf</filename>:


  <programlisting>alias char-major-178 tdfx_vid</programlisting>
</para></step>
</procedure>

<para>
Nella stessa directory c'è un'applicazione di test che si chiama
<command>tdfx_vid_test</command>. Se tutto funziona bene, dovrebbe fornire
alcune informazioni utili.
</para>

</sect1>

<!-- ********** -->

<sect1 id="opengl">
<title>Uscita OpenGL</title>

<para>
<application>MPlayer</application> supporta la riproduzione di filmati usando
OpenGL, ma se se la tua piattaforma/driver supportano xv come è il caso di un
PC con Linux, allora usa xv, le prestazioni OpenGL sono pesantemente peggiori.
Se hai un'implementazione di X11 senza xv, OpenGL è una valida alternativa.
</para>

<para>
Sfortunatamente non tutti i driver supportano questa caratteristica. I driver
Utah-GLX (per XFree86 3.3.6) la supportano per tutte le schede.
Vedi <ulink url="http://utah-glx.sf.net"/> per dettagli su come installarli.
</para>

<para>
XFree86(DRI) 4.0.3 or later supports OpenGL with Matrox and Radeon cards,
4.2.0 or later supports Rage128.
Vedi <ulink url="http://dri.sf.net"/> for download and installation
instructions.
XFree86(DRI) 4.0.3 o successivi supportano OpenGL con schede Matrox e Radeon,
4.2.0 o successivi supportano le Rage128.
Leggi su <ulink url="http://dri.sf.net"/> le istruzioni per scaricarli ed
installare.
</para>

<para>
Un consiglio per i nostri utenti: l'uscita video GL può essere usata per
ottenere un'uscita sincronizzata su vsync. Devi impostare una variabile
d'ambiente (perlomeno con nVidia):
</para>

<para>
<command>export __GL_SYNC_TO_VBLANK=1</command>
</para>
</sect1>

<!-- ********** -->

<sect1 id="aalib">
<title>AAlib &ndash; Visualizzazione in modalità testuale</title>

<para>
AAlib è una libreria per mostrare elementi grafici in modalità testuale,
usando un potente renderizzatore ASCII. Ci sono <emphasis>valanghe</emphasis>
di programmi che la utilizzano, come Doom, Quake, etc.
<application>MPlayer</application> ne include un driver facilmente utilizzabile.
Se <filename>./configure</filename> trova AAlib installata, il driver di uscita
video per aalib verrà compilato.
</para>

<para>
Puoi usare alcune chiavi nella finestra AA per modificare le opzioni di
renderizzazione:
</para>

<informaltable>
<tgroup cols="2">
<thead>
  <row><entry>Chiave</entry><entry>Azione</entry></row>
</thead>
<tbody>
<row><entry><keycap>1</keycap></entry><entry>
  diminuisce il contrasto
</entry></row>
<row><entry><keycap>2</keycap></entry><entry>
  aumenta il contrasto
</entry></row>
<row><entry><keycap>3</keycap></entry><entry>
  diminuisce la luminosità
</entry></row>
<row><entry><keycap>4</keycap></entry><entry>
  aumenta la luminosità
</entry></row>
<row><entry><keycap>5</keycap></entry><entry>
  abilita/disabilita il fast rendering
</entry></row>
<row><entry><keycap>6</keycap></entry><entry>
  imposta la modalità di dithering (nessuna, distribuzione di errore,
  Floyd Steinberg)
</entry></row>
<row><entry><keycap>7</keycap></entry><entry>
  inverte l'immagine
</entry></row>
<row><entry><keycap>8</keycap></entry><entry>
  passa tra i controlli di aa e quelli di <application>MPlayer</application>
</entry></row>
</tbody>
</tgroup>
</informaltable>

<variablelist>
<title>Si possono usare le seguenti opzioni sulla riga di comando:</title>
<varlistentry>
  <term><option>-aaosdcolor=<replaceable>V</replaceable></option></term>
  <listitem><para>
    modifica il colore OSD
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-aasubcolor=<replaceable>V</replaceable></option></term>
  <listitem><para>
    modifica il colore dei sottitoli
    </para><para>
    dove <replaceable>V</replaceable> può essere:
    <literal>0</literal> (normale),
    <literal>1</literal> (scuro),
    <literal>2</literal> (grassetto),
    <literal>3</literal> (font grassetto),
    <literal>4</literal> (invertito),
    <literal>5</literal> (speciale).
  </para></listitem>
</varlistentry>
</variablelist>

<variablelist>
<title>AAlib di suo fornisce un po' di opzioni. Di seguito alcune
importanti:</title>
<varlistentry>
  <term><option>-aadriver</option></term>
  <listitem><para>
    Impostra il driver aa preferito (X11, curses, Linux).
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-aaextended</option></term>
  <listitem><para>
    Usa tutti e 256 i caratteri.
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-aaeight</option></term>
  <listitem><para>
    Usa ASCII a otto bit.
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-aahelp</option></term>
  <listitem><para>
    Lista tutte le opzioni per aalib.
  </para></listitem>
</varlistentry>
</variablelist>

<note><para>
La renderizzazione è molto pesante per la CPU, specialmente usando AA-on-X
(usando aalib su X), ed è più leggera su una console standard, senza
framebuffer. Usa SVGATextMode per impostare una modalità a molti caratteri,
poi divertiti! (le schede Hercules con seconda uscita sono mitiche :))
(ma IMHO puoi usare l'opzione <option>-vf 1bpp</option> per avere grafica su
hgafb:)
</para></note>

<para>
Usa l'opzione <option>-framedrop</option> se il tuo computer non è abbastanza
veloce da renderizzare tutti i fotogrammi!
</para>

<para>
Riproducendo su un terminale, avrai migliore velocità e qualità usando il
driver Linux, non ncurses (<option>-aadriver linux</option>). Ma devi anche
avere accesso a
<filename>/dev/vcsa<replaceable>&lt;terminale&gt;</replaceable></filename>!
Questo non è rilevato automaticamente da aalib, ma vo_aa cerca di trovare la
modalità migliore. Leggi <ulink url="http://aa-project.sf.net/tune"/> per
altri consigli di impostazioni.
</para>
</sect1>

<!-- ********** -->

<sect1 id="caca">
<title>
<systemitem class="library">libcaca</systemitem> &ndash; Libreria Color ASCII Art
</title>

<para>
La libreria <ulink url="http://sam.zoy.org/projects/libcaca/"><systemitem class="library">libcaca</systemitem></ulink>
è una libreria grafica che emette testo al posto di pixel, indi può funzionare
su schede video più vecchie o su terminali di testo. Non è dissimile dalla
famosa libreria <systemitem class="library">AAlib</systemitem>.
<systemitem class="library">libcaca</systemitem> ha bisogno di un terminale per
poter funzionare, perciò dovrebbe funzionare su tutti i sistemi Unix (incluso
Mac OS X) usando la libreria <systemitem class="library">slang</systemitem>
ovvero la libreria <systemitem class="library">ncurses</systemitem>, sotto DOS
usando la libreria <systemitem class="library">conio.h</systemitem>, e nei
sistemi Windows usando <systemitem class="library">slang</systemitem> o
<systemitem class="library">ncurses</systemitem> (tramite l'emulazione Cygwin)
oppure <systemitem class="library">conio.h</systemitem>. Se
<filename>./configure</filename> rileva la presenza di
<systemitem class="library">libcaca</systemitem>, il driver di uscita video per
caca verrà compilato.
</para>

<itemizedlist>
<title>Le differenze rispetto ad <systemitem class="library">AAlib</systemitem>
  sono le seguenti:</title>
<listitem><para>
   16 colori disponibili per l'emissione a caratteri (256 coppie di colori)
</para></listitem>
<listitem><para>
   dithering del colore dell'immagine
</para></listitem>
</itemizedlist>

<itemizedlist>
<title>Ma <systemitem class="library">libcaca</systemitem> ha anche le seguenti
  limitazioni:</title>
<listitem><para>
   nessun supporto per luminosià, contrasto, gamma
</para></listitem>
</itemizedlist>

<para>
Puoi utilizzare alcuni tasti nella finestra caca per modificare le opzioni di
renderizzazione:
</para>

<informaltable>
<tgroup cols="2">
<thead>
  <row><entry>Chiave</entry><entry>Azione</entry></row>
</thead>
<tbody>
<row><entry><keycap>d</keycap></entry><entry>
  Attiva/disattiva il metodo di dithering di
  <systemitem class="library">libcaca</systemitem>.
</entry></row>
<row><entry><keycap>a</keycap></entry><entry>
  Attiva/disattiva l'antialias di
  <systemitem class="library">libcaca</systemitem>.
</entry></row>
<row><entry><keycap>b</keycap></entry><entry>
  Attiva/disattiva lo sfondo di
  <systemitem class="library">libcaca</systemitem>.
</entry></row>
</tbody>
</tgroup>
</informaltable>

<variablelist>
<title><systemitem class="library">libcaca</systemitem> terrà anche conto di
  alcune variabili d'ambiente:</title>
<varlistentry>
  <term><option>CACA_DRIVER</option></term>
  <listitem><para>
    Imposta il driver caca richiesto. Per es. ncurses, slang, x11.
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>CACA_GEOMETRY (solo X11)</option></term>
  <listitem><para>
    Specifica il numero di righe e colonne. Per es. 128x50.
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>CACA_FONT (solo X11)</option></term>
  <listitem><para>
    Specifica il font da usare. Per es. fixed, nexus.
  </para></listitem>
</varlistentry>
</variablelist>

<para>
Usa l'opzione <option>-framedrop</option> se il tuo computer non è abbastanza
veloce per renderizzare tutti i fotogrammi.
</para>

</sect1>

<!-- ********** -->

<sect1 id="vesa">
<title>VESA - uscita attraverso il VESA BIOS</title>

<para>
Questo driver è stato progettato ed introdotto come un
<emphasis role="bold">driver generico</emphasis> per qualsiasi scheda video che
abbia un BIOS compatibile con VESA VBE 2.0. Un altro vantaggio di questo driver
è che cerca di attivare l'uscita TV.
La <citetitle>VESA BIOS EXTENSION (VBE) Versione 3.0 Data: 16 settembre
1998</citetitle> (pagina 70) dice:
</para>

<!-- TODO: try to find an 'official' translation -->
<blockquote>
<formalpara><title>Dual-Controller Designs</title>
<para>
VBE 3.0 supports the dual-controller design by assuming that since both
controllers are typically provided by the same OEM, under control of a
single BIOS ROM on the same graphics card, it is possible to hide the fact
that two controllers are indeed present from the application. This has the
limitation of preventing simultaneous use of the independent controllers,
but allows applications released before VBE 3.0 to operate normally. The
VBE Function 00h (Return Controller Information) returns the combined
information of both controllers, including the combined list of available
modes. When the application selects a mode, the appropriate controller is
activated. Each of the remaining VBE functions then operates on the active
controller.
</para>
</formalpara>
</blockquote>

<para>
Perciò usando questo driver hai qualche possibilità di far funzionare
l'uscita TV (si presume che spesso l'uscita TV sia almeno un'uscita a sè
stante).
</para>

<itemizedlist spacing="compact">
<title>VANTAGGI</title>
<listitem><para>
  Puoi riuscire a guardare film <emphasis role="bold">anche se Linux non
  riconosce</emphasis> il tuo hardware grafico.
</para></listitem>
<listitem><para>
  Non ti serve avere alcuna cosa relativa alla grafica (come X11 (AKA XFree86),
  fbdev e così via) sul tuo Linux. Questo driver può venir utilizzato dalla
  <emphasis role="bold">modalità testo</emphasis>.
</para></listitem>
<listitem><para>
  Hai qualche possibilità di avere l'<emphasis role="bold">uscita TV
  funzionante</emphasis> (per le schede ATI perlomeno è così).
</para></listitem>
<listitem><para>
  Questo driver chiama la funzione <function>int 10h</function> percui non è
  un emulatore - fa riferimento a cose <emphasis role="bold">reali</emphasis>
  del BIOS <emphasis role="bold">reale</emphasis> in 
  <emphasis>modalità reale</emphasis> (attualmente in modalità vm86).
</para></listitem>
<listitem><para>
  Con esso puoi usare VIDIX, potendo ottenere contemporaneamente un'uscita
  video accelerata <emphasis role="bold">e</emphasis> e l'uscita TV!
  (consigliato per schede ATI)
  </para></listitem>
<listitem><para>
  Se hai VESA VBE 3.0+ e hai specificato in qualche dove
  <option>monitor-hfreq, monitor-vfreq, monitor-dotclock</option> (nel file di
  configurazione o dalla riga comando) otterrai la massima frequenza di
  aggiornamento possibile (usando formule generiche di temporizzazione).
  Per abilitare questa funzionalità devi specificare
  <emphasis role="bold">tutte</emphasis> le opzioni per il tuo monitor.
</para></listitem>
</itemizedlist>

<itemizedlist spacing="compact">
<title>SVANTAGGI</title>
<listitem><para>
   Funziona solo su <emphasis role="bold">sistemi x86</emphasis>.
</para></listitem>
<listitem><para>
  Può essere usato solo da <systemitem class="username">root</systemitem>.
</para></listitem>
<listitem><para>
  Attualmente è disponibile solo per <emphasis role="bold">Linux</emphasis>.
</para></listitem>
</itemizedlist>

<important><para>
Non usare questo driver con <emphasis role="bold">GCC 2.96</emphasis>!
Non funzionerà!
</para></important>

<variablelist>
<title>OPZIONI DELLA RIGA COMANDO DISPONIBILI PER VESA</title>
<varlistentry>
  <term><option>-vo vesa:<replaceable>opzioni</replaceable></option></term>
  <listitem><para>
    attualmente riconosciute: <literal>dga</literal> per forzare la modalità
    dga e <literal>nodga</literal> per disabilitarla. In modalità dga puoi
    abilitare il doppio buffering con l'opzione <option>-double</option>.
    Nota: puoi omettere questi parametri per abilitare
    l'<emphasis role="bold">auto-rilevazione</emphasis> della modalità dga.
  </para></listitem>
</varlistentry>
</variablelist>

<itemizedlist spacing="compact">
<title>PROBLEMI CONOSCIUTI E SOLUZIONI</title>
<listitem><para>
  Se hai dei font <emphasis role="bold">NLS</emphasis> installati sulla tua
  macchina Linux ed utilizzi il driver VESA in modalità testo, allora dopo
  essere uscito da<application>MPlayer</application> avrai i
  <emphasis role="bold">font ROM</emphasis> caricati al posto di quelli locali.
  Puoi ricaricare i font locali usando lo strumento
  <command>setsysfont</command> per Mandrake/Mandriva, ad esempio
  (<emphasis role="bold">consiglio</emphasis>: lo stesso strumento viene
  usato per la localizzazione di fbdev).
</para></listitem>
<listitem><para>
  Alcuni <emphasis role="bold">driver grafici per Linux</emphasis> non
  modificano nella memoria DOS la
  <emphasis role="bold">modalità BIOS</emphasis> attiva.
  Per cui se hai questo problema - usa sempre il driver VESA dalla
  <emphasis role="bold">modalità testo</emphasis>. Altrimenti verrà
  comunque attivata la modalità testo (#03) e dovrai riavviare il tuo
  computer.
</para></listitem>
<listitem><para>
  Spesso dopo aver dismesso il driver VESA ottieni uno schermo
  <emphasis role="bold">nero</emphasis>. Per riportare il tuo schermo allo
  stato originario - salta semplicemente ad unìaltra console (premendo
  <keycombo><keycap>Alt</keycap><keycap>F&lt;x&gt;</keycap></keycombo>) poi
  ritorna alla console precedente allo stesso modo.
</para></listitem>
<listitem><para>
  Per avere <emphasis role="bold">l'uscita TV funzionante</emphasis> devi avere
  il connettore TV collegato prima di avviare il tuo PC, visto che il BIOS
  video si inizializza solo una volta durante il passaggio POST.
</para></listitem>
</itemizedlist>
</sect1>

<!-- ********** -->

<sect1 id="x11">
<title>X11</title>

<para>
Da evitare se possibile. Uscita su X11 (utilizza l'estensione della memoria
condivisa), senza alcuna accelerazione hardware. Gestisce il ridimensionamento
software (accelerato MMX/3DNow/SSE, ma sempre lento), usa le opzioni
<option>-fs -zoom</option>. La maggior parte delle schede gestisce un
ridimensionamento hardware, usa per queste l'uscita <option>-vo xv</option>,
oppure <option>-vo xmga</option> per le schede Matrox.
</para>

<para>
Il problema è che i driver di molte schede non supportano l'accelerazione
hardware sulla seconda uscita o TV. In quei casi, vedi delle finestre blu/verdi
al posto del film. In questi casi torna utile questo driver, ma ti serve una
CPU potente per effettuare il ridimensionamento software. Non usare il driver
di uscita SDL + ridimensionamento software, ha una peggior qualità
dell'immagine.
</para>

<para>
Il ridimensionamento software è molto lento, ti conviene piuttosto cambiare la
modalità video. E' molto facile. Guarda le
<link linkend="dga-modelines">modeline della sezione DGA</link>, e inseriscile
nel tuo <filename>XF86Config</filename>.

<itemizedlist spacing="compact">
<listitem><para>
  Se hai XFree86 4.x.x: usa l'opzione <option>-vm</option>. Passerà alla
  risoluzione che meglio si adatta al tuo film. Se non lo fa:
</para></listitem>
<listitem><para>
  With XFree86 3.x.x: you have to cycle through available resolutions
  Con XFree86 3.x.x: devi passare attraverso le risoluzioni disponibili con i
  tasti
  <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap><keycap>Keypad +</keycap></keycombo>
  e
  <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap><keycap>Keypad -</keycap></keycombo>.
</para></listitem>
</itemizedlist>
</para>

<para>
Se non trovi le modalità che hai aggiunto, controlla l'emissione di XFree86.
Alcuni driver non possono usare dei pixelclock che servono per modalità a
bassa risoluzione.
</para>
</sect1>

<!-- ********** -->

<sect1 id="vidix">
<title>VIDIX</title>

<formalpara><title>PREAMBOLO</title>
<para>
<acronym>VIDIX</acronym> è un nome breve che sta per 
<emphasis role="bold">VID</emphasis>eo
<emphasis role="bold">I</emphasis>nterface
per *ni<emphasis role="bold">X</emphasis>.
VIDIX è stato progettato ed introdotto com un'interfaccia per driver veloci
nello spazio utente, fornendo delle prestazioni video come quelle che fornisce
mga_vid per le schede Matrox. E' anche molto portabile.
</para>
</formalpara>

<para>
Quest'interfaccia è stata progettata come un tentativo di riunire le
interfacce di accelerazione video già esistenti (conosciute come mga_vid,
rage128_vid, radeon_vid, pm3_vid) in uno schema fissato. Fornisce un'interfaccia
di alto livello a chip conosciuti come BES (BackEnd scalers) o OV (Video
Overlays). Non fornisce un'interfaccia a basso livello a cose conosciute come
server grafici (non voglio entrare in competizione con il gruppo di X11 per le
modifiche alla modalità grafica). Per es. l'obiettivo principale di
quest'intarfaccia è quello di velocizzare la riproduzione video.
</para>

<itemizedlist spacing="compact">
<title>USO</title>
<listitem><para>
  Puoi usare un driver di uscita video a sé stante: <option>-vo xvidix</option>.
  Questo driver è stato sviluppato come un front-end tra X11 e la tecnologia
  VIDIX. Richiede l'X server e può funzionare solo dentro all'X server stesso.
  Nota che, visto che accede direttamente all'hardware e oltrepassa il driver X,
  le immagini memorizzate nella memoria della scheda video possono venir
  corrotte. Puoi evitarlo limitando la dimensione della memoria video usata da
  X con l'opzine "VideoRam" nella sezione device di XF86Config. Dovresti
  impostare tale opzione alla quantità di memoria della tua scheda meno 4MB.
  Se hai meno di 8MB di ram video, puoi usare invece l'opzione
  "XaaNoPixmapCache" nella sezione screen.
</para></listitem>
<listitem>
  <para>
  C'è poi un driver VIDIX per la console: <option>-vo cvidix</option>.
  Questo richiede per la maggior parte delle schede un framebuffer
  inizializzato e funzionante  (altrimenti incasinerai solamente lo schermo), e
  otterrai un effetto simile a <option>-vo mga</option> o
  <option>-vo fbdev</option>. Le schede nVidia tuttavia sono in grado di
  emettere video completamente grafico su vere console di testo. Vedi la sezione
  <link linkend="vidix-nvidia">nvidia_vid</link> per ulteriori informazioni.
  Per evitare il testo sui bordi e il cursore lampeggiante, prova qualcosa tipo
  </para>

  <screen>setterm -cursor off > /dev/tty9</screen>

  <para>
  (presumendo che <systemitem>tty9</systemitem> non venga utilizzata) e poi
  passa a <systemitem>tty9</systemitem>.
  D'altro canto, <option>-colorkey 0</option> dovrebbe mostrarti il video sullo
  "sfondo", anche se questo dipende dal fatto che colorkey funzioni bene o no.
  </para>
</listitem>
<listitem><para>
  Puoi usare un sotto-dispositivo VIDIX che sia stato applicato a vari driver
  di uscita video, così: <option>-vo vesa:vidix</option>
  (<emphasis role="bold">solo per Linux</emphasis>) e
  <option>-vo fbdev:vidix</option>.
</para></listitem>
</itemizedlist>

<para>
In verità non conta quale driver di uscita video venga usato con
<emphasis role="bold">VIDIX</emphasis>.
</para>

<itemizedlist spacing="compact">
<title>PREREQUISITI</title>
<listitem><para>
  La scheda video dovrebbe essere in modalità grafica (tranne le schede nVidia
  con il driver di uscita <option>-vo cvidix</option>).
</para></listitem>
<listitem><para>
  Il driver di uscita video di <application>MPlayer</application> dovrebbe
  conoscere la modalità video attiva ed essere in grado di fornire al
  sotto-dispositivo VIDIX alcune caratteristiche video del server.
</para></listitem>
</itemizedlist>

<formalpara><title>MODI DI UTILIZZO</title>
<para>
Quando VIDIX viene usato come un
<emphasis role="bold">sotto-dispositivo</emphasis> (<option>-vo
vesa:vidix</option>) allora la configurazione della modalità video viene
eseguita dal dispositivo di uscita video
(<emphasis role="bold">vo_server</emphasis>, in breve). Perciò puoi passare
sulla riga comando di <application>MPlayer</application> le stesse chiavi per
vo_server. Inoltre accetta <option>-double</option> come un parametro globale
(si consiglia di usare questa opzione con VIDIX almeno per le schede ATI).
Come <option>-vo xvidix</option>, attualmente riconosce le seguenti opzioni:
<option>-fs -zoom -x -y -double</option>.
</para>
</formalpara>

<para>
Poi puoi specificare il driver VIDIX direttamente sulla riga comando come una
terza sotto-opzione:
<screen>
mplayer -vo xvidix:mga_vid.so -fs -zoom -double <replaceable>file.avi</replaceable>
</screen>
o
<screen>
mplayer -vo vesa:vidix:radeon_vid.so -fs -zoom -double -bpp 32 <replaceable>file.avi</replaceable>
</screen>
ma è pericoloso e non dovresti farlo. In questo caso il driver indicato verrà
forzato e i risultati sono imprevedibili (potrebbe mandarti il computer in
<emphasis role="bold">freeze</emphasis>). Dovresti farlo SOLO se sei
assolutamente sicuro che funzionerà e <application>MPlayer</application> non
lo farà automaticamente. Per favore dillo agli sviluppatori. Il modo corretto
è utilizzare VIDIX senza argomenti per abilitare la rilevazione automatica del
driver.
</para>


<sect2 id="svgalib_helper">
<title>svgalib_helper</title>

<para>
Visto che VIDIX richiede un accesso diretto all'hardware puoi sia eseguirlo come
root, sia impostare il bit SUID sull'eseguibile di
<application>MPlayer</application>.
(<emphasis role="bold">Attenzione: questo è un rischio di sicurezza!</emphasis>)
Alternativamente puoi usare uno modulo del kernel speciale, come questo:
</para>

<procedure>
<step><para>
  Scarica la <ulink url="http://www.arava.co.il/matan/svgalib/">versione di
  sviluppo</ulink> di svgalib (1.9.x).
</para></step>
<step><para>
  Compila il modulo nella directory
  <filename class="directory">svgalib_helper</filename> (si trova dentro la
  directory <filename class="directory">svgalib-1.9.17/kernel/</filename> se hai
  scaricato i sorgenti dal sito di svgalib) e caricalo nel kernel.
</para></step>
<step><para>
  Per creare i dispositivi necessari nella directory
  <filename class="directory">/dev</filename>, esegui, da utente root,
  <screen>make device</screen> nella directory
  <filename class="directory">svgalib_helper</filename>.
</para></step>
<step><para>
  Poi esegui di nuovo <filename>configure</filename> passando i parametri
  <option>--enable-svgalib_helper</option> e
  <option>--with-extraincdir=<replaceable>/percorso/dei/sorgenti/di/svgalib_helper</replaceable>kernel/svgalib_helper</option>,
  dove <replaceable>/percorso/dei/sorgenti/di/svgalib_helper</replaceable> deve
  puntare al percorso dove hai estratto i sorgenti di svgalib_helper.
</para></step>
<step><para>
  Ricompila.
</para></step>
</procedure>
</sect2>


<sect2 id="vidix-ati">
<title>Schede ATI</title>

<para>
Attualmente la maggior parte delle schede ATI è supportata nativamente, dalle
Mach64 alle più recenti Radeon.
</para>

<para>
Ci sono due binari compilati: <filename>radeon_vid</filename> per le Radeon e
<filename>rage128_vid</filename> per le schede Rage 128. Puoi forzare
l'utilizzo di uno dei due, oppure lasciare che il sistema VIDIX provi tutti i
driver disponibili.
</para>
</sect2>


<sect2 id="vidix-mga">
<title>Schede Matrox</title>

<para>
Le Matrox G200, G400, G450 and G550 sono state riportate come funzionanti.
</para>

<para>
Il driver supporta gli equalizzatori video e dovrebbe essere veloce quasi quanto
il <link linkend="mga_vid">framebuffer Matrox</link>.
</para>
</sect2>


<sect2 id="vidix-trident">
<title>Schede Trident</title>

<para>
C'è un driver disponibile per il chipset Trident Cyberblade/i1, che si può
trovare sulle schede madri VIA Epia.
</para>

<para>
Il driver è scritto e mantenuto da
<ulink url="http://www.blackfiveservices.co.uk/EPIAVidix.shtml">Alastair M. Robinson</ulink>.
</para>
</sect2>


<sect2 id="vidix-3dlabs">
<title>Schede 3DLabs</title>

<para>
Anche se esiste un driver per i chip 3DLabs GLINT R3 e Permedia3, nessuno lo ha
provato, perciò delle informazioni sono benvenute.
</para>
</sect2>


<sect2 id="vidix-nvidia">
<title>Schede nVidia</title>

<para>
Una caratteristica unica del driver nvidia_vid è la sua abilità nel mostrare
video su di una
<emphasis role="bold">semplice, pura, console di testo</emphasis> - senza alcun
framebuffer o qualche magia di X. Per questo fine, dovremo usare il driver di
uscita video <option>cvidix</option>, come mostrato nell'esempio che segue:
<screen>mplayer -vo cvidix <replaceable>esempio.avi</replaceable></screen>
</para>
</sect2>


<sect2 id="vidix-sis">
<title>Schede SiS</title>

<para>
Questo codice è davvero sperimentale, proprio come nvidia_vid.
</para>

<para>
E' stato testato su SiS 650/651/740 (i chipset più diffusi usati nelle versioni
SiS dello "Shuttle XPC").
</para>

<para>
Si attendono resoconti!
</para>
</sect2>
</sect1>

<!-- ********** -->

<sect1 id="directfb">
<title>DirectFB</title>

<blockquote><para>
"DirectFB is a graphics library which was designed with embedded systems
in mind. It offers maximum hardware accelerated performance at a minimum
of resource usage and overhead." - citazione da
<ulink url="http://www.directfb.org"/>
</para></blockquote>

<para>Ometterò le caratteristiche di DirectFB da questa sezione.</para>

<para>
Anche se <application>MPlayer</application> non è supportato come un "provider
video" in DirectFB, questo driver di uscita video abiliterà la riproduzione
video tramite DirectFB. Sarà - ovviamente - accelerata, la velocità di
DirectFB sulla mia Matrox G400 è la stessa di XVideo.
</para>

<para>
Cerca sempre di utilizzare la versione più recente di DirectFB. Sulla riga
comando puoi usare le opzioni di DirectFB, usando <option>-dfbopts</option>.
La scelta del livello può essere fatta con il metodo del sotto-dispositivo,
per es.:
<option>-vo directfb:2</option> (il livello -1 è il default: autorilevazione)
</para>
</sect1>

<!-- ********** -->

<sect1 id="dfbmga">
<title>DirectFB/Matrox (dfbmga)</title>

<para>
Leggi per favore la sezione <link linkend="directfb">principale di DirectFB</link>
per le informazioni generali.
</para>

<para>
Questo driver di uscita video abiliterà il CRTC2 (sulla seconda uscita) delle
schede Matrox G400/G450/G550, mostrando il video
<emphasis role="bold">independentemente</emphasis> rispetto alla prima uscita.
</para>

<para>
Ville Syrjala's ha un
<ulink url="http://www.sci.fi/~syrjala/directfb/Matrox_TV-out_README.txt">README</ulink>
e un
<ulink url="http://www.sci.fi/~syrjala/directfb/matrox-tv-out-howto">HOWTO</ulink>
sul suo sito, che spiegano come far funzionare l'uscita TV DirectFB sulle schede
Matrox.
</para>

<note><para>
La prima versione di DirectFB con cui siamo riusciti a farlo funzionare è la
0.9.17 (ha problemi, gli serve la patch <systemitem>surfacemanager</systemitem>
dal sito suddetto). Portare il codice per CRTC2 in
<link linkend="mga_vid">mga_vid</link> è in progetto da anni,
sono benvenute delle <ulink url="../../tech/patches.txt">patch</ulink>.
</para></note>
</sect1>


<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->


<sect1 id="mpeg_decoders">
<title>Decodificatori MPEG</title>

<sect2 id="dvb">
<title>Uscita e ingresso DVB</title>

<para>
<application>MPlayer</application> supporta le schede con chipset DVB Siemens
di produttori come Siemens, Technotrend, Galaxis o Hauppauge. I driver DVB più
recenti sono disponibili sul
<ulink url="http://www.linuxtv.org">sito di Linux TV</ulink>.
Se vuoi eseguire la transcodifica software dovresti avere almeno una CPU a 1GHz.
</para>

<para>
Configure dovrebbe rilevare la tua scheda DVB. Se non lo fa, forzalo con
<screen>./configure --enable-dvb</screen>
Se hai gli header ost in un percorso non standard, imposta il percorso con
<screen>
./configure --with-extraincdir=<replaceable>directory sorgenti DVB</replaceable>/ost/include
</screen>
Poi compila ed installa come al solito.</para>

<formalpara><title>USO</title>
<para>
La decodifica hardware di flussi contententi video MPEG-1/2 e/o audio MPEG puà
essere effettuata con questo comando:
<screen>
mplayer -ao mpegpes -vo mpegpes <replaceable>file.mpg|vob</replaceable>
</screen>
</para>
</formalpara>

<para>
La decodfica di qualsiasi altro tipo di flusso video richiede la transcodifica
in MPEG-1, indi è lenta a potrebbe non valerne la pena, specialmente se il tuo
computer è lento.
Si puà ottenere usando un comando come questo:
<screen>
mplayer -ao mpegpes -vo mpegpes <replaceable>tuofile.ext</replaceable>
mplayer -ao mpegpes -vo mpegpes -vf expand <replaceable>tuofile.ext</replaceable>
</screen></para>

<para>
Fai attenzione che le schede DVB supportano solo le altezze 288 e 576 per PAL
oppure 240 e 480 per NTSC. <emphasis role="bold">Devi</emphasis> ridimensionare
le altre altezze aggiungendo <option>scale=larghezza:altezza</option>, con la
larghezza e l'altezza volute, all'opzione <option>-vf</option>. Le schede DVB
accettano diverse larghezze, come 720, 704, 640, 512, 480, 352 etc. ed
effettuano il ridimensionamento hardware sulla direzione orizzontale, perciò
nella maggior parte deiu casi non ti serve ridimensionare in orizzontale.
Per un MPEG-4 (DivX) a 512x384 (aspetto 4:3), prova:
<screen>mplayer -ao mpegpes -vo mpegpes -vf scale=512:576</screen>
</para>

<para>
Se hai un film in widescreen e non vuoi ridimensionarlo ad altezza piena,
puoi usare il filtro <option>expand=w:h</option> per aggiungere delle bande
nere. Per guardare un MPEG-4 (DivX) a 640x384, prova:
<screen>
mplayer -ao mpegpes -vo mpegpes -vf expand=640:576 <replaceable>file.avi</replaceable>
</screen>
</para>

<para>
Se la tua CPU è troppo lenta per un MPEG-4 (DivX) intero a 720x576, prova a
rimpicciolirlo:
<screen>
mplayer -ao mpegpes -vo mpegpes -vf scale=352:576 <replaceable>file.avi</replaceable>
</screen>
</para>

<para>
Se la velocità non migliora, prova a rimpicciolirlo anche in verticale:
<screen>
mplayer -ao mpegpes -vo mpegpes -vf scale=352:288 <replaceable>file.avi</replaceable>
</screen>
</para>

<para>
Per l'OSD e i sottotitoli usa la caratteristica OSD del filtro expand. Quindi,
al posto di <option>expand=w:h</option> o <option>expand=w:h:x:y</option>, usa
<option>expand=w:h:x:y:1</option> (il quinto parametro <option>:1</option> alla
fine abiliterà il rendering dell'OSD). Potresti voler spostare leggermente
verso l'alto l'immagine per ottenere una banda nera più ampia per i
sottotitoli. Potresti anche voler spostare più in alto i sottotitoli, se sono
al di fuori dello schermo della tua TV, usa l'opzione
<option>-subpos &lt;0-100&gt;</option> (<option>-subpos 80</option> è una
buona scelta).
</para>

<para>
Per poter riprodurre un film non a 25fps su una TV PAL ovvero con una CPU
lenta, aggiungi l'opzione <option>-framedrop</option>.
</para>

<para>
Per mantenere il rapporto di aspetto dei file MPEG-4 (DivX) e ottenere i
parametri ottimali per il ridimensionamento (ridimensionamento orizzontale
hardware e verticale software mantenendo il giusto rapporto di aspetto), usa il
nuovo filtro dvbscale:
<screen>
per una TV a  4:3: -vf dvbscale,scale=-1:0,expand=-1:576:-1:-1:1
per una TV a 16:9: -vf dvbscale=1024,scale=-1:0,expand=-1:576:-1:-1:1
</screen>
</para>

<formalpara><title>TV Digitale (modulo d'ingresso DVB)</title>
<para>Puoi usare la tua scheda TV per guardare la TV Digitale.</para>
</formalpara>

<para>
Dovresti avere installati i programmi <command>scan</command> e
<command>szap/tzap/czap/azap</command>; essi sono inclusi nel pacchetto dei
driver.
</para>

<para>
Verifica che i tuoi driver funzionino correttamente attraverso un programma tipo
<ulink url="http://sf.net/projects/dvbtools/"><command>dvbstream</command></ulink>
(che è la base del modulo d'ingresso DVB).
</para>

<para>
Ora dovresti riempire un file <filename>~/.mplayer/channels.conf</filename>,
con la sintassi accettata da <command>szap/tzap/czap/azap</command>, o fare in
modo che <command>scan</command> lo riempia per te.
</para>

<para>
Se hai più di un tipo di scheda (per es. Satellitare, Terrestre, Via Cavo e
ATSC) puoi salvare i tuoi file dei canali come
<filename>~/.mplayer/channels.conf.sat</filename>,
<filename>~/.mplayer/channels.conf.ter</filename>,
<filename>~/.mplayer/channels.conf.cbl</filename>,
e <filename>~/.mplayer/channels.conf.atsc</filename>,
rispettivamente, per spingere implicitamente <application>MPlayer</application>
ad usare questi file invece che <filename>~/.mplayer/channels.conf</filename>,
e devi solamente specificare quale scheda usare.
</para>

<para>
Assicurati di avere <emphasis>solo</emphasis> canali in chiaro nel tuo file
<filename>channels.conf</filename>, altrimenti
<application>MPlayer</application> resterà in attesa di una trasmissione non
criptata.
</para>

<para>
Nei tuoi campi audio e video puoi usare una sintassi espansa:
<option>...:pid[+pid]:...</option> (fino ad un massimo di 6 pid ciascuno);
in questo caso <application>MPlayer</application> includerà nel flusso tutti
i pid indicati, oltre al pid 0 (che contiene il PAT).
Si consiglia di includere in ogni riga i pid PMT e PCR per il canale
corrispondente (se conosciuti).
Puoi anche specificare 8192, che seleziona tutti i pid su quella frequenza e
puoi anche passare con TAB attraverso i programmi.
Potrebbe aver bisogno di più banda, anche se le schede economiche passano
sempre tutti canali al kernel, per cui non fa molta differenza per queste.
Altri utilizzi possibili sono: pid televideo, seconda traccia audio, etc...
</para>

<para>
Se <application>MPlayer</application> si lamenta frequentemente di
<screen>Troppi pacchetti video/audio nel buffer</screen> oppure noti una
desincronizzazione crescente tra l'audio e il video, verifica la presenza del
pid PCR nel tuo flusso (serve per adeguarsi alla modalità di buffering del
trasmettitore) e/o prova ad usare il demuxer MPEG-TS di libavformat aggiungendo 
<option>-demuxer lavf -lavfdopts probesize=128</option> alla tua riga comando.
</para>

<para>
Per vedere il primo dei canali presenti nella tua lista, esegui
<screen>mplayer dvb://</screen>
</para>

<para>
Se vuoi guardare un canale in particolare, come R1, esegui
<screen>mplayer dvb://<replaceable>R1</replaceable></screen>
</para>

<para>
Se hai più di una scheda puoi anche dover specificare il numero della scheda
dove il canale si vede (per es. 2) con la sintassi:
<screen>mplayer dvb://<replaceable>2@R1</replaceable></screen>
</para>

<para>
Per cambiare canale premi i tasti <keycap>h</keycap> (successivo) e
<keycap>k</keycap> (precedente), oppure usa il
<link linkend="osdmenu">menu OSD</link>.
</para>

<para>
Per disabilitare temporaneamente il flusso video o audio, copia quello che
segue in <filename>~/.mplayer/input.conf</filename>:
<screen>
% set_property  switch_video -2
&amp; step_property switch_video
? set_property  switch_audio -2
^ step_property switch_audio
</screen>
(Reimpostando i comandi da tastiera come si preferisce.) Premendo il tasto
corrispondente a switch_x -2, il flusso relativo verrà chiuso;
premendo il tasto corrispondente a step_x il flusso verrà riaperto.
Nota che quando ci sono più flussi audio e video nel multiplex questo
meccanismo non funzionerà nel modo che ci si aspetta.
</para>

<para>
Durante la riproduzione (non durante la registrazione), per evitare
saltellamenti e messaggi di errore tipo 'Il tuo sistema è troppo LENTO',
si consiglia di aggiungere
<screen>
-mc 10 -speed 0.97 -af scaletempo
</screen>
alla riga comando, impostando i parametri di scaletempo come si preferisce.
</para>

<para>
Se il tuo <filename>~/.mplayer/menu.conf</filename> contiene una voce
<literal>&lt;dvbsel&gt;</literal>, come quella nel file di esempio
<filename>etc/dvb-menu.conf</filename> (che puoi usare per sovrascrivere
<filename>~/.mplayer/menu.conf</filename>), il menu principale mostrerà una
voce di sotto-menu che ti lascerà scegliere uno dei canali presenti nel tuo
<filename>channels.conf</filename>, possibilmente preceduto da un menu con la
lista delle schede disponibili, se ve ne è più di una utilizzabile da
<application>MPlayer</application>.
</para>

<para>
Se vuoi salvare su disco un programma puoi usare
<screen>
mplayer -dumpfile <replaceable>r1.ts</replaceable> -dumpstream dvb://<replaceable>R1</replaceable>
</screen>
</para>

<para>
Se vuoi registrarlo in un formato diverso (ri-codificandolo) puoi invece
lanciare un comando come
<screen>
mencoder -o <replaceable>r1.avi</replaceable> -ovc xvid -xvidencopts bitrate=800 \
    -oac mp3lame -lameopts cbr:br=128 -pp=ci dvb://<replaceable>R1</replaceable>
</screen>
</para>

<para>
Leggi la pagina man per una lista di opzioni che puoi passare al modulo di
ingresso DVB.
</para>

<formalpara><title>FUTURO</title>
<para>
Se hai domande o vuoi ricevere gli annunci di nuove caratteristiche e vuoi
partecipare a discussioni su questo argomento, iscriviti alla nostra mailing
list
<ulink url="http://lists.mplayerhq.hu/mailman/listinfo/mplayer-dvb">MPlayer-DVB</ulink>.
Per favore tieni presente che la lingua della lista è l'inglese.
</para>
</formalpara>

<para>
In futuro puoi aspettarti la possibilità di mostrare OSD e sottotitoli usando
la caratteristica nativa delle schede DVB, così come una riproduzione più
fluida di film non a 25fps e transcodifica in tempo reale tra MPEG-2 e MPEG-4
(decompressione parziale).
</para>
</sect2>

<!-- ********** -->

<sect2 id="dxr2">
<title>DXR2</title>

<para>
<application>MPlayer</application> fornisce una riproduzione accelerata
hardware con la scheda Creative DXR2.
</para>
  
<para>
Prima di tutto ti serviranno dei driver DXR2 correttamente installati. Puoi
trovare i driver e le istruzioni per l'installazione sul sito
<ulink url="http://dxr2.sf.net/">DXR2 Resource Center</ulink>.
</para>

<variablelist><title>USO</title>
<varlistentry>
  <term><option>-vo dxr2</option></term>
  <listitem><para>Abilita l'uscita TV.</para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-vo dxr2:x11</option> or <option>-vo dxr2:xv</option></term>
  <listitem><para>Abilita in X11 l'uscita su Overlay.</para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-dxr2 &lt;option1:option2:...&gt;</option></term>
  <listitem><para>
  Questa opzione viene usata per controllare il driver DXR2.
  </para></listitem>
</varlistentry>
</variablelist>

<para>
Il chipset di overlay usato sulla DXR2 ha una qualità piuttosto bassa, ma le
impostazioni di default dovrebbero funzionare per chiunque. L'OSD potrebbe
essre utilizzabile con l'overlay (non sulla TV) disegnandolo nella chiave
colore. Con le impostazioni di default della chiave colore puoi ottenere
risultati variabili, spesso vedrai la chiave colore attorno ai caratteri o
qualche altro effetto strambo. Ma se imposti correttamente le opzioni della
chiave colore dovresti ricavare dei risultati accettabili.
</para>

<para>Per favore vedi nella pagina man le opzioni disponibili.</para>
</sect2>

<!-- ********** -->

<sect2 id="dxr3">
<title>DXR3/Hollywood+</title>

<para>
<application>MPlayer</application> fornisce una riproduzione accelerata con le
schede Creative DXR3 e Sigma Designs Hollywood Plus. Queste schede usano
entrambe il chip em8300 di decodifica MPEG di Sigma Designs.
</para>

<para>
Prima di tutto ti serviranno dei driver DXR3/H+ correttamente installati,
versione 0.12.0 o successiva. Puoi trovare i driver e le istruzioni per
l'installazione sul sito
<ulink url="http://dxr3.sf.net/">DXR3 &amp; Hollywood Plus per Linux</ulink>.
<filename>configure</filename> dovrebbe rilevare automaticamente la tua scheda,
la compilazione dovrebbe concludersi senza problemi.
</para>

<!-- FIXME: find a more clear presentation -->
<variablelist>
<title>USO</title>
<varlistentry>
<term><option>-vo dxr3:prebuf:sync:norm=x:<replaceable>dispositivo</replaceable></option></term>
<listitem><para>
<option>overlay</option> attiva l'overlay (sovrapposizione) invece che l'uscita
TV. Per funzionare richiede un'impostazione dell'overlay adeguatamente
configurata. Il modo più semplice di configurare l'overlay è eseguire prima
autocal. Poi lanciare mplayer con l'uscita dxr3 e, senza l'overlay abilitato,
eseguire dxr3view. In dxr3view puoi giocherellare con le impostazioni
dell'overlay e vederne il risultato in tempo reale, forse questa funzionalità
sarà utilizzabile in futueo dalla GUI di <application>MPlayer</application>.
Una volta che l'overlay sarà correttamente configurato, non ti servirà più
dxr3view.
<option>prebuf</option> abilita il pre-buffering. Il pre-buffering è una
funzionalità del chip em8300 che gli permette di contenere più di un
fotogramma video per volta. Questo significa che quando stai usando il
pre-buffering, <application>MPlayer</application> cercherà di mantenere il
buffer video constantemente pieno di dati.
Se sei su una macchina lenta, l'uso della CPU di
<application>MPlayer</application> sarà vicino, o pari, al 100%.
Questo è particolarmente vero se riproduci flussi MPEG puri (come DVD, SVCD e
così via), visto che <application>MPlayer</application> non dovrà
ricodificarli in MPEG riempirà il buffer molto velocemente.
Con il pre-buffering la riproduzione video è
<emphasis role="bold">molto</emphasis> meno sensibile all'utilizzo della CPU da
parte di altri programmi, non scarterà fotogrammi a meno che tale applicazione
prenda possesso della CPU per un tempo lungo.
Quando viene usato senza pre-buffering, l'em8300 è molto più sensibile al
carico della CPU, per cui si consiglia caldamente di abilitare l'opzione
<option>-framedrop</option> di <application>MPlayer</application> per evitare
un'ulteriore perdita di sincronia.
<option>sync</option> abiliterà il nuovo motore di sincronizzazione.
Questa attualmente è una caratteristica sperimentale. Con il motore di
sincronizzazione abilitato, l'orologio interno dell'em8300 verrà tenuto
constantemente sotto controllo, se inizia a spostarsi dall'orologio di
<application>MPlayer</application> verrà resettato causando lo scarto da parte
dell'em8300 di tutti i fotogrammi rimasti indietro.
<option>norm=x</option> imposterà la norma TV della scheda DXR3 senza il
bisogno di strumenti esterni come em8300setup. Norme valide sono 5 = NTSC,
4 = PAL-60, 3 = PAL. Norme speciali sono 2 (auto-impostazione usando PAL/PAL-60)
e 1 (auto-impostazione usando PAL/NTSC) poiché decidono quale norma usare
in base alla frequenza fotogrammi del filmato. norm = 0 (default) non modifica
la norma corrente.
<option><replaceable>dispositivo</replaceable></option> = numero del dipositivo da usare se hai più di una scheda em8300. Ognuna di queste opzioni può essere
tralasciata.
<option>:prebuf:sync</option> sembra funzionare molto bene riproducendo filmati
MPEG-4 (DivX). Alcune persone hanno notificato problemi usando l'opzione prebuf
riproducendo file MPEG-1/2.
Potresti voler provare dapprima l'esecuzione senza alcuna opzione, se hai
problemi di sincronizzazione, o problemi coi sottotitoli DVD, fai un tentativo
con <option>:sync</option>.
</para></listitem>
</varlistentry>

<varlistentry>
  <term><option>-ao oss:/dev/em8300_ma-<replaceable>X</replaceable></option></term>
  <listitem><para>
  Per l'uscita audio, dove <replaceable>X</replaceable> è il numero del
  dispositivo (0 per una scheda sola).
  </para></listitem>
</varlistentry>

<varlistentry>
  <term><option>-af resample=<replaceable>xxxxx</replaceable></option></term>
  <listitem><para>
  This does not work with digital audio output (<option>-ac hwac3</option>).
  L'em8300 non può riprodurre frequenze inferiori a 44100Hz. Se la frequenza
  è minore di 44100Hz imposta 44100Hz oppure 48000Hz a seconda di quale sia la
  più prossima. Per es. se il film usa 22050Hz allora usa 44100Hz come
  44100 / 2 = 22050, se è 24000Hz usa 48000Hz come 48000 / 2 = 24000 e così
  via.
  </para></listitem>
</varlistentry>

<varlistentry>
  <term><option>-vf lavc</option></term>
  <listitem><para>
  Per visualizzare contenuti non MPEG sull'em8300 (per es. MPEG-4 (DivX) o
  RealVideo) devi specificare un filtro video MPEG-1 come
  <systemitem class="library">libavcodec</systemitem> (lavc).
  Vedi la pagina man per ulteriori informazioni circa <option>-vf lavc</option>.
  Attualmente non c'è modo di impostare gli fps dell'em8300, il che significa
  che sono fissati a 30000/1001 fps.
  A causa di ciò si raccomanda caldamente di usare 
  <option>-vf lavc=<replaceable>qualità</replaceable>:25</option> soprattutto
  se stai usando il pre-buffering. Allora perché 25 e non 30000/1001?
  Bene, il fatto è che quando usi 30000/1001 l'immagine diventa un pochino
  saltellante. La ragione di ciò ci è sconosciuta.
  Se li imposti a qualcosa tra 25 e 27 l'immagine diventa stabile.
  Per adesso tutto quello che possiamo fare è accettarlo empiricamente.
  </para></listitem>
</varlistentry>

<varlistentry>
  <term><option>-vf expand=-1:-1:-1:-1:1</option></term>
  <listitem><para>
  Anche se il driver DXR3 può posizionare qualche OSD sul video MPEG-1/2/4, ha
  una qualità decisamente inferiore del tipico OSD di
  <application>MPlayer</application>, e ha anche molti problemi di
  aggiornamento. La riga comando suddetta dapprima converte il video in ingresso
  a MPEG-4 (questo è obbligatorio, scusa), poi applica un filtro expand che non
  espande nulla (-1: default), ma aggiunge all'immagine l'OSD normale
  (questo è ciò che fa l'"1" alla fine).
  </para></listitem>
</varlistentry>

<varlistentry>
  <term><option>-ac hwac3</option></term>
  <listitem><para>
  L'em8300 supporta la riproduzione audio AC-3 (in surround) attraverso l'uscita
  digitale della scheda. Vedi l'opzione <option>-ao oss</option> più sopra,
  deve essere usata per specificare l'uscita DXR3 al posto di una scheda audio.
  </para></listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1>


<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->


<sect1 id="other">
<title>Altri dispositivi di visualizzazione</title>

<sect2 id="zr">
<title>Zr</title>

<para>
Questo è un driver video (<option>-vo zr</option>) per un buon numero di schede
di cattura/riproduzione MJPEG (provato con DC10+ e Buz, e dovrebbe funzionare
per LML33, la DC10). Il driver lavora codificando il fotogramma in JPEG e poi
inviandolo alla scheda. Per la codifica JPEG viene usata, e richiesta,
<systemitem class="library">libavcodec</systemitem>.
Con la modalità speciale <emphasis>cinerama</emphasis>, puoi guardare filmati
in verà modalità widescreen a patto che tu abbia due proiettori e due
schede MJPEG. Proporzionalmente alla risoluzione e alle impostazioni della
qualità, questo driver può richiedere molta potenza di CPU, ricordati di
specificare <option>-framedrop</option> se la tua macchina è troppo lenta.
Nota: il mio AMD K6-2 350MHz è (con <option>-framedrop</option>) abbastanza
adeguato per riprodurre materiale VCD e film rimpiccioliti.
</para>

<para>
Il driver comunica col driver del kernel disponibile su
<ulink url="http://mjpeg.sf.net"/>, indi devi avere per prima cosa questo
funzionante. La presenza di una scheda MJPEG è autorilevata dallo script
<filename>configure</filename>, se la rilevazione fallisce, forzala con
<screen>./configure --enable-zr</screen>
</para>

<para>
L'uscita può essere controllata con varie opzioni, una descrizione dettagliata
delle opzioni si trova nella pagina man, una lista breve delle opzioni si può
avere eseguendo
<screen>mplayer -zrhelp</screen>
</para>

<para>
Cose come il ridimensionamento e l'OSD (on screen display) non sono gestite da
questo driver ma possono essere ottenute usado dei filtri video. Per esempio,
supponi di avere un film a una risoluzione di 512x272 e vuoi vederlo a schermo
intero con un'ampiezza di 768, 384 o 192. Per ragioni di prestazioni e di
qualità, io sceglierei di ridimensionare il film a 384x204 usando il
ridimensionatore software bilineae veloce. La riga comando diventa
<screen>
mplayer -vo zr -sws 0 -vf scale=384:204 <replaceable>filmato.avi</replaceable>
</screen>
</para>

<para>
Il ritaglio può essere eseguito dal filtro <option>crop</option> e da questo
driver di per sé. Supponi che un film sia troppo ampio per vedersi dal tuo
Buz e che tu voglia usare <option>-zrcrop</option> per ridurre l'ampiezza del
film, allora dovrai lanciare il comando seguente
<screen>
mplayer -vo zr -zrcrop 720x320+80+0 <replaceable>benhur.avi</replaceable>
</screen>
</para>

<para>
Se vuoi usare il filtro <option>crop</option>, dovresti lanciare
<screen>
mplayer -vo zr -vf crop=720:320:80:0 <replaceable>benhur.avi</replaceable>
</screen>
</para>

<para>
Ulteriori presenze di <option>-zrcrop</option> evocano la modalità
<emphasis>cinerama</emphasis>, per es. puoi distribuire il filmato su varie TV
o proiettori per creare uno schermo più grande.
Supponi di avere due proiettori. Quello di sinistra è collegato al tuo Buz su
<filename>/dev/video1</filename> e quello di destra è connesso al tuo DC10+ su
<filename>/dev/video0</filename>. Il film ha una risoluzione di 704x288.
Supponi inoltre di volere il proiettore di destra in bianco e nero e che quello
di sinistra debba avere fotogrammi JPEG con una qualità 10, allora dovrai
eseguire il comando seguente
<screen>
mplayer -vo zr -zrdev /dev/video0 -zrcrop 352x288+352+0 -zrxdoff 0 -zrbw \
    -zrcrop 352x288+0+0 -zrdev /dev/video1 -zrquality 10 \
	<replaceable>film.avi</replaceable>
</screen>
</para>

<para>
Vedi che le opzioni che ci sono prima della seconda <option>-zrcrop</option> si
applicano solo al DC10+ e che le opzioni dopo la seconda
<option>-zrcrop</option> si applicano al Buz. Il massino numero di schede MJPEG
contemporanee in <emphasis>cinerama</emphasis> è quattro, per cui puoi
costruire un muro video di 2x2.
</para>

<para>
Infine una nota importante: non avviare o fermare XawTV sul dispoitivo di
riproduzione durante la riproduzione stessa, o ti manderà in crash il
computer. Va tuttavia bene <emphasis role="bold">PRIMA</emphasis> lanciare 
XawTV, <emphasis role="bold">POI</emphasis> avviare
<application>MPlayer</application>, attendere l'uscita di
<application>MPlayer</application>, e <emphasis role="bold">DOPO</emphasis>
fermare XawTV.
</para>
</sect2>

<!-- ********** -->

<sect2 id="blinkenlights">
<title>Blinkenlights</title>

<para>
Il driver è in grado di riprodurre usando il protocollo UDP Blinkenlights. Se
non sai cosa siano
<ulink url="http://www.blinkenlights.de/">Blinkenlights</ulink> o il suo
successore  <ulink url="http://www.blinkenlights.de/arcade/">Arcade</ulink>,
scoprilo. Anche se probabilmente questo è uno degli ultimi driver video usati,
senza dubbio è il più figo che <application>MPlayer</application> abbia da
offrire. Guarda solo alcuni dei
<ulink url="http://www.blinkenlights.de/video.en.html">video documentali di
Blinkenlights</ulink>.
Sul video Arcade puoi vedere il driver di uscita video Blinkenlights in azione
alla posizione 00:07:50.
</para>
</sect2>
</sect1>


<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->


<sect1 id="tvout">
<title>Gestione uscita TV-out</title>

<sect2 id="tvout-mga-g400">
<title>Schede Matrox G400</title>

<para>
Sotto Linux hai due modi per far funzionare l'uscita TV delle G400:
</para>

<important>
<para>
Per le istruzioni per l'uscita TV-out su Matrox G450/G550, vedi per favore la
sezione successiva!
</para>
</important>

<variablelist>
<varlistentry>
  <term>XFree86</term>
  <listitem>
    <para>
    Usando il driver e il modulo HAL, disponibile dal
    <ulink url="http://www.matrox.com">sito Matrox</ulink>. Questo ti farò
    avere X sulla TV.
    </para>
    <para>
    <emphasis role="bold">Questo metodo non ti fornirà una riproduzione
    accelerate</emphasis> come sotto Windows! La seconda uscita ha solo il
    framebuffer YUV, il <emphasis>BES</emphasis> (Back End Scaler, il
    ridimensionatore sulle schede G200/G400/G450/G550) non funziona su di esso!
    Il driver per Windows in qualche modo aggira il problema, probabilmente
    usando il motore 3D per ridimensionare, e il framebuffer YUV per mostrare
    l'immagine ridimensionata. Se vuoi davvero usare X, uitlizza le opzioni
    <option>-vo x11 -fs -zoom</option>, ma sarà
    <emphasis role="bold">LENTO</emphasis>, e avrà la protezione di copia
    <emphasis role="bold">Macrovision</emphasis> abilitata (puoi "correggere"
    Macrovision usando questo
    <ulink url="http://avifile.sf.net/mgamacro.pl">script perl</ulink>).
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>Framebuffer</term>
  <listitem>
    <para>
    Usando i <emphasis role="bold">moduli matroxfb</emphasis> nei kernel 2.4.
    I kernel 2.2 non hanno in sé la funzionalità TVout, indi sono
    inutilizzabili per questo fine. Devi abilitare TUTTE le caratteristiche
    specifiche per matroxfb durante la compilazione (tranne MultiHead), e
    compilarle dentro ai <emphasis role="bold">moduli</emphasis>!
    Devi anche abilitare I2C e mettere gli strumenti
    <application>matroxset</application>, <application>fbset</application>
    e <application>con2fb</application> in un percorso eseguibile (path).
    </para>

    <procedure>
    <step><para>
      Quindi carica nel kernel i moduli <systemitem>matroxfb_Ti3026,
      matroxfb_maven, i2c-matroxfb, matroxfb_crtc2</systemitem>.
      La tua console in modalità testo entrerà in modalità framebuffer
      (senza via di ritorno!).
    </para></step>
    <step><para>
      Dopodiché imposta il monitor e la TV come ti garba usando gli strumenti
      citati sopra.
    </para></step>
    <step><para>
      Evvai. L'operazione successiva è far sparire il cursore a blocco di tty1
      (o quello che è) e disabilitare lo spegnimento dello schermo. Esegui i
      comandi seguenti:

      <screen>
echo -e '\033[?25l'
setterm -blank 0<!--
   --></screen>
      or
      <screen>
setterm -cursor off
setterm -blank 0<!--
   --></screen>

      Probabilmente vuoi mettere i suddetti in uno script e anche vuotare lo
      schermo. Per ripristinare il cursore:
      <screen>echo -e '\033[?25h'</screen> o
      <screen>setterm -cursor on</screen>
    </para></step>
    <step><para>
      Yeah kewl. Avvia la riproduzione del film con
      <screen>
mplayer -vo mga -fs -screenw 640 -screenh 512 <replaceable>nomefile</replaceable><!--
   --></screen>

      (se usi X, adesso passa alla matroxfb con per esempio
      <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap><keycap>F1</keycap></keycombo>.)
      Sostituisci <literal>640</literal> e <literal>512</literal> se imposti la
      risoluzione ad un'altra...
    </para></step>
    <step><para>
      <emphasis role="bold">Goditi la ultra-veloce ultra-accessoriata uscita TV
      Matrox (megli di Xv)!</emphasis>
    </para></step>
    </procedure>
  </listitem>
</varlistentry>
</variablelist>

<formalpara><title>Costruire un cavo per uscita TV-out Matrox</title>
<para>
Nessuno si assume alcuna responsabilità, né risponde di alcuna danno causato
da questa documentazione.
</para>
</formalpara>

<formalpara><title>Cavo per G400</title>
<para>
Il quarto pin del connettore CRTC2 è il segnale video composito. La terra sono
il sesto, settimo e ottavo pin (informazioni fornite da Balázs Rácz).
</para>
</formalpara>

<formalpara><title>Cavo per G450</title>
<para>
Il primo pin del connettore CRTC2 è il segnale video composito. La terra sono
il quinto, sesto, settimo e quindicesimo pin (5, 6, 7, 15) (informazioni
fornite da Balázs Rácz).
</para>
</formalpara>
</sect2>

<!-- ********** -->

<sect2 id="tv-out_matrox_g450">
<title>Schede Matrox G450/G550</title>

<para>
La gestione dell'uscita TV per queste schede è stata aggiunta solo
recentemente e non è ancora nel kernel ufficiale.
Attualmente il modulo <emphasis role="bold">mga_vid</emphasis> non può essere
utilizzato, per quanto ne so, perché il driver G450/G550 funziona solo in una
modalità: il primo chip CRTC (con molte più funzioni) sul primo schermo (sul
monitor), e il secondo CRTC (niente <emphasis role="bold">BES</emphasis> - per
chiarimenti su BES, vedi la sezione sopra sulla G400) sulla TV. Perciò per ora
puoi usare solo il driver di uscita <emphasis>fbdev</emphasis> di
<application>MPlayer</application>.
</para>

<para>
The first CRTC can't be routed to the second head currently. The author of the
kernel matroxfb driver - Petr Vandrovec - will maybe make support for this, by
displaying the first CRTC's output onto both of the heads at once, as currently
recommended for G400, see the section above.
</para>

<para>
La patch necessaria per il kernel e l'HOWTO dettagliato sono scaricabili da
<ulink url="http://www.bglug.ca/matrox_tvout/"/>
</para>
</sect2>

<!-- ********** -->

<sect2 id="tv-out_matrox_cable">
<title>Costruire un cavo per l'uscita TV Matrox</title>
<para>
Nessuno si prende alcuna responsabilità, né garantisce per qualsiasi danno
causato da questa documentazione.
</para>

<formalpara><title>Cavo per G400</title>
<para>
Il quarto pin del connettore CRTC2 è il segnale video composito. La terra sono
il sesto, settimo e ottavo pin. (informazioni fornite da Balázs Rácz)
</para>
</formalpara>

<formalpara><title>Cavo per G450</title>
<para>
Il primo pin del connettore CRTC2 è il segnale video composito. La terra sono
il quinto, sesto, settimo e quindicesimo pin (5, 6, 7, 15).
(informazioni fornite da Balázs Kerekes)
</para>
</formalpara>
</sect2>

<!-- ********** -->

<sect2 id="tvout-ati">
<title>Schede ATI</title>

<formalpara><title>PREAMBOLO</title>
<para>
Attualmente ATI non vuole supportare alcuno dei suoi chip TV-out sotto Linux a
causa della loro tecnologia Macrovision sotto licenza.
</para>
</formalpara>

<itemizedlist>
<title>SITUAZIONE USCITA TV DELLE SCHEDE ATI IN LINUX</title>
<listitem><para>
  <emphasis role="bold">ATI Mach64</emphasis>:
  supportata da <ulink url="http://gatos.sf.net">GATOS</ulink>.
</para></listitem>
<listitem><para>
  <emphasis role="bold">ASIC Radeon VIVO</emphasis>:
  supportata da <ulink url="http://gatos.sf.net">GATOS</ulink>.
</para></listitem>
<listitem><para>
  <emphasis role="bold">Radeon</emphasis> e <emphasis role="bold">Rage128</emphasis>:
  supportate da <application>MPlayer</application>!
  Controlla le sezioni <link linkend="vesa">driver VESA</link> e
  <link linkend="vidix">VIDIX</link>.
</para></listitem>
<listitem><para>
  <emphasis role="bold">Rage Mobility P/M, Radeon, Rage 128, Mobility M3/M4</emphasis>:
  supportate da
  <ulink url="http://www.stud.uni-hamburg.de/users/lennart/projects/atitvout/">atitvout</ulink>.
</para></listitem>
</itemizedlist>

<para>
Con le altre schede usa semplicemente il driver <link linkend="vesa">VESA</link>
senza VIDIX. Tuttavia ti serve una CPU potente.
</para>

<para>
Un'unica cosa ti serve fare - <emphasis role="bold">Assicurati di avere il
connettore TV collegato prima di avviare il tuo PC</emphasis> dato che il BIOS
video si inizializza solamente durante il passaggio POST.
</para>
</sect2>

<!-- ********** -->

<sect2 id="tvout-nvidia">
<title>nVidia</title>

<para>
Per prima cosa, DEVI scaricare i driver proprietari a sorgenti chiusi da
<ulink url="http://nvidia.com"/>.
Non sarà spiegato il processo di installazione e configurazione visto che non
esula lo scopo di questa documentazione.
</para>

<para>
Dopo che XFree86, XVideo, e l'accelerazione 3D funzionano correttamente,
modifica la sezione Device della tua scheda nel file
<filename>XF86Config</filename>, secondo l'esempio seguente (adattalo alla tua
scheda/TV):

<programlisting>
Section "Device"
        Identifier      "GeForce"
        VendorName      "ASUS"
        BoardName       "nVidia GeForce2/MX 400"
        Driver          "nvidia"
        #Option         "NvAGP" "1"
        Option          "NoLogo"
        Option          "CursorShadow"  "on"

        Option          "TwinView"
        Option          "TwinViewOrientation" "Clone"
        Option          "MetaModes" "1024x768,640x480"
        Option          "ConnectedMonitor" "CRT, TV"
        Option          "TVStandard" "PAL-B"
        Option          "TVOutFormat" "Composite"
EndSection
</programlisting>
</para>

<para>
Sicuramente la cosa importante è la parte TwinView.
</para>
</sect2>

<!-- ********** -->

<sect2 id="tvout-neomagic">
<title>NeoMagic</title>

<para>
Il chip NeoMagic si trova in unìampia gamma di portatili, alcuni dei quali sono
equipaggiati con un codificatore TV analogico semplice, alcuni ne hanno uno
avanzato.
<itemizedlist>
<listitem><para>
  E' stato riportato che si può ottenere un'uscita TV affidabile usando
  <option>-vo fbdev</option> o <option>-vo fbdev2</option>.
  Devi avere vesafb compilato nel kernel e passare i seguenti parametri sulla
  riga di avvio del kernel:
  <option>append="video=vesafb:ywrap,mtrr" vga=791</option>.
  Dovresti far partire <application>X</application>, poi passare alla modalità
  in console con per es.
  <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap><keycap>F1</keycap></keycombo>.
  Se non avvii <application>X</application> prima di lanciare
  <application>MPlayer</application> dalla console, il video diventa lento e
  frammentato (chiarimenti sono benvenuti).
  Collegati in console, poi lancia il comando seguente:

  <screen>clear; mplayer -vo fbdev -zoom -cache 8192 dvd://</screen>

  Ora dovresti vedere il filmato in console, che riempie circa la metà dello
  schermo LCD del tuo portatile. Per passare alla TV premi per tre volte
  <keycombo><keycap>Fn</keycap><keycap>F5</keycap></keycombo>.
  Provato su un Tecra 8000, kernel 2.6.15 con vesafb, ALSA v1.0.10.
</para></listitem>
<listitem>
  <para>
  <emphasis role="bold">Chip di codifica Chrontel 70xx</emphasis>:
  Si trova negli IBM Thinkpad 390E e facilmente altri Thinkpad o portatili.
  </para><para>
  Devi usare <option>-vo vesa:neotv_pal</option> per PAL o
  <option>-vo vesa:neotv_ntsc</option> per NTSC.
  Fornirà la funzione di uscita TV nelle modalità a 16 e 8 bpp seguenti:
  </para>
  <itemizedlist>
    <listitem><para>NTSC 320x240, 640x480 e forse anche 800x600.</para></listitem>
    <listitem><para>PAL  320x240, 400x300, 640x480, 800x600.</para></listitem>
  </itemizedlist>
  <para>
  La modalità 512x384 non è supportata dal BIOS. Per attivare l'uscita TV
  devi ridimensionare l'immagine a una risoluzione diversa. Se riesci a vedere
  un immagine sullo schermo a 640x480 o a 800x600 ma non a 320x240 o ad altre
  risoluzioni inferiori devi sostituire due tabelle in
  <filename>vbelib.c</filename>. Vedi la funzione vbeSetTV per i dettagli.
  In questo caso per favore contatta l'autore.
  </para>
  <para>
  Problemi conosciuti: solo VESA, non è implementato alcun controllo come
  luminosità, contrasto, livello del nero, filtro per lo sfarfallio.
  </para>
</listitem>
</itemizedlist>
</para>
</sect2>
</sect1>

</chapter>
