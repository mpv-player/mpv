<?xml version="1.0" encoding="utf-8"?>
<!-- 52% synced with r23272 -->
<chapter id="video">
<title>Dispositivi di uscita video</title>

<sect1 id="mtrr">
<title>Impostare gli MTRR</title>

<para>
Si consiglia vivamente di controllare che i registri MTRR siano impostati
correttamente, poiché possono aumentare di molto le prestazioni.
</para>

<para>
Fai un <command>cat /proc/mtrr</command>:
<screen>
<prompt>--($:~)--</prompt> cat /proc/mtrr
reg00: base=0xe4000000 (3648MB), size=  16MB: write-combining, count=9
reg01: base=0xd8000000 (3456MB), size= 128MB: write-combining, count=1<!--
--></screen>
</para>

<para>
E' giusto, mostra la mia Matrox G400 con 16MB di memoria. L'ho fatto da
XFree 4.x.x, che imposta i registri MTRR automaticamente.
</para>

<para>
Se non ha funzionato, devi farlo a mano. Per prima cosa, devi trovare
l'indirizzo di base. Hai 3 modi per trovarlo:

<orderedlist>
<listitem><para>
  dai messaggi di avvio di X11, per esempio:
  <screen>
(--) SVGA: PCI: Matrox MGA G400 AGP rev 4, Memory @ 0xd8000000, 0xd4000000
(--) SVGA: Linear framebuffer at 0xD8000000<!--
  --></screen>
</para></listitem>
<listitem><para>
  da <filename>/proc/pci</filename> (usa il comando
  <command>lspci -v</command>):
  <screen>
01:00.0 VGA compatible controller: Matrox Graphics, Inc.: Unknown device 0525
Memory at d8000000 (32-bit, prefetchable)<!--
  --></screen>
</para></listitem>
<listitem><para>
  dai messaggi del driver del kernel mga_vid (usa <command>dmesg</command>):
  <screen>mga_mem_base = d8000000</screen>
</para></listitem>
</orderedlist>
</para>

<para>
Ora troviamo la dimensione della memoria. Questo è molto facile, converti
semplicemente la video RAM in esadecimale, o usa questa tabella:
<informaltable frame="none">
<tgroup cols="2">
<tbody>
  <row><entry>1 MB</entry><entry>0x100000</entry></row>
  <row><entry>2 MB</entry><entry>0x200000</entry></row>
  <row><entry>4 MB</entry><entry>0x400000</entry></row>
  <row><entry>8 MB</entry><entry>0x800000</entry></row>
  <row><entry>16 MB</entry><entry>0x1000000</entry></row>
  <row><entry>32 MB</entry><entry>0x2000000</entry></row>
</tbody>
</tgroup>
</informaltable>
</para>

<para>
Ora che sai l'indirizzo di base e la dimensione della memoria, impostiamo i
registri MTRR!
Per esempio, per la scheda Matrox suddetta (<literal>base=0xd8000000</literal>)
con 32MB di ram (<literal>size=0x2000000</literal>) esegui semplicemente:
<screen>
echo "base=0xd8000000 size=0x2000000 type=write-combining" &gt; /proc/mtrr
</screen>
</para>

<para>
Non tutte le CPU hanno gli MTRR. Per esempio le CPU K6-2 più vecchie (intorno
ai 266MHz, stepping 0) non hanno degli MTRR, ma gli stepping 12 invece sì
(esegui <command>cat /proc/cpuinfo</command> per verificarlo).
</para>
</sect1>


<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->


<sect1 id="xv">
<title>Xv</title>

<para>
In XFree86 4.0.2 o successivi, puoi utilizzare le funzioni YUV hardware della
tua scheda usando l'estensione XVideo. Questo è quello che fa l'opzione
<option>-vo xv</option>. Inoltre, il driver supporta l'impostazione di
luminosità/contrasto/tonalità/etc (a meno che tu non usi il vecchio e
lento codec DirectShow DivX, che le supporta ovunque), vedi la pagina man.
</para>

<para>
In order to make this work, be sure to check the following:
Per far sì che funzioni, assicurati di controllare le seguenti:

<orderedlist>
<listitem><para>
  Che tu usi XFree86 4.0.2 o superiore (le versioni precedenti non hanno XVideo)
</para></listitem>
<listitem><para>
  Che la tua scheda supporti l'accellerazione hardware (le schede moderne
  la supportano)
</para></listitem>
<listitem><para>
  Che X carichi l'estensione XVideo, è un qualcosa del genere:
  <programlisting>(II) Loading extension XVideo</programlisting>
  in <filename>/var/log/XFree86.0.log</filename>
  <note><para>
   Questo carica solo l'estensione per XFree86. In una buona installazione
   viene sempre caricata, e non significa che il supporto per l'XVideo della
   <emphasis role="bold">scheda</emphasis> sia supportato!
  </para></note>
</para></listitem>
<listitem><para>
  Che la tua scheda abbia il supporto Xv sotto Linux. Per controllare, prova con
  <command>xvinfo</command>, è parte della distribuzione di XFree86. Dovrebbe
  mostrarti un lungo testo, simile al seguente:
  <screen>
X-Video Extension version 2.2
screen #0
  Adaptor #0: "Savage Streams Engine"
    number of ports: 1
    port base: 43
    operations supported: PutImage
    supported visuals:
      depth 16, visualID 0x22
      depth 16, visualID 0x23
    number of attributes: 5
(...)
    Number of image formats: 7
      id: 0x32595559 (YUY2)
        guid: 59555932-0000-0010-8000-00aa00389b71
        bits per pixel: 16
        number of planes: 1
        type: YUV (packed)
      id: 0x32315659 (YV12)
        guid: 59563132-0000-0010-8000-00aa00389b71
        bits per pixel: 12
        number of planes: 3
        type: YUV (planar)
(...etc...)<!--
--></screen>
  Deve supportare i formati pixel YUY2 packed e YV12 planar per poter essere
  utilizzabile con <application>MPlayer</application>.
</para></listitem>
<listitem><para>
  E infine, controlla che <application>MPlayer</application> sia stato compilato
  col supporto per 'xv'. Lancia un <command>mplayer -vo help | grep xv </command>.
  Se il supporto per 'xv' è compilato, dovrebbe uscire una linea come la
  seguente:
  <screen>  xv      X11/Xv</screen>
</para></listitem>
</orderedlist>
</para>


<sect2 id="tdfx">
<title>Schede 3dfx</title>

<para>
I vecchi driver 3dfx erano conosciuti per aver problemi con l'accellerazione
XVideo, non supportavano gli spazi colore YUY2 o YV12. Verifica di avere XFree86
4.2.0 o superiore, può gestire YV12 e YUY2, mentre le versioni precedenti,
4.1.0 incluso, <emphasis role="bold">vanno in crash con YV12</emphasis>.
Se hai degli strani risultati usando <option>-vo xv</option>, prova SDL
(anch'essa ha XVideo) e vedi se aiuta. Controlla la sezione su
<link linkend="sdl">SDL</link> per i dettagli.
</para>

<para>
<emphasis role="bold">OPPURE</emphasis>, prova il NUOVO driver
<option>-vo tdfxfb</option>! Vedi la sezione
<link linkend="tdfxfb">tdfxfb</link>
</para>
</sect2>


<sect2 id="s3">
<title>Schede S3</title>

<para>
Le S3 Savage3D dovrebbero funzionare bene, ma per le Savage4, usa XFree86 4.0.3
o superiore (nel caso tu abbia problemi di immagini, prova a 16bpp). Per le
S3 Virge invece: c'è il supporto per xv, ma la scheda in sé è molto lenta,
per cui ti conviene venderla.
</para>

<para>
Non c'è un driver framebuffer nativo per le schede S3 Virge simile a tdfxfb.
Configura il tuo framebuffer (per es. aggiungi
"<option>vga=792 video=vesa:mtrr</option>" alla riga di avvio del kernel) e usa
<option>-vo s3fb</option> (<option>-vf yuy2</option> e <option>-dr</option>
aiutano).
</para>

<note><para>
Non è ben chiaro il perché i modelli Savage non abbiano il supporto YV12 e
facciano la conversione con il driver (lento). Se pensi sia colpa della scheda,
cerca un driver più nuovo, o chiedi gentilmente di un driver abilitato
MMX/3DNow! sulla mailing list MPlayer-users.
</para></note>
</sect2>


<sect2 id="nvidia">
<title>Schede nVidia</title>

<para>
nVidia non è sempre una scelta molto buona sotto Linux ... Il driver
open-source di XFree86 supporta la maggior parte di queste schede, ma in alcuni
casi, dovrai usare il driver a sorgenti chiusi di nVidia, disponibile sul
<ulink url="http://www.nvidia.com/object/linux.html">sito nVidia</ulink>.
Ti servirà sempre questo driver anche se vuoi l'accellerazione 3D.
</para>

<para>
Le schede Riva128 non hanno il supporto XVideo con il driver nVidia di
XFree86 :(
Lamentati con nVidia.
</para>

<para>
Tuttavia, <application>MPlayer</application> contiene un driver
<link linkend="vidix">VIDIX</link> per la maggior parte delle schede nVidia.
Attualmente è a livello di sviluppo beta, è ha alcuni problemi. Per
ulteriori informazioni, vedi la sezione
<link linkend="vidix-nvidia">VIDIX nVidia</link>.
</para>
</sect2>


<sect2 id="ati">
<title>Schede ATI</title>

<para>
Il <ulink url="http://gatos.sf.net">driver GATOS</ulink>
(che dovresti usare a meno che tu non abbia una Rage128 o una Radeon) di
default ha il VSYNC abilitato. Ciò significa che la velocità di decodifica
(!) è sincronizzata alla frequenza di aggiornamento del monitor. Se la
riproduzione ti pare lenta, prova a disabilitare in qualche modo VSYNC, o ad
impostare la frequenza di aggiornamento a n*(fps del film) Hz.
</para>

<para>
Read the <link linkend="vidix">VIDIX</link> section.
Radeon VE - se ti serve X, per questa scheda usa XFree86 4.2.0 o superiore.
Il TV out non è supportato. Ovviamente con <application>MPlayer</application>
puoi felicemente avere un display <emphasis role="bold">accellerato</emphasis>,
con o senza l'<emphasis role="bold">uscita TV</emphasis>, e non servono
librerie né X.
Leggi la sezione <link linkend="vidix">VIDIX</link>.
</para>
</sect2>


<sect2 id="neomagic">
<title>Schede NeoMagic</title>

<para>
Queste schede si possono trovare in molti portatili. Devi usare XFree86 4.3.0 o
superiore, o alternativamente usare i
<ulink url="http://www.mplayerhq.hu/MPlayer/contrib/NeoMagic-driver/">driver con Xv</ulink>
di Stefan Seyfried.
Scegli semplicemente quello che ti serve in base alla tua versione di XFree86.
</para>

<para>
XFree86 4.3.0 include il supporto per Xv, caomunque Bohdan Horst ha postato
una piccola <ulink url="http://www.mplayerhq.hu/MPlayer/contrib/NeoMagic-driver/neo_driver.patch">patch</ulink> ai sorgenti di XFree86 che velocizza fino a
quattro volte tanto le operazioni sul framebuffer (quindi XVideo).
La patch è stata poi incorporata in XFree86 CVS e dovrebbe esserci nei rilasci
successivi al 4.3.0.
</para>

<para>
Per permettere la riproduzione di contenuti della dimensione DVD, modifica il
tuo XF86Config in questo modo:
<programlisting>
Section "Device"
    [...]
    Driver "neomagic"
    <emphasis>Option "OverlayMem" "829440"</emphasis>
    [...]
EndSection<!--
--></programlisting>
</para>
</sect2>


<sect2 id="trident">
<title>Schede Trident</title>

<para>
Se vuoi usare Xv con una scheda Trident, assunto il fatto che con 4.1.0 non
funziona, intalla Xfree 4.2.0. Il 4.2.0 aggiunge il supporto per Xv a schermo
intero con la scheda Cyberblade XP.
</para>

<para>
Alternativamente, <application>MPlayer</application> contiene un driver
<link linkend="vidix">VIDIX</link> per le schede Cyberblade/i1.
</para>
</sect2>


<sect2 id="kyro">
<title>Schede Kyro/PowerVR</title>

<para>
Se vuoi usare Xv con una scheda basata su Kyro (per esempio la Hercules
Prophet 4000XT), dovresti scaricare i driver dal
<ulink url="http://www.powervr.com/">sito di PowerVR</ulink>.
</para>
</sect2>
</sect1>

<!-- ********** -->

<sect1 id="dga">
<title>DGA</title>

<formalpara>
<title>PREAMBOLO</title>
<para>
Questa documento cerca di spiegare in poche parole cosa sia DGA e cosa possa
fare (e cosa no) il driver di uscita video DGA di
<application>MPlayer</application>.
</para>
</formalpara>

<formalpara>
<title>COS'E' DGA</title>
<para>
<acronym>DGA</acronym> è il nome breve di <emphasis>Direct Graphics
Access</emphasis> (accesso grafico diretto) ed è un modo per fa sì
che un programma oltrepassi l'X server e modifichi direttamente la memoria
del framebuffer. In termini tecnici la memoria del framebuffer viene
rimappata nello spazio di memoria del tuo processo.
Questo è permesso dal kernel solo se hai provilegi di superutente. Puoi averli
o autenticandoti come <systemitem class="username">root</systemitem> o
impostando il bit SUID sull'eseguibile di <application>MPlayer</application>
(<emphasis role="bold">sconsigliato</emphasis>).
</para>
</formalpara>
<para>
Ci sono due versioni di DGA: DGA1 usato da XFree 3.x.x e DGA2 che è stato
introdotto con XFree 4.0.1.
</para>

<para>
DGA1 fornisce solamente accesso diretto al framebuffer come descritto sopra.
Per modificare la risoluzione del segnale video devi affidarti all'estensione
XVidMode.
</para>

<para>
DGA2 include le funzionalità dell'estensione XVidMode e inoltre permette la
modifica della profondità colore del display. Così, anche se stai facendo
girare un X server con profondità di 32 bit, puoi passare a una di 15 e
__viceversa__.
</para>

<para>
Tuttavia DGA ha dei punti deboli. Sembra sia in qualche modo dipendente dal
chip grafico utilizzato e dall'implementazione del driver video dell'X server
che controlla tale chip. Per cui non funziona su tutti i sistemi...
</para>

<formalpara>
<title>INSTALLARE IL SUPPORTO PER DGA IN MPLAYER</title>

<para>
Per prima cosa assicurati che X carichi l'estensione DGA, guarda in
<filename>/var/log/XFree86.0.log</filename>:

<programlisting>(II) Loading extension XFree86-DGA</programlisting>

Attenzione, si <emphasis role="bold">consiglia vivamente </emphasis>
XFree86 4.0.x o superiore!
Il driver DGA di <application>MPlayer</application> viene rilevato
automaticamente da <filename>./configure</filename>, ovvero puoi forzarlo
con <option>--enable-dga</option>.
</para>
</formalpara>

<para>
Se il driver non è riuscito a reimpostare una risoluzione inferiore, fai delle
prove con le opzioni <option>-vm</option> (solo con X 3.3.x),
<option>-fs</option>, <option>-bpp</option>, <option>-zoom</option> per trovare
una modalità video in cui ci stia il film. Per ora non c'è un convertitore :(
</para>

<para>
Diventa <systemitem class="username">root</systemitem>. A DGA serve l'accesso
da root per essere in grado di scrivere direttamente sulla memoria video. Se
vuoi eseguirlo come utente, allora installa <application>MPlayer</application>
SUID root:

<screen>
chown root <replaceable>/usr/local/bin/mplayer</replaceable>
chmod 750 <replaceable>/usr/local/bin/mplayer</replaceable>
chmod +s <replaceable>/usr/local/bin/mplayer</replaceable>
</screen>

Ora funziona anche da utente normale.
</para>

<caution>
<title>Rischi di sicurezza</title>
<para>
Questo porta un <emphasis role="bold">grosso</emphasis> rischio di sicurezza!
Non farlo <emphasis role="bold">mai</emphasis> su un server o su un computer
che può essere utilizzato da altre persone, perché si possono ottenere
privilegi di root attraverso <application>MPlayer</application> SUID root.
</para>
</caution>

<para>
Ora usa l'opzione <option>-vo dga</option>, e sei a cavallo! (speralo:)
Potresti anche provare se ti funziona l'opzione
<option>-vo sdl:driver=dga</option>!
E' molto più veloce!
</para>


<formalpara id="dga-modelines">
<title>MODIFICARE LA RISOLUZIONE</title>

<para>
Il driver DGA permette la modifica della risoluzione del segnale di uscita.
Questo evita la necessità di eseguire un (lento) ridimensionamento software e
allo stesso tempo fornisce un'immagine a schermo pieno. Idealmente dovrebbe
ridimensionarsi alla risoluzione precisa (rispettando il rapporto di aspetto)
dei dati video, ma l'X server permette solo di impostare le risoluzioni
precedentemente definite in <filename>/etc/X11/XF86Config</filename>
(<filename>/etc/X11/XF86Config-4</filename> per XFree 4.X.X).
Queste ultime sono conosciute come "modelines" e dipendono dalle potenzialità
del tuo hardware video. Il server X legge questo file di configurazione
all'avvio e disabilita le modelines incompatibili col tuo hardware.
Puoi scoprire quali modalità ti restano attraverso il file di log di X11.
Si può trovare qui: <filename>/var/log/XFree86.0.log</filename>.
</para>
</formalpara>

<para>
Queste modalità si sa che funzionano correttamente con un chip Riva128,
usando il driver nv.o del server X.
</para>

<para><programlisting>
Section "Modes"
  Identifier "Modes[0]"
  Modeline "800x600"  40     800 840 968 1056  600 601 605 628
  Modeline "712x600"  35.0   712 740 850 900   400 410 412 425
  Modeline "640x480"  25.175 640 664 760 800   480 491 493 525
  Modeline "400x300"  20     400 416 480 528   300 301 303 314 Doublescan
  Modeline "352x288"  25.10  352 368 416 432   288 296 290 310
  Modeline "352x240"  15.750 352 368 416 432   240 244 246 262 Doublescan
  Modeline "320x240"  12.588 320 336 384 400   240 245 246 262 Doublescan
EndSection
</programlisting></para>


<formalpara>
<title>DGA &amp; MPLAYER</title>
<para>
DGA is used in two places with <application>MPlayer</application>: The SDL
driver can be made to make use of it (<option>-vo sdl:driver=dga</option>) and
within the DGA driver (<option>-vo dga</option>). The above said is true
for both; in the following sections I'll explain how the DGA driver for
<application>MPlayer</application> works.
DGA viene usato con <application>MPlayer</application> in due posti: può
essere usato attraverso il driver SDL (<option>-vo sdl:driver=dga</option>) e
con il driver DGA (<option>-vo dga</option>). Quanto detto sopra è valido per
entrambi; nei paragrafi seguenti viene spiegato come il driver DGA funziona per
<application>MPlayer</application>.

</para>
</formalpara>


<formalpara>
<title>CARATTERISTICHE</title>

<para>
Il driver DGA viene utilizzato specificando <option>-vo dga</option> sulla riga
comando. Il comportamento di default è di passare ad una risoluzione il più
vicino possibile a quella originaria del video. Ignora volutamente le opzioni
<option>-vm</option> e <option>-fs</option> (abilitazione ridimensionamento
video e schermo intero) - cerca sempre di coprire la più vasta area possibile
dello schermo reimpostando la modalità video, evitando così di sprecare cicli
della CPU per ridimensionare l'immagine. Se la modalità video selezionata non
ti piace, puoi forzarlo a scegliere la modalità più prossima alla risoluzione
specificata con <option>-x</option> e <option>-y</option>. Impostando l'opzione
<option>-v</option>, il driver DGA emetterà, tra una sacco ci altre cose,
un'elenco delle risoluzioni supportate dal tuo file
<filename>XF86Config</filename>. Se hai DGA2, puoi anche forzarlo ad utilizzare
una data profondità usando l'opzione <option>-bpp</option>. Profondità
valide sono 15, 16, 24 e 32. Se queste profondità siano supportate nativamente
oppure se debba venir effettuata una conversione (eventualmente lenta), dipende
dal tuo hardware.
</para>
</formalpara>
<para>
Se dovessi essere abbastanza fortunato da avere sufficiente memoria fuori dalla
visualizzazione per poterci far stare un'immagine intera, il driver DGA userà
un buffering doppio, fornendo una riproduzione più fluida. Ti dirà quando il
doppio buffering sarà abilitato o no.
</para>

<para>
"Doppio buffering" significa che il fotogramma successivo del video viene
disegnato nella memoria fuori dello schermo, mentre il fotogramma corrente
viene mostrato. Quando il fotogramma successivo è pronto, il chip grafico
rivece solo l'indirizzo in memoria del nuovo fotogramma e semplicemente prende
da là i dati da mostrare. Nel frattempo l'altro buffer di memoria viene
riempito con altri dati video.
</para>

<para>
Il doppio buffering può venir abilitato usando l'opzione
<option>-double</option> e disabilitato con <option>-nodouble</option>.
L'opzione attuale di default è di disabilitarlo. Usando il driver DGA, la
visualizzazione dati su schermo (OSD, onscreen display) funziona solo con il
doppio buffering abilitato. In ogni caso, abilitare il doppio buffering può
portare una pesante penalizzazione della velocità (sul mio K6-II+ 525 usa
un ulteriore 20% di tempo di CPU) in dipendenza dall'implementazione per DGA
del tuo hardware.
</para>


<formalpara>
<title>PROBLEMI DI VELOCITA'</title>

<para>
In generale, l'accesso DGA al framebuffer dovrebbe essere almeno veloce quanto
utilizzare il driver X11, con il beneficio aggiunto di ottenere un'immagine a
schermo intero. I valori di velocità percentuale emessi da
<application>MPlayer</application> devono essere interpretati con un po' di
attenzione, dato che per esempio con il driver X11 non includono il tempo usato
dal server X per il disegno effettivo. Attacca un terminale sulla seriale della
tua macchina e lancia <command>top</command> per vedere cosa stia davvero
succedendo.
</para>
</formalpara>

<para>
In linea di massima, l'aumento di velocità usando DGA rispetto all'utilizzo
'normale' di X11 dipende fortemente dalla tua scheda video e da quanto bene il
relativo modulo del server X sia ottimizzato.
</para>

<para>
Se hai un sistema lento, è meglio usare una profondità di 15 o 16 bit, visto
che richiedono solo la metà della banda di memoria di una visualizzazion a
32 bit.
</para>

<para>
Usare una profondità di 24 è una buona idea anche se la tua scheda supporta
nativamente solo quella a 32 bit, dato che trasferisce il 25% dei dati in meno
rispetto alla modalità a 32/32.
</para>

<para>
Ho visto alcuni file AVI riprodotti su Pentium MMX 266. Le CPU AMD K6-2 possono
lavorare a 400 MHz e oltre.
</para>


<formalpara>
<title>PROBLEMI/BACHI CONOSCIUTI</title>

<para>
Bene, secondo gli sviluppatori di XFree, DGA è quasi una bestia. Ti dicono che
è meglio non usarla. La sua implementazione non è sempre perfetta con tutti i
driver dei chip per XFree che ci sono là fuori.
</para>
</formalpara>

<itemizedlist>
<listitem><para>
  Con XFree 4.0.3 e <filename>nv.o</filename> c'è un baco che porta ad avere
  strani colori.
</para></listitem>
<listitem><para>
  I driver ATI hanno bisogno che la modalità sia reimpostata più di una
  volta dopo aver utilizzato DGA.
</para></listitem>
<listitem><para>
  Alcuni driver semplicemente non riescono a tornare alla risoluzione normale
  (Usa
  <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap><keycap>Keypad +</keycap></keycombo>
  e
  <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap><keycap>Keypad -</keycap></keycombo>
  per cambiarla manualmente).
</para></listitem>
<listitem><para>
  Alcuni driver semplicemente mostrano strani colori.
</para></listitem>
<listitem><para>
  Alcuni driver mentono riguardo alla memoria che mappano nello spazio
  indirizzi del processo, perciò vo_dga non usa il doppio buffering (SIS?).
</para></listitem>
<listitem><para>
  Alcuni driver sembra che falliscano nel fornire almeno una modalità valida.
  In questo caso il driver DGA andrà in crash raccontandoti di una modalità
  senza senso tipo 100000x100000 o qualcosa di simile.
</para></listitem>
<listitem><para>
  L'OSD funziona solo col doppio buffering abilitato (altrimenti sfarfalla).
</para></listitem>
</itemizedlist>

</sect1>

<!-- ********** -->

<sect1 id="sdl">
<title>SDL</title>

<para>
<acronym>SDL</acronym> (Simple Directmedia Layer) è praticamente un'interfaccia
unificata audio/video. I programmi che la usano non sanno che driver video o
audio SDL usi davvero, ma conoscono solo l'interfaccia. Per esempio un porting
di Doom che usi SDL può girara sopra a svgalib, aalib, X, fbdev e altro, devi
semplicemente specificare (per esempio) il driver video da usare attraverso la
variabile d'ambiente <envar>SDL_VIDEODRIVER</envar>. In teoria, perlomeno.
</para>

<para>
Con <application>MPlayer</application>, usiamo la sua potenzialità di
ridimensionamento via software del driver di X11 per le schede che non
gestiscono XVideo, fino a quando non faremo il nostro (più veloce, più bello)
ridimensionatore software. Abbiamo anche usato la sua uscita per aalib, ma ora
abbiamo la nostra che è più comoda. La sua modalità per DGA era migliore
della nostra fino a poco tempo fa. Hai capito, no? :)
</para>

<para>
Aiuta anche con alcuni driver/schede bacate, se il video è scattoso (non per
problemi di sistema lento) oppure l'audio è saltellante.
</para>

<para>
L'uscita video SDL supporta la visualizzazione dei sottotitoli sotto al filmato
ovvero sulla striscia nera (se presente).
</para>
</sect1>

<!-- ********** -->

<sect1 id="svgalib">
<title>SVGAlib</title>

<formalpara>
<title>INSTALLAZIONE</title>
<para>
Affinché <application>MPlayer</application> compili il suo driver per SVGAlib
(autorilevato, ma può essere forzato), devi installare svgalib e il suo
pacchetto di sviluppo e non dimenticare di modificare
<filename>/etc/vga/libvga.config</filename> in modo che corrisponda alla tua
scheda e al tuo monitor.
</para>
</formalpara>

<note><para>
Assicurati di non usare l'opzione <option>-fs</option>, dato che attiva
l'utilizzo del ridimensionatore software, ed è lento. Se davvero ti serve, usa
l'opzione <option>-sws 4</option>, che porterà una bassa qualità, ma è in
qualche modo più veloce.
</para></note>

<formalpara>
<title>SUPPORTO PER EGA (4BPP)</title>
<para>
SVGAlib include EGAlib, e <application>MPlayer</application> ha la possibilità
di mostrare qualsiasi filmato in 16 colori, utilizzabile in queste situazioni:
</para>
</formalpara>

<itemizedlist>
<listitem><para>
  Scheda EGA con monitor EGA: 320x200x4bpp, 640x200x4bpp, 640x350x4bpp
</para></listitem>
<listitem><para>
  Scheda EGA con monitor CGA: 320x200x4bpp, 640x200x4bpp
</para></listitem>
</itemizedlist>

<para>
Il valore dei bpp (bit per pixel) deve essere impostato a 4 manualmente:
<option>-bpp 4</option>
</para>

<para>
Il filmato probabilmente deve essere rimpicciolito per starci nella modalità
EGA:
<screen>-vf scale=640:350</screen>
or
<screen>-vf scale=320:200</screen>
</para>

<para>
Per questo ci serve una funzione di ridimensionamento veloce ma a bassa
qualità:
<screen>-sws 4</screen>
</para>

<para>
Forse la correzione automatica dell'aspetto va disattivata:
<screen>-noaspect</screen>
</para>

<note><para>
Secondo la mia esperienza la qualità migliore dell'immagine su schermi EGA
può essere ottenuta diminuendo un pochino la luminosità:
<option>-vf eq=-20:0</option>. Sul mio sistema ho anche bisogno di abbassare
la frequenza audio, dato che era rovinata a 44kHz:
<option>-srate 22050</option>.
</para></note>

<para>
Puoi abilitare l'OSD e i sottotitoli solo con il filtro <option>expand</option>,
vedi la pagina man per i parametri precisi.
</para>
</sect1>

<!-- ********** -->

<sect1 id="fbdev">
<title>Uscita su framebuffer (FBdev)</title>

<para>
Se compilare l'uscita FBdev o no viene rilevato automaticamente da
<filename>./configure</filename>. Leggi nei sorgenti del kernel la
documentazione sul framebuffer (<filename>Documentation/fb/*</filename>) per
ulteriori informazioni.
</para>

<para>
Se la tua scheda non supporta lo standard VBE 2.0 (vecchie schede ISA/PCI, come
la S3 Trio64), ma solo VBE 1.2 (o precedente?): bene, c'è ancora VESAfb, ma
ddovrai caricare SciTech Display Doctor (conosciuto precedentemente come UniVBE)
prima di avviare Linux. Usa un disco di avvio DOS o qualcosa del genere. E non
dimenticare di registrare il tuo UniVBE ;))
</para>

<para>
L'uscita su FBdev richiede principalmente alcuni parametri addizionali:
</para>

<variablelist>
<varlistentry>
  <term><option>-fb</option></term>
  <listitem><para>
    specifica il dispositivo framebuffer da usare (default:
    <filename>/dev/fb0</filename>)
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-fbmode</option></term>
  <listitem><para>
    nome della modalità da usare (come in <filename>/etc/fb.modes</filename>)
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-fbmodeconfig</option></term>
  <listitem><para>
    file di configirazione delle modalità (default:
    <filename>/etc/fb.modes</filename>)
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-monitor-hfreq</option></term>
  <term><option>-monitor-vfreq</option></term>
  <term><option>-monitor-dotclock</option></term>
  <listitem><para>
    valori <emphasis role="bold">importanti</emphasis>, vedi
    <filename>example.conf</filename>
  </para></listitem>
</varlistentry>
</variablelist>

<para>
Se vuoi passare a una modalità particolare, allora usa
<screen>
mplayer -vm -fbmode <replaceable>nome_modalità</replaceable> <replaceable>nomefile</replaceable>
</screen>
</para>

<itemizedlist>
<listitem><para>
  <option>-vm</option> da sola può scegliere la modalità più adatta da
  <filename>/etc/fb.modes</filename>. Può essere usata anche insieme con le
  opzioni <option>-x</option> e <option>-y</option>. L'opzione
  <option>-flip</option> è supportata solo se il formato pixel del film
  corrisponde al formato pixel della modalità video. Stai attento al valore
  di bpp, il driver fbdev cerca di usare prima quello corrente, poi quello che
  indichi tramite l'opzione <option>-bpp</option> option.
</para></listitem>
<listitem><para>
  l'opzione <option>-zoom</option> non è supportata
  (usa <option>-vf scale</option>). Non puoi usare modalità a 8bbp (o meno).
</para></listitem>
<listitem><para>
  Probabilmente vuoi disabilitare il cursore:
  <screen>echo -e '\033[?25l'</screen>
  o
  <screen>setterm -cursor off</screen>
  e il salvaschermo:
  <screen>setterm -blank 0</screen>
  Per riabilitare il cursore:
  <screen>echo -e '\033[?25h'</screen>
  o
  <screen>setterm -cursor on</screen>
</para></listitem>
</itemizedlist>

<note><para>
La modifica della modalità video di FBdev <emphasis>non funziona</emphasis>
con il framebuffer VESA, e non chiederla, visto che non è una limitazione di
<application>MPlayer</application>.
</para></note>
</sect1>

<!-- ********** -->

<sect1 id="mga_vid">
<title>Framebuffer Matrox (mga_vid)</title>

<para>
<systemitem>mga_vid</systemitem> è un'incrocio di un driver di uscita video e
di un modulo del kernel, che utilizza il ridimensionatore e l'overlay video
delle Matrox G200/G400/G450/G550 per effettuare una conversione dello spazio
colore YUV->RGB e un ridimensionamento video arbitrario.
<systemitem>mga_vid</systemitem> ha un supporto hardware per VSYNC con triplo
buffering. Funziona sia in una console su framebuffer che dentro X, ma solo con
Linux 2.4.x.
</para>

<para>
Per una versione del driver per Linux 2.6.x controlla
<ulink url="http://attila.kinali.ch/mga/"/>.
</para>

<procedure>
<title>Installazione:</title>
<step><para>
  Per usarlo, devi innanzitutto compilare <filename>mga_vid.o</filename>:
  <screen>
cd drivers
make<!--
--></screen>
</para></step>
<step><para>
  Poi esegui (come <systemitem class="username">root</systemitem>)
  <screen>make install</screen>
  che dovrebbe installare il modulo e creare per te il nodo del dispositivo.
  Carica il driver con
  <screen>insmod mga_vid.o</screen>
</para></step>
<step><para>
  Dovresti verificare il rilevamento della dimensione della memoria usando il
  comando <command>dmesg</command>. Se è errato, usa l'opzione
  <option>mga_ram_size</option> (prima fai <command>rmmod mga_vid</command>),
  indicando in MB la dimensione della memoria della scheda:
  <screen>insmod mga_vid.o mga_ram_size=16</screen>
</para></step>
<step><para>
  Per far sì che venga caricato/scaricato quando serve, prima inserisci la
  riga seguente alla fine di <filename>/etc/modules.conf</filename>:

  <programlisting>alias char-major-178 mga_vid</programlisting>
</para></step>
<step><para>
  Ora devi (ri)compilare <application>MPlayer</application>,
  <command>./configure</command> rileverà <filename>/dev/mga_vid</filename> e
  compilerà il driver 'mga'. Si potrà usare da
  <application>MPlayer</application> con <option>-vo mga</option> se sei su una
  console matroxfb, oppure <option>-vo xmga</option> se sei sotto XFree86 3.x.x
  o 4.x.x.
</para></step>
</procedure>

<para>
Il driver mga_vid collabora con Xv.
</para>

<para>
Si può leggere il file del dispositivo <filename>/dev/mga_vid</filename> per
alcune informazioni, per esempio facendo
<screen>cat /dev/mga_vid</screen>
e ci si può scrivere per modificare la luminosità:
<screen>echo "brightness=120" &gt; /dev/mga_vid</screen>
</para>

<para>
Nella stessa directory c'è un'applicazione di test che si chiama
<command>mga_vid_test</command>. Se tutto funziona bene, dovrebbe disegnare
immagini di 256x256 sullo schermo.
</para>

</sect1>

<!-- ********** -->

<sect1 id="tdfxfb" xreflabel="3Dfx YUV support (tdfxfb)">
<title>Supporto YUV per 3Dfx</title>

<para>
Questo driver usa il driver tdfx del kernel per il framebuffer per riprodurre
filmati con accellerazione YUV. Ti serve un kernel con supporto per tdfxfb e
ricompilare con
<screen>./configure --enable-tdfxfb</screen>
</para>
</sect1>

<!-- ********** -->

<sect1 id="tdfx_vid">
<title>tdfx_vid</title>

<para>
Questo è un'incrocio di un driver di uscita video e di un modulo del kernel,
simile a <link linkend="mga_vid">mga_vid</link>. Ti serve un kernel 2.4.x con
il driver <systemitem>agpgart</systemitem>, visto che
<systemitem>tdfx_vid</systemitem> usa AGP. Passa
<option>--enable-tdfxfb</option> a <command>configure</command> per compilare
il driver di uscita video e compila il module del kernel con le istruzioni
seguenti.
</para>

<procedure>
<title>Installare il modulo del kernel tdfx_vid.o:</title>
<step><para>
  Compila <filename>tdfx_vid.o</filename>:
  <screen>
cd drivers
make</screen>
</para></step>
<step><para>
  Poi esegui (come <systemitem class="username">root</systemitem>)
  <screen>make install</screen>
  che dovrebbe installare il modulo e creare per te il nodo del dispositivo.
  Carica il driver con
  <screen>insmod tdfx_vid.o</screen>
</para></step>
<step><para>
  Per far sì che venga caricato/scaricato quando serve, prima inserisci la
  riga seguente alla fine di <filename>/etc/modules.conf</filename>:


  <programlisting>alias char-major-178 tdfx_vid</programlisting>
</para></step>
</procedure>

<para>
Nella stessa directory c'è un'applicazione di test che si chiama
<command>tdfx_vid_test</command>. Se tutto funziona bene, dovrebbe fornire
alcune informazioni utili.
</para>

</sect1>

<!-- ********** -->

<sect1 id="opengl">
<title>Uscita OpenGL</title>

<para>
<application>MPlayer</application> supporta la riproduzione di filmati usando
OpenGL, ma se se la tua piattaforma/driver supportano xv come è il caso di un
PC con Linux, allora usa xv, le prestazioni OpenGL sono pesantemente peggiori.
Se hai un'implementazione di X11 senza xv, OpenGL è una valida alternativa.
</para>

<para>
Sfortunatamente non tutti i driver supportano questa caratteristica. I driver
Utah-GLX (per XFree86 3.3.6) la supportano per tutte le schede.
Vedi <ulink url="http://utah-glx.sf.net"/> per dettagli su come installarli.
</para>

<para>
XFree86(DRI) 4.0.3 or later supports OpenGL with Matrox and Radeon cards,
4.2.0 or later supports Rage128.
Vedi <ulink url="http://dri.sf.net"/> for download and installation
instructions.
XFree86(DRI) 4.0.3 o successivi supportano OpenGL con schede Matrox e Radeon,
4.2.0 o successivi supportano le Rage128.
Leggi su <ulink url="http://dri.sf.net"/> le istruzioni per scaricarli ed
installare.
</para>

<para>
Un consiglio per i nostri utenti: l'uscita video GL può essere usata per
ottenere un'uscita sincronizzata su vsync. Devi impostare una variabile
d'ambiente (perlomeno con nVidia):
</para>

<para>
<command>export __GL_SYNC_TO_VBLANK=1</command>
</para>
</sect1>

<!-- ********** -->

<sect1 id="aalib">
<title>AAlib &ndash; Visualizzazione in modalità testuale</title>

<para>
AAlib è una libreria per mostrare elementi grafici in modalità testuale,
usando un potente renderizzatore ASCII. Ci sono <emphasis>valanghe</emphasis>
di programmi che la utilizzano, come Doom, Quake, etc.
<application>MPlayer</application> ne include un driver facilmente utilizzabile.
Se <filename>./configure</filename> trova AAlib installata, il driver di uscita
video per aalib verrà compilato.
</para>

<para>
Puoi usare alcune chiavi nella finestra AA per modificare le opzioni di
renderizzazione:
</para>

<informaltable>
<tgroup cols="2">
<thead>
  <row><entry>Chiave</entry><entry>Azione</entry></row>
</thead>
<tbody>
<row><entry><keycap>1</keycap></entry><entry>
  diminuisce il contrasto
</entry></row>
<row><entry><keycap>2</keycap></entry><entry>
  aumenta il contrasto
</entry></row>
<row><entry><keycap>3</keycap></entry><entry>
  diminuisce la luminosità
</entry></row>
<row><entry><keycap>4</keycap></entry><entry>
  aumenta la luminosità
</entry></row>
<row><entry><keycap>5</keycap></entry><entry>
  abilita/disabilita il fast rendering
</entry></row>
<row><entry><keycap>6</keycap></entry><entry>
  imposta la modalità di dithering (nessuna, distribuzione di errore,
  Floyd Steinberg)
</entry></row>
<row><entry><keycap>7</keycap></entry><entry>
  inverte l'immagine
</entry></row>
<row><entry><keycap>8</keycap></entry><entry>
  passa tra i controlli di aa e quelli di <application>MPlayer</application>
</entry></row>
</tbody>
</tgroup>
</informaltable>

<variablelist>
<title>Si possono usare le seguenti opzioni sulla riga di comando:</title>
<varlistentry>
  <term><option>-aaosdcolor=<replaceable>V</replaceable></option></term>
  <listitem><para>
    modifica il colore OSD
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-aasubcolor=<replaceable>V</replaceable></option></term>
  <listitem><para>
    modifica il colore dei sottitoli
    </para><para>
    dove <replaceable>V</replaceable> può essere:
    <literal>0</literal> (normale),
    <literal>1</literal> (scuro),
    <literal>2</literal> (grassetto),
    <literal>3</literal> (font grassetto),
    <literal>4</literal> (invertito),
    <literal>5</literal> (speciale).
  </para></listitem>
</varlistentry>
</variablelist>

<variablelist>
<title>AAlib di suo fornisce un po' di opzioni. Di seguito alcune
importanti:</title>
<varlistentry>
  <term><option>-aadriver</option></term>
  <listitem><para>
    Impostra il driver aa preferito (X11, curses, Linux).
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-aaextended</option></term>
  <listitem><para>
    Usa tutti e 256 i caratteri.
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-aaeight</option></term>
  <listitem><para>
    Usa ASCII a otto bit.
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-aahelp</option></term>
  <listitem><para>
    Lista tutte le opzioni per aalib.
  </para></listitem>
</varlistentry>
</variablelist>

<note><para>
La renderizzazione è molto pesante per la CPU, specialmente usando AA-on-X
(usando aalib su X), ed è più leggera su una console standard, senza
framebuffer. Usa SVGATextMode per impostare una modalità a molti caratteri,
poi divertiti! (le schede Hercules con seconda uscita sono mitiche :))
(ma IMHO puoi usare l'opzione <option>-vf 1bpp</option> per avere grafica su
hgafb:)
</para></note>

<para>
Usa l'opzione <option>-framedrop</option> se il tuo computer non è abbastanza
veloce da renderizzare tutti i fotogrammi!
</para>

<para>
Riproducendo su un terminale, avrai migliore velocità e qualità usando il
driver Linux, non ncurses (<option>-aadriver linux</option>). Ma devi anche
avere accesso a
<filename>/dev/vcsa<replaceable>&lt;terminale&gt;</replaceable></filename>!
Questo non è rilevato automaticamente da aalib, ma vo_aa cerca di trovare la
modalità migliore. Leggi <ulink url="http://aa-project.sf.net/tune"/> per
altri consigli di impostazioni.
</para>
</sect1>

<!-- ********** -->

<sect1 id="caca">
<title>
<systemitem class="library">libcaca</systemitem> &ndash; Libreria Color ASCII Art
</title>

<para>
La libreria <ulink url="http://sam.zoy.org/projects/libcaca/"><systemitem class="library">libcaca</systemitem></ulink>
è una libreria grafica che emette testo al posto di pixel, indi può funzionare
su schede video più vecchie o su terminali di testo. Non è dissimile dalla
famosa libreria <systemitem class="library">AAlib</systemitem>.
<systemitem class="library">libcaca</systemitem> ha bisogno di un terminale per
poter funzionare, perciò dovrebbe funzionare su tutti i sistemi Unix (incluso
Mac OS X) usando la libreria <systemitem class="library">slang</systemitem>
ovvero la libreria <systemitem class="library">ncurses</systemitem>, sotto DOS
usando la libreria <systemitem class="library">conio.h</systemitem>, e nei
sistemi Windows usando <systemitem class="library">slang</systemitem> o
<systemitem class="library">ncurses</systemitem> (tramite l'emulazione Cygwin)
oppure <systemitem class="library">conio.h</systemitem>. Se
<filename>./configure</filename> rileva la presenza di
<systemitem class="library">libcaca</systemitem>, il driver di uscita video per
caca verrà compilato.
</para>

<itemizedlist>
<title>Le differenze rispetto ad <systemitem class="library">AAlib</systemitem>
  sono le seguenti:</title>
<listitem><para>
   16 colori disponibili per l'emissione a caratteri (256 coppie di colori)
</para></listitem>
<listitem><para>
   dithering del colore dell'immagine
</para></listitem>
</itemizedlist>

<itemizedlist>
<title>Ma <systemitem class="library">libcaca</systemitem> ha anche le seguenti
  limitazioni:</title>
<listitem><para>
   nessun supporto per luminosià, contrasto, gamma
</para></listitem>
</itemizedlist>

<para>
Puoi utilizzare alcuni tasti nella finestra caca per modificare le opzioni di
renderizzazione:
</para>

<informaltable>
<tgroup cols="2">
<thead>
  <row><entry>Chiave</entry><entry>Azione</entry></row>
</thead>
<tbody>
<row><entry><keycap>d</keycap></entry><entry>
  Attiva/disattiva il metodo di dithering di
  <systemitem class="library">libcaca</systemitem>.
</entry></row>
<row><entry><keycap>a</keycap></entry><entry>
  Attiva/disattiva l'antialias di
  <systemitem class="library">libcaca</systemitem>.
</entry></row>
<row><entry><keycap>b</keycap></entry><entry>
  Attiva/disattiva lo sfondo di
  <systemitem class="library">libcaca</systemitem>.
</entry></row>
</tbody>
</tgroup>
</informaltable>

<variablelist>
<title><systemitem class="library">libcaca</systemitem> terrà anche conto di
  alcune variabili d'ambiente:</title>
<varlistentry>
  <term><option>CACA_DRIVER</option></term>
  <listitem><para>
    Imposta il driver caca richiesto. Per es. ncurses, slang, x11.
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>CACA_GEOMETRY (solo X11)</option></term>
  <listitem><para>
    Specifica il numero di righe e colonne. Per es. 128x50.
  </para></listitem>
</varlistentry>
<varlistentry>
  <term><option>CACA_FONT (solo X11)</option></term>
  <listitem><para>
    Specifica il font da usare. Per es. fixed, nexus.
  </para></listitem>
</varlistentry>
</variablelist>

<para>
Usa l'opzione <option>-framedrop</option> se il tuo computer non è abbastanza
veloce per renderizzare tutti i fotogrammi.
</para>

</sect1>

<!-- ********** -->

<sect1 id="vesa">
<title>VESA - uscita attraverso il VESA BIOS</title>

<para>
Questo driver è stato progettato ed introdotto come un
<emphasis role="bold">driver generico</emphasis> per qualsiasi scheda video che
abbia un BIOS compatibile con VESA VBE 2.0. Un altro vantaggio di questo driver
è che cerca di attivare l'uscita TV.
La <citetitle>VESA BIOS EXTENSION (VBE) Versione 3.0 Data: 16 settembre
1998</citetitle> (pagina 70) dice:
</para>

<!-- TODO: try to find an 'official' translation -->
<blockquote>
<formalpara><title>Dual-Controller Designs</title>
<para>
VBE 3.0 supports the dual-controller design by assuming that since both
controllers are typically provided by the same OEM, under control of a
single BIOS ROM on the same graphics card, it is possible to hide the fact
that two controllers are indeed present from the application. This has the
limitation of preventing simultaneous use of the independent controllers,
but allows applications released before VBE 3.0 to operate normally. The
VBE Function 00h (Return Controller Information) returns the combined
information of both controllers, including the combined list of available
modes. When the application selects a mode, the appropriate controller is
activated. Each of the remaining VBE functions then operates on the active
controller.
</para>
</formalpara>
</blockquote>

<para>
Perciò usando questo driver hai qualche possibilità di far funzionare
l'uscita TV (si presume che spesso l'uscita TV sia almeno un'uscita a sè
stante).
</para>

<itemizedlist spacing="compact">
<title>VANTAGGI</title>
<listitem><para>
  Puoi riuscire a guardare film <emphasis role="bold">anche se Linux non
  riconosce</emphasis> il tuo hardware grafico.
</para></listitem>
<listitem><para>
  Non ti serve avere alcuna cosa relativa alla grafica (come X11 (AKA XFree86),
  fbdev e così via) sul tuo Linux. Questo driver può venir utilizzato dalla
  <emphasis role="bold">modalità testo</emphasis>.
</para></listitem>
<listitem><para>
  Hai qualche possibilità di avere l'<emphasis role="bold">uscita TV
  funzionante</emphasis> (per le schede ATI perlomeno è così).
</para></listitem>
<listitem><para>
  Questo driver chiama la funzione <function>int 10h</function> percui non è
  un emulatore - fa riferimento a cose <emphasis role="bold">reali</emphasis>
  del BIOS <emphasis role="bold">reale</emphasis> in 
  <emphasis>modalità reale</emphasis> (attualmente in modalità vm86).
</para></listitem>
<listitem><para>
  Con esso puoi usare VIDIX, potendo ottenere contemporaneamente un'uscita
  video accellerata <emphasis role="bold">e</emphasis> e l'uscita TV!
  (consigliato per schede ATI)
  </para></listitem>
<listitem><para>
  Se hai VESA VBE 3.0+ e hai specificato in qualche dove
  <option>monitor-hfreq, monitor-vfreq, monitor-dotclock</option> (nel file di
  configurazione o dalla riga comando) otterrai la massima frequenza di
  aggiornamento possibile (usando formule generiche di temporizzazione).
  Per abilitare questa funzionalità devi specificare
  <emphasis role="bold">tutte</emphasis> le opzioni per il tuo monitor.
</para></listitem>
</itemizedlist>

<itemizedlist spacing="compact">
<title>SVANTAGGI</title>
<listitem><para>
   Funziona solo su <emphasis role="bold">sistemi x86</emphasis>.
</para></listitem>
<listitem><para>
  Può essere usato solo da <systemitem class="username">root</systemitem>.
</para></listitem>
<listitem><para>
  Attualmente è disponibile solo per <emphasis role="bold">Linux</emphasis>.
</para></listitem>
</itemizedlist>

<important><para>
Non usare questo driver con <emphasis role="bold">GCC 2.96</emphasis>!
Non funzionerà!
</para></important>

<variablelist>
<title>OPZIONI DELLA RIGA COMANDO DISPONIBILI PER VESA</title>
<varlistentry>
  <term><option>-vo vesa:<replaceable>opzioni</replaceable></option></term>
  <listitem><para>
    attualmente riconosciute: <literal>dga</literal> per forzare la modalità
    dga e <literal>nodga</literal> per disabilitarla. In modalità dga puoi
    abilitare il doppio buffering con l'opzione <option>-double</option>.
    Nota: puoi omettere questi parametri per abilitare
    l'<emphasis role="bold">auto-rilevazione</emphasis> della modalità dga.
  </para></listitem>
</varlistentry>
</variablelist>

<itemizedlist spacing="compact">
<title>PROBLEMI CONOSCIUTI E SOLUZIONI</title>
<listitem><para>
  Se hai dei font <emphasis role="bold">NLS</emphasis> installati sulla tua
  macchina Linux ed utilizzi il driver VESA in modalità testo, allora dopo
  essere uscito da<application>MPlayer</application> avrai i
  <emphasis role="bold">font ROM</emphasis> caricati al posto di quelli locali.
  Puoi ricaricare i font locali usando lo strumento
  <command>setsysfont</command> per Mandrake/Mandriva, ad esempio
  (<emphasis role="bold">consiglio</emphasis>: lo stesso strumento viene
  usato per la localizzazione di fbdev).
</para></listitem>
<listitem><para>
  Alcuni <emphasis role="bold">driver grafici per Linux</emphasis> non
  modificano nella memoria DOS la
  <emphasis role="bold">modalità BIOS</emphasis> attiva.
  Per cui se hai questo problema - usa sempre il driver VESA dalla
  <emphasis role="bold">modalità testo</emphasis>. Altrimenti verrà
  comunque attivata la modalità testo (#03) e dovrai riavviare il tuo
  computer.
</para></listitem>
<listitem><para>
  Spesso dopo aver dismesso il driver VESA ottieni uno schermo
  <emphasis role="bold">nero</emphasis>. Per riportare il tuo schermo allo
  stato originario - salta semplicemente ad unìaltra console (premendo
  <keycombo><keycap>Alt</keycap><keycap>F&lt;x&gt;</keycap></keycombo>) poi
  ritorna alla console precedente allo stesso modo.
</para></listitem>
<listitem><para>
  Per avere <emphasis role="bold">l'uscita TV funzionante</emphasis> devi avere
  il connettore TV collegato prima di avviare il tuo PC, visto che il BIOS
  video si inizializza solo una volta durante il passaggio POST.
</para></listitem>
</itemizedlist>
</sect1>

<!-- ********** -->

<sect1 id="x11">
<title>X11</title>

<para>
Avoid if possible. Outputs to X11 (uses shared memory extension), with no
hardware acceleration at all. Supports (MMX/3DNow/SSE accelerated, but
still slow) software scaling, use the options <option>-fs -zoom</option>.
Most cards have hardware scaling support, use the <option>-vo xv</option>
output for them, or <option>-vo xmga</option> for Matrox cards.
</para>

<para>
The problem is that most cards' driver doesn't support hardware
acceleration on the second head/TV. In those cases, you see green/blue
colored window instead of the movie. This is where this driver comes in
handy, but you need powerful CPU to use software scaling. Don't use the SDL
driver's software output+scaler, it has worse image quality!
</para>

<para>
Software scaling is very slow, you better try changing video modes instead.
It's very simple. See the <link linkend="dga-modelines">DGA section's
modelines</link>, and insert them into your <filename>XF86Config</filename>.

<itemizedlist spacing="compact">
<listitem><para>
  If you have XFree86 4.x.x: use the <option>-vm</option> option. It will
  change to a resolution your movie fits in. If it doesn't:
</para></listitem>
<listitem><para>
  With XFree86 3.x.x: you have to cycle through available resolutions
  with the
  <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap><keycap>Keypad +</keycap></keycombo>
  and
  <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap><keycap>Keypad -</keycap></keycombo>
  keys.
</para></listitem>
</itemizedlist>
</para>

<para>
If you can't find the modes you inserted, browse XFree86's output. Some
drivers can't use low pixelclocks that are needed for low resolution
video modes.
</para>
</sect1>

<!-- ********** -->

<sect1 id="vidix">
<title>VIDIX</title>

<formalpara><title>PREAMBLE</title>
<para>
<acronym>VIDIX</acronym> is the abbreviation for
<emphasis role="bold">VID</emphasis>eo
<emphasis role="bold">I</emphasis>nterface
for *ni<emphasis role="bold">X</emphasis>.
VIDIX was designed and introduced as an interface for fast user-space drivers
providing such video performance as mga_vid does for Matrox cards. It's also
very portable.
</para>
</formalpara>

<para>
This interface was designed as an attempt to fit existing video
acceleration interfaces (known as mga_vid, rage128_vid, radeon_vid,
pm3_vid) into a fixed scheme. It provides a high level interface to chips
which are known as BES (BackEnd scalers) or OV (Video Overlays). It doesn't
provide low level interface to things which are known as graphics servers.
(I don't want to compete with X11 team in graphics mode switching). I.e.
main goal of this interface is to maximize the speed of video playback.
</para>

<itemizedlist spacing="compact">
<title>USAGE</title>
<listitem><para>
  You can use standalone video output driver: <option>-vo xvidix</option>.
  This driver was developed as X11's front end to VIDIX technology. It
  requires X server and can work only under X server. Note that, as it directly
  accesses the hardware and circumvents the X driver, pixmaps cached in the
  graphics card's memory may be corrupted. You can prevent this by limiting
  the amount of video memory used by X with the XF86Config option "VideoRam"
  in the device section. You should set this to the amount of memory installed
  on your card minus 4MB. If you have less than 8MB of video ram, you can use
  the option "XaaNoPixmapCache" in the screen section instead.
</para></listitem>
<listitem>
  <para>
  There is a console VIDIX driver: <option>-vo cvidix</option>.
  This requires a working and initialized framebuffer for most cards (or else
  you'll just mess up the screen), and you'll have a similar effect as with
  <option>-vo mga</option> or <option>-vo fbdev</option>. nVidia cards however
  are able to output truly graphical video on a real text console. See the
  <link linkend="vidix-nvidia">nvidia_vid</link> section for more information.
  To get rid of text on the borders and the blinking cursor, try something like
  </para>

  <screen>setterm -cursor off > /dev/tty9</screen>

  <para>
  (assuming <systemitem>tty9</systemitem> is unused so far) and then
  switch to <systemitem>tty9</systemitem>.
  On the other hand, <option>-colorkey 0</option> should give you a video
  running in the "background", though this depends on the colorkey
  functionality to work right.
  </para>
</listitem>
<listitem><para>
  You can use VIDIX subdevice which was applied to several video output
  drivers, such as: <option>-vo vesa:vidix</option>
  (<emphasis role="bold">Linux only</emphasis>) and
  <option>-vo fbdev:vidix</option>.
</para></listitem>
</itemizedlist>

<para>
Indeed it doesn't matter which video output driver is used with
<emphasis role="bold">VIDIX</emphasis>.
</para>

<itemizedlist spacing="compact">
<title>REQUIREMENTS</title>
<listitem><para>
  Video card should be in graphics mode (except nVidia cards with the
  <option>-vo cvidix</option> output driver).
</para></listitem>
<listitem><para>
  <application>MPlayer</application>'s video output driver should know
  active video mode and be able to tell to VIDIX subdevice some video
  characteristics of server.
</para></listitem>
</itemizedlist>

<formalpara><title>USAGE METHODS</title>
<para>
When VIDIX is used as <emphasis role="bold">subdevice</emphasis> (<option>-vo
vesa:vidix</option>) then video mode configuration is performed by video
output device (<emphasis role="bold">vo_server</emphasis> in short). Therefore you can
pass into command line of <application>MPlayer</application> the same keys
as for vo_server. In addition it understands <option>-double</option> key
as globally visible parameter. (I recommend using this key with VIDIX at
least for ATI's card). As for <option>-vo xvidix</option>, currently it
recognizes the following options: <option>-fs -zoom -x -y -double</option>.
</para>
</formalpara>

<para>
Also you can specify VIDIX's driver directly as third subargument in
command line:
<screen>
mplayer -vo xvidix:mga_vid.so -fs -zoom -double <replaceable>file.avi</replaceable>
</screen>
or
<screen>
mplayer -vo vesa:vidix:radeon_vid.so -fs -zoom -double -bpp 32 <replaceable>file.avi</replaceable>
</screen>
But it's dangerous, and you shouldn't do that. In this case given driver
will be forced and result is unpredictable (it may
<emphasis role="bold">freeze</emphasis> your computer). You should do that
ONLY if you are absolutely sure it will work, and
<application>MPlayer</application> doesn't do it automatically. Please tell
about it to the developers. The right way is to use VIDIX without arguments
to enable driver autodetection.
</para>

<para>
Since VIDIX requires direct hardware access you can either run it as root
or set the SUID bit on the <application>MPlayer</application> binary
(<emphasis role="bold">Warning: This is a security risk!</emphasis>).
Alternatively, you can use a special kernel module, like this:
</para>

<procedure>
<step><para>
  Download the
  <ulink url="http://www.arava.co.il/matan/svgalib/">development version</ulink>
  of svgalib (for example 1.9.17), <emphasis role="bold">OR</emphasis>
  download a version made by Alex especially for usage with
  <application>MPlayer</application> (it doesn't need the svgalib source to
  compile) from
  <ulink url="http://www.mplayerhq.hu/MPlayer/contrib/svgalib/svgalib_helper-1.9.17-mplayer.tar.bz2">here</ulink>.
</para></step>
<step><para>
  Compile the module in the
  <filename class="directory">svgalib_helper</filename> directory (it can be
  found inside the
  <filename class="directory">svgalib-1.9.17/kernel/</filename> directory if
  you've downloaded the source from the svgalib site) and insmod it.
</para></step>
<step><para>
  To create the necessary devices in the
  <filename class="directory">/dev</filename> directory, do a
  <screen>make device</screen> in the
  <filename class="directory">svgalib_helper</filename> dir, as root.
</para></step>
<step><para>
  Move the <filename class="directory">svgalib_helper</filename> directory to
  the <filename class="directory">vidix</filename> subdirectory of the
  <application>MPlayer</application> source tree.
</para></step>
<step><para>
  Remove the comment before the CFLAGS line containing the "svgalib_helper"
  string from <filename class="directory">vidix/Makefile</filename>.
</para></step>
<step><para>
  Recompile.
</para></step>
</procedure>


<sect2 id="vidix-ati">
<title>ATI cards</title>

<para>
Currently most ATI cards are supported natively, from Mach64 to the
newest Radeons.
</para>

<para>
There are two compiled binaries: <filename>radeon_vid</filename> for Radeon and
<filename>rage128_vid</filename> for Rage 128 cards. You may force one or let
the VIDIX system autoprobe all available drivers.
</para>
</sect2>


<sect2 id="vidix-mga">
<title>Matrox cards</title>

<para>
Matrox G200, G400, G450 and G550 have been reported to work.
</para>

<para>
The driver supports video equalizers and should be nearly as fast as the
<link linkend="mga_vid">Matrox framebuffer</link>
</para>
</sect2>


<sect2 id="vidix-trident">
<title>Trident cards</title>

<para>
There is a driver available for the Trident Cyberblade/i1 chipset, which
can be found on VIA Epia motherboards.
</para>

<para>
The driver was written and is maintained by
<ulink url="http://www.blackfiveservices.co.uk/EPIAVidix.shtml">Alastair M. Robinson</ulink>.
</para>
</sect2>


<sect2 id="vidix-3dlabs">
<title>3DLabs cards</title>

<para>
Although there is a driver for the 3DLabs GLINT R3 and Permedia3 chips, no one
has tested it, so reports are welcome.
</para>
</sect2>


<sect2 id="vidix-nvidia">
<title>nVidia cards</title>

<para>
An unique feature of the nvidia_vid driver is its ability to display video on
<emphasis role="bold">plain, pure, text-only console</emphasis> - with no
framebuffer or X magic whatsoever. For this purpose, we'll have to use the
<option>cvidix</option> video output, as the following example shows:
<screen>mplayer -vo cvidix <replaceable>example.avi</replaceable></screen>
</para>
</sect2>


<sect2 id="vidix-sis">
<title>SiS cards</title>

<para>
This is very experimental code, just like nvidia_vid.
</para>

<para>
It's been tested on SiS 650/651/740 (the most common chipsets used in the
SiS versions of the "Shuttle XPC" barebones boxes out there)
</para>

<para>
Reports awaited!
</para>
</sect2>
</sect1>

<!-- ********** -->

<sect1 id="directfb">
<title>DirectFB</title>

<blockquote><para>
"DirectFB is a graphics library which was designed with embedded systems
in mind. It offers maximum hardware accelerated performance at a minimum
of resource usage and overhead." - quoted from
<ulink url="http://www.directfb.org"/>
</para></blockquote>

<para>I'll exclude DirectFB features from this section.</para>

<para>
Though <application>MPlayer</application> is not supported as a "video
provider" in DirectFB, this output driver will enable video playback
through DirectFB. It will - of course - be accelerated, on my Matrox G400
DirectFB's speed was the same as XVideo.
</para>

<para>
Always try to use the newest version of DirectFB. You can use DirectFB options
on the command line, using the <option>-dfbopts</option> option. Layer
selection can be done by the subdevice method, e.g.:
<option>-vo directfb:2</option> (layer -1 is default: autodetect)
</para>
</sect1>

<!-- ********** -->

<sect1 id="dfbmga">
<title>DirectFB/Matrox (dfbmga)</title>

<para>
Please read the <link linkend="directfb">main DirectFB</link> section for
general information.
</para>

<para>
This video output driver will enable CRTC2 (on the second head) on Matrox
G400/G450/G550 cards, displaying video
<emphasis role="bold">independent</emphasis> of the first head.
</para>

<para>
Ville Syrjala's has a
<ulink url="http://www.sci.fi/~syrjala/directfb/Matrox_TV-out_README.txt">README</ulink>
and a
<ulink url="http://www.sci.fi/~syrjala/directfb/matrox-tv-out-howto">HOWTO</ulink>
on his homepage that explain how to make DirectFB TV output run on Matrox cards.
</para>

<note><para>
the first DirectFB version with which we could get this working was
0.9.17 (it's buggy, needs that <systemitem>surfacemanager</systemitem>
patch from the URL above). Porting the CRTC2 code to
<link linkend="mga_vid">mga_vid</link> has been planned for years,
<ulink url="../../tech/patches.txt">patches</ulink> are welcome.
</para></note>
</sect1>


<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->


<sect1 id="mpeg_decoders">
<title>MPEG decoders</title>

<sect2 id="dvb">
<title>DVB output and input</title>

<para>
<application>MPlayer</application> supports cards with the Siemens DVB chipset
from vendors like Siemens, Technotrend, Galaxis or Hauppauge. The latest DVB
drivers are available from the
<ulink url="http://www.linuxtv.org">Linux TV site</ulink>.
If you want to do software transcoding you should have at least a 1GHz CPU.
</para>

<para>
Configure should detect your DVB card. If it did not, force detection with
<screen>./configure --enable-dvb</screen>
If you have ost headers at a non-standard path, set the path with
<screen>
./configure --with-extraincdir=<replaceable>DVB source directory</replaceable>/ost/include
</screen>
Then compile and install as usual.</para>

<formalpara><title>USAGE</title>
<para>
Hardware decoding of streams containing MPEG-1/2 video and/or MPEG audio can be done with this
command:
<screen>
mplayer -ao mpegpes -vo mpegpes <replaceable>file.mpg|vob</replaceable>
</screen>
</para>
</formalpara>

<para>
Decoding of any other type of video stream requires transcoding to MPEG-1, thus it's slow
and may not be worth the trouble, especially if your computer is slow.
It can be achieved using a command like this:
<screen>
mplayer -ao mpegpes -vo mpegpes <replaceable>yourfile.ext</replaceable>
mplayer -ao mpegpes -vo mpegpes -vf expand <replaceable>yourfile.ext</replaceable>
</screen></para>

<para>
Note that DVB cards only support heights 288 and 576 for PAL or 240 and 480 for
NTSC. You <emphasis role="bold">must</emphasis> rescale for other heights by
adding <option>scale=width:height</option> with the width and height you want
to the <option>-vf</option> option. DVB cards accept various widths, like 720,
704, 640, 512, 480, 352 etc. and do hardware scaling in horizontal direction,
so you do not need to scale horizontally in most cases.
For a 512x384 (aspect 4:3) MPEG-4 (DivX) try:
<screen>mplayer -ao mpegpes -vo mpegpes -vf scale=512:576</screen>
</para>

<para>
If you have a widescreen movie and you do not want to scale it to full height,
you can use the <option>expand=w:h</option> filter to add black bands. To view a
640x384 MPEG-4 (DivX), try:
<screen>
mplayer -ao mpegpes -vo mpegpes -vf expand=640:576 <replaceable>file.avi</replaceable>
</screen>
</para>

<para>
If your CPU is too slow for a full size 720x576 MPEG-4 (DivX), try downscaling:
<screen>
mplayer -ao mpegpes -vo mpegpes -vf scale=352:576 <replaceable>file.avi</replaceable>
</screen>
</para>

<para>If speed does not improve, try vertical downscaling, too:
<screen>
mplayer -ao mpegpes -vo mpegpes -vf scale=352:288 <replaceable>file.avi</replaceable>
</screen>
</para>

<para>
For OSD and subtitles use the OSD feature of the expand filter. So, instead of
<option>expand=w:h</option> or <option>expand=w:h:x:y</option>, use
<option>expand=w:h:x:y:1</option> (the 5th parameter <option>:1</option>
at the end will enable OSD rendering). You may want to move the image up a bit
to get a bigger black zone for subtitles. You may also want to move subtitles
up, if they are outside your TV screen, use the
<option>-subpos &lt;0-100&gt;</option>
option to adjust this (<option>-subpos 80</option> is a good choice).
</para>

<para>
In order to play non-25fps movies on a PAL TV or with a slow CPU, add the
<option>-framedrop</option> option.
</para>

<para>
To keep the aspect ratio of MPEG-4 (DivX) files and get the optimal scaling
parameters (hardware horizontal scaling and software vertical scaling
while keeping the right aspect ratio), use the new dvbscale filter:
<screen>
for a  4:3 TV: -vf dvbscale,scale=-1:0,expand=-1:576:-1:-1:1
for a 16:9 TV: -vf dvbscale=1024,scale=-1:0,expand=-1:576:-1:-1:1
</screen>
</para>

<formalpara><title>Digital TV (DVB input module)</title>
<para>You can use your DVB card for watching Digital TV.</para>
</formalpara>

<para>
You should have the programs <command>scan</command> and
<command>szap/tzap/czap/azap</command> installed; they are all included in
the drivers package.
</para>

<para>
Verify that your drivers are working properly with a program such as
<ulink url="http://sf.net/projects/dvbtools/"><command>dvbstream</command></ulink>
(that is the base of the DVB input module).
</para>

<para>
Now you should compile a <filename>~/.mplayer/channels.conf</filename>
file, with the syntax accepted by <command>szap/tzap/czap/azap</command>, or
have <command>scan</command> compile it for you.
</para>

<para>
If you have more than one card type (e.g. Satellitar, Terrestrial, Cable and ATSC)
you can save your channels files as
<filename>~/.mplayer/channels.conf.sat</filename>,
<filename>~/.mplayer/channels.conf.ter</filename>,
<filename>~/.mplayer/channels.conf.cbl</filename>,
and <filename>~/.mplayer/channels.conf.atsc</filename>,
respectively, so as to implicitly hint <application>MPlayer</application>
to use these files rather than <filename>~/.mplayer/channels.conf</filename>,
and you only need to specify which card to use.
</para>

<para>
Make sure that you have have <emphasis>only</emphasis> Free to Air
channels in your <filename>channels.conf</filename> file, or
<application>MPlayer</application> will try to skip to the next visible one,
but it may take long if there are many consecutive encrypted channels.
</para>

<para>
In your audio and video fields you can use an extended syntax:
<option>...:pid[+pid]:...</option> (for a maximum of 6 pids each);
in this case <application>MPlayer</application> will include in the
stream all the indicated pids, plus pid 0 (that contains the PAT).
You are encouraged to include in each row the PMT pid for the
corresponding channel (if you know it).
You can also specify 8192, this will select all pids on this frequency
and you can then switch between the programs with TAB.
This might need more bandwidth, though cheap cards always transfer all
channels at least to the kernel so it does not make much of a difference
for these.
Other possible uses are: televideo pid, second audio track, etc.
</para>

<para>
If <application>MPlayer</application> complains frequently about
<screen>Too many video/audio packets in the buffer</screen> or
if you notice a growing desynchronization between audio and
video try to use the libavformat MPEG-TS demuxer by adding
<option>-demuxer lavf -lavfdopts probesize=128</option>
to your command line.
</para>

<para>
To show the first of the channels present in your list, run
<screen>mplayer dvb://</screen>
</para>

<para>
If you want to watch a specific channel, such as R1, run
<screen>mplayer dvb://<replaceable>R1</replaceable></screen>
</para>

<para>
If you have more than one card you also need to specify the number of the card
where the channel is visible (e.g. 2) with the syntax:
<screen>mplayer dvb://<replaceable>2@R1</replaceable></screen>
</para>

<para>
To change channels press the <keycap>h</keycap> (next) and
<keycap>k</keycap> (previous) keys, or use the
<link linkend="osdmenu">OSD menu</link>.
</para>

<para>
If your <filename>~/.mplayer/menu.conf</filename> contains a
<literal>&lt;dvbsel&gt;</literal> entry, such as the one in the example
file <filename>etc/dvb-menu.conf</filename> (that you can use to overwrite
<filename>~/.mplayer/menu.conf</filename>), the main menu will show a
sub-menu entry that will permit you to choose one of the channels present
in your <filename>channels.conf</filename>, possibly preceded by a menu
with the list of cards available if more than one is usable by
<application>MPlayer</application>.
</para>

<para>
If you want to save a program to disk you can use
<screen>
mplayer -dumpfile <replaceable>r1.ts</replaceable> -dumpstream dvb://<replaceable>R1</replaceable>
</screen>
</para>

<para>
If you want to record it in a different format (re-encoding it) instead
you can run a command such as
<screen>
mencoder -o <replaceable>r1.avi</replaceable> -ovc xvid -xvidencopts bitrate=800 \
    -oac mp3lame -lameopts cbr:br=128 -pp=ci dvb://<replaceable>R1</replaceable>
</screen>
</para>

<para>
Read the man page for a list of options that you can pass to the
DVB input module.
</para>

<formalpara><title>FUTURE</title>
<para>
If you have questions or want to hear feature announcements and take part in
discussions on this subject, join our
<ulink url="http://lists.mplayerhq.hu/mailman/listinfo/mplayer-dvb">MPlayer-DVB</ulink>
mailing list. Please remember that the list language is English.
</para>
</formalpara>

<para>
In the future you may expect the ability to display OSD and subtitles using
the native OSD feature of DVB cards, as well as more fluent playback of
non-25fps movies and realtime transcoding between MPEG-2 and MPEG-4 (partial
decompression).
</para>
</sect2>

<!-- ********** -->

<sect2 id="dxr2">
<title>DXR2</title>

<para>
<application>MPlayer</application> supports hardware accelerated playback
with the Creative DXR2 card.
</para>
  
<para>
First of all you will need properly installed DXR2 drivers. You can find
the drivers and installation instructions at the
<ulink url="http://dxr2.sf.net/">DXR2 Resource Center</ulink> site.
</para>

<variablelist><title>USAGE</title>
<varlistentry>
  <term><option>-vo dxr2</option></term>
  <listitem><para>Enable TV output.</para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-vo dxr2:x11</option> or <option>-vo dxr2:xv</option></term>
  <listitem><para>Enable Overlay output in X11.</para></listitem>
</varlistentry>
<varlistentry>
  <term><option>-dxr2 &lt;option1:option2:...&gt;</option></term>
  <listitem><para>
  This option is used to control the DXR2 driver.
  </para></listitem>
</varlistentry>
</variablelist>

<para>
The overlay chipset used on the DXR2 is of pretty bad quality but the
default settings should work for everybody. The OSD may be usable with the
overlay (not on TV) by drawing it in the colorkey. With the default colorkey
settings you may get variable results, usually you will see the colorkey
around the characters or some other funny effect. But if you properly adjust
the colorkey settings you should be able to get acceptable results.
</para>

<para>Please see the man page for available options.</para>
</sect2>

<!-- ********** -->

<sect2 id="dxr3">
<title>DXR3/Hollywood+</title>

<para>
<application>MPlayer</application> supports hardware accelerated playback
with the Creative DXR3 and Sigma Designs Hollywood Plus cards. These cards
both use the em8300 MPEG decoder chip from Sigma Designs.
</para>

<para>
First of all you will need properly installed DXR3/H+ drivers, version 0.12.0
or later. You can find the drivers and installation instructions at the
<ulink url="http://dxr3.sf.net/">DXR3 &amp; Hollywood Plus for Linux</ulink>
site. <filename>configure</filename> should detect your card automatically,
compilation should go without problems.
</para>

<!-- FIXME: find a more clear presentation -->
<variablelist>
<title>USAGE</title>
<varlistentry>
<term><option>-vo dxr3:prebuf:sync:norm=x:<replaceable>device</replaceable></option></term>
<listitem><para>
<option>overlay</option> activates the overlay instead of TVOut. It requires
that you have a properly configured overlay setup to work right. The easiest
way to configure the overlay is to first run autocal. Then run mplayer with
dxr3 output and without overlay turned on, run dxr3view. In dxr3view you can
tweak the overlay settings and see the effects in realtime, perhaps this feature
will be supported by the <application>MPlayer</application> GUI in the future.
When overlay is properly set up you will no longer need to use dxr3view.
<option>prebuf</option> turns on prebuffering. Prebuffering is a feature of the
em8300 chip that enables it to hold more than one frame of video at a time.
This means that when you are running with prebuffering
<application>MPlayer</application> will try to keep the video buffer filled
with data at all times.
If you are on a slow machine <application>MPlayer</application> will probably
use close to, or precisely 100% of CPU.
This is especially common if you play pure MPEG streams
(like DVDs, SVCDs a.s.o.) since <application>MPlayer</application> will not have
to reencode it to MPEG it will fill the buffer very fast.
With prebuffering video playback is <emphasis role="bold">much</emphasis>
less sensitive to other programs hogging the CPU, it will not drop frames unless
applications hog the CPU for a long time.
When running without prebuffering the em8300 is much more sensitive to CPU load,
so it is highly suggested that you turn on <application>MPlayer</application>'s
<option>-framedrop</option> option to avoid further loss of sync.
<option>sync</option> will turn on the new sync-engine. This is currently an
experimental feature. With the sync feature turned on the em8300's internal
clock will be monitored at all times, if it starts to deviate from
<application>MPlayer</application>'s clock it will be reset causing the em8300
to drop any frames that are lagging behind.
<option>norm=x</option> will set the TV norm of the DXR3 card without the need
for external tools like em8300setup. Valid norms are 5 = NTSC, 4 = PAL-60,
3 = PAL. Special norms are 2 (auto-adjust using PAL/PAL-60) and 1 (auto-adjust
using PAL/NTSC) because they decide which norm to use by looking at the frame
rate of the movie. norm = 0 (default) does not change the current norm.
<option><replaceable>device</replaceable></option> = device number to use if
you have more than one em8300 card. Any of these options may be left out.
<option>:prebuf:sync</option> seems to work great when playing MPEG-4 (DivX)
movies. People have reported problems using the prebuf option when playing
MPEG-1/2 files.
You might want to try running without any options first, if you have sync
problems, or DVD subtitle problems, give <option>:sync</option> a try.
</para></listitem>
</varlistentry>

<varlistentry>
  <term><option>-ao oss:/dev/em8300_ma-<replaceable>X</replaceable></option></term>
  <listitem><para>
  For audio output, where <replaceable>X</replaceable> is the device number
  (0 if one card).
  </para></listitem>
</varlistentry>

<varlistentry>
  <term><option>-af resample=<replaceable>xxxxx</replaceable></option></term>
  <listitem><para>
  The em8300 cannot play back samplerates lower than 44100Hz. If the sample
  rate is below 44100Hz select either 44100Hz or 48000Hz depending on which
  one matches closest. I.e. if the movie uses 22050Hz use 44100Hz as
  44100 / 2 = 22050, if it is 24000Hz use 48000Hz as 48000 / 2 = 24000
  and so on.
  This does not work with digital audio output (<option>-ac hwac3</option>).
  </para></listitem>
</varlistentry>

<varlistentry>
  <term><option>-vf lavc</option></term>
  <listitem><para>
  To watch non-MPEG content on the em8300 (i.e. MPEG-4 (DivX) or RealVideo)
  you have to specify an MPEG-1 video filter such as
  <systemitem class="library">libavcodec</systemitem> (lavc).
  See the man page for further info about <option>-vf lavc</option>.
  Currently there is no way of setting the fps of the em8300 which means that
  it is fixed to 30000/1001 fps.
  Because of this it is highly recommended that you use
  <option>-vf lavc=<replaceable>quality</replaceable>:25</option>
  especially if you are using prebuffering. Then why 25 and not 30000/1001?
  Well, the thing is that when you use 30000/1001 the picture becomes a bit
  jumpy.
  The reason for this is unknown to us.
  If you set it to somewhere between 25 and 27 the picture becomes stable.
  For now all we can do is accept this for a fact.
  </para></listitem>
</varlistentry>

<varlistentry>
  <term><option>-vf expand=-1:-1:-1:-1:1</option></term>
  <listitem><para>
  Although the DXR3 driver can put some OSD onto the MPEG-1/2/4 video, it has
  much lower quality than <application>MPlayer</application>'s traditional OSD,
  and has several refresh problems as well. The command line above will firstly
  convert the input video to MPEG-4 (this is mandatory, sorry), then apply an
  expand filter which won't expand anything (-1: default), but apply the normal
  OSD onto the picture (that's what the "1" at the end does).
  </para></listitem>
</varlistentry>

<varlistentry>
  <term><option>-ac hwac3</option></term>
  <listitem><para>
  The em8300 supports playing back AC3 audio (surround sound) through the
  digital audio output of the card. See the <option>-ao oss</option> option
  above, it must be used to specify the DXR3's output instead of a sound card.
  </para></listitem>
</varlistentry>
</variablelist>
</sect2>
</sect1>


<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->


<sect1 id="other">
<title>Other visualization hardware</title>

<sect2 id="zr">
<title>Zr</title>

<para>
This is a display-driver (<option>-vo zr</option>) for a number of MJPEG
capture/playback cards (tested for DC10+ and Buz, and it should work for the
LML33, the DC10). The driver works by encoding the frame to JPEG and then
sending it to the card. For the JPEG encoding
<systemitem class="library">libavcodec</systemitem>
is used, and required. With the special <emphasis>cinerama</emphasis> mode,
you can watch movies in true wide screen provided that you have two beamers
and two MJPEG cards. Depending on resolution and quality settings, this driver
may require a lot of CPU power, remember to specify <option>-framedrop</option>
if your machine is too slow. Note: My AMD K6-2 350MHz is (with
<option>-framedrop</option>) quite adequate for watching VCD sized material and
downscaled movies.
</para>

<para>
This driver talks to the kernel driver available at
<ulink url="http://mjpeg.sf.net"/>, so
you must get it working first. The presence of an MJPEG card is autodetected by
the <filename>configure</filename> script, if autodetection fails, force
detection with
<screen>./configure --enable-zr</screen>
</para>

<para>
The output can be controlled by several options, a long description of the
options can be found in the man page, a short list of options can be viewed
by running
<screen>mplayer -zrhelp</screen>
</para>

<para>
Things like scaling and the OSD (on screen display) are not handled by
this driver but can be done using the video filters. For example, suppose
that you have a movie with a resolution of 512x272 and you want to view it
fullscreen on your DC10+. There are three main possibilities, you may scale
the movie to a width of 768, 384 or 192. For performance and quality reasons,
I would choose to scale the movie to 384x204 using the fast bilinear software
scaler. The command line is
<screen>
mplayer -vo zr -sws 0 -vf scale=384:204 <replaceable>movie.avi</replaceable>
</screen>
</para>

<para>
Cropping can be done by the <option>crop</option> filter and by this
driver itself. Suppose that a movie is too wide for display on your Buz and
that you want to use <option>-zrcrop</option> to make the movie less wide,
then you would issue the following command
<screen>
mplayer -vo zr -zrcrop 720x320+80+0 <replaceable>benhur.avi</replaceable>
</screen>
</para>

<para>
if you want to use the <option>crop</option> filter, you would do
<screen>
mplayer -vo zr -vf crop=720:320:80:0 <replaceable>benhur.avi</replaceable>
</screen>
</para>

<para>
Extra occurrences of <option>-zrcrop</option> invoke
<emphasis>cinerama</emphasis> mode, i.e. you can distribute the movie over
several TV's or beamers to create a larger screen.
Suppose you have two beamers. The left one is connected to your
Buz at <filename>/dev/video1</filename> and the right one is connected to
your DC10+ at <filename>/dev/video0</filename>. The movie has a resolution
of 704x288. Suppose also that you want the right beamer in black and white and
that the left beamer should have JPEG frames at quality 10, then you would
issue the following command
<screen>
mplayer -vo zr -zrdev /dev/video0 -zrcrop 352x288+352+0 -zrxdoff 0 -zrbw \
    -zrcrop 352x288+0+0 -zrdev /dev/video1 -zrquality 10 \
	<replaceable>movie.avi</replaceable>
</screen>
</para>

<para>
You see that the options appearing before the second <option>-zrcrop</option>
only apply to the DC10+ and that the options after the second
<option>-zrcrop</option> apply to the Buz. The maximum number of MJPEG cards
participating in <emphasis>cinerama</emphasis> is four, so you can build a
2x2 vidiwall.
</para>

<para>
Finally an important remark: Do not start or stop XawTV on the playback device
during playback, it will crash your computer. It is, however, fine to
<emphasis role="bold">FIRST</emphasis> start XawTV,
<emphasis role="bold">THEN</emphasis> start <application>MPlayer</application>,
wait for <application>MPlayer</application>
to finish and <emphasis role="bold">THEN</emphasis> stop XawTV.
</para>
</sect2>

<!-- ********** -->

<sect2 id="blinkenlights">
<title>Blinkenlights</title>

<para>
This driver is capable of playback using the Blinkenlights UDP protocol. If you
don't know what <ulink url="http://www.blinkenlights.de/">Blinkenlights</ulink>
or its successor
<ulink url="http://www.blinkenlights.de/arcade/">Arcade</ulink>
are, find it out. Although this is most probably the least used video output
driver, without a doubt it is the coolest <application>MPlayer</application>
has to offer. Just watch some of the
<ulink url="http://www.blinkenlights.de/video.en.html">Blinkenlights documentation videos</ulink>.
On the Arcade video you can see the Blinkenlights output driver in
action at 00:07:50.
</para>
</sect2>
</sect1>


<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->


<sect1 id="tvout">
<title>TV-out support</title>

<sect2 id="tvout-mga-g400">
<title>Matrox G400 cards</title>

<para>
Under Linux you have two methods to get G400 TV out working:
</para>

<important>
<para>
for Matrox G450/G550 TV-out instructions, please see the next section!
</para>
</important>

<variablelist>
<varlistentry>
  <term>XFree86</term>
  <listitem>
    <para>
    Using the driver and the HAL module, available from the <ulink
    url="http://www.matrox.com">Matrox site</ulink>. This will give you X
    on the TV.
    </para>
    <para>
    <emphasis role="bold">This method doesn't give you accelerated playback</emphasis>
    as under Windows! The second head has only YUV framebuffer, the
    <emphasis>BES</emphasis> (Back End Scaler, the YUV scaler on
    G200/G400/G450/G550 cards) doesn't work on it! The windows driver somehow
    workarounds this, probably by using the 3D engine to zoom, and the YUV
    framebuffer to display the zoomed image. If you really want to use X, use
    the <option>-vo x11 -fs -zoom</option> options, but it will be
    <emphasis role="bold">SLOW</emphasis>, and has
    <emphasis role="bold">Macrovision</emphasis> copy protection enabled
    (you can "workaround" Macrovision using this
    <ulink url="http://avifile.sf.net/mgamacro.pl">perl script</ulink>).
    </para>
  </listitem>
</varlistentry>
<varlistentry>
  <term>Framebuffer</term>
  <listitem>
    <para>
    Using the <emphasis role="bold">matroxfb modules</emphasis> in the 2.4
    kernels. 2.2 kernels don't have the TVout feature in them, thus unusable
    for this. You have to enable ALL matroxfb-specific feature during
    compilation (except MultiHead), and compile them into
    <emphasis role="bold">modules</emphasis>!
    You'll also need I2C enabled.
    </para>

    <procedure>
    <step><para>
      Enter <filename class="directory">TVout</filename> and type
      <command>./compile.sh</command>. Install
      <filename>TVout/matroxset/matroxset</filename>
      somewhere into your <envar>PATH</envar>.
    </para></step>
    <step><para>
      If you don't have <command>fbset</command> installed, put
      <filename>TVout/fbset/fbset</filename>
      somewhere into your <envar>PATH</envar>.
    </para></step>
    <step><para>
      If you don't have <command>con2fb</command> installed, put
      <filename>TVout/con2fb/con2fb</filename>
      somewhere into your <envar>PATH</envar>.
    </para></step>
    <step><para>
      Then enter into the <filename class="directory">TVout/</filename>
      directory in the <application>MPlayer</application> source, and execute
      <filename>./modules</filename> as root. Your text-mode console will
      enter into framebuffer mode (no way back!).
    </para></step>
    <step><para>
      Next, EDIT and run the <filename>./matroxtv</filename> script. This will
      present you to a very simple menu. Press <keycap>2</keycap> and
      <keycap>Enter</keycap>. Now you should have the same picture on your
      monitor, and TV. If the TV (PAL by default)
      picture has some weird stripes on it, the script wasn't able to set the
      resolution correctly (to 640x512 by default). Try other resolutions
      from the menu and/or experiment with fbset.
    </para></step>
    <step><para>
      Yoh. Next task is to make the cursor on tty1 (or whatever) to
      disappear, and turn off screen blanking. Execute the following
      commands:

      <screen>
echo -e '\033[?25l'
setterm -blank 0<!--
   --></screen>
      or
      <screen>
setterm -cursor off
setterm -blank 0<!--
   --></screen>

      You possibly want to put the above into a script, and also clear the
      screen. To turn the cursor back:
      <screen>echo -e '\033[?25h'</screen> or
      <screen>setterm -cursor on</screen>
    </para></step>
    <step><para>
      Yeah kewl. Start movie playing with
      <screen>
mplayer -vo mga -fs -screenw 640 -screenh 512 <replaceable>filename</replaceable><!--
   --></screen>

      (If you use X, now change to matroxfb with for example
      <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap><keycap>F1</keycap></keycombo>.)
      Change <literal>640</literal> and <literal>512</literal> if you set
      the resolution to other...
    </para></step>
    <step><para>
      <emphasis role="bold">Enjoy the ultra-fast ultra-featured Matrox TV
      output (better than Xv)!</emphasis>
    </para></step>
    </procedure>
  </listitem>
</varlistentry>
</variablelist>

<formalpara><title>Building a Matrox TV-out cable</title>
<para>
No one takes any responsibility, nor guarantee for any damage caused
by this documentation.
</para>
</formalpara>

<formalpara><title>Cable for G400</title>
<para>
The CRTC2 connector's fourth pin is the composite video signal. The
ground are the sixth, seventh and eighth pins. (info contributed
from Balázs Rácz)
</para>
</formalpara>

<formalpara><title>Cable for G450</title>
<para>
The CRTC2 connector's first pin is the composite video signal. The
ground are the fifth, sixth, seventh, and fifteenth (5, 6, 7, 15)
pins. (info contributed from Balázs Kerekes)
</para>
</formalpara>
</sect2>

<!-- ********** -->

<sect2 id="tv-out_matrox_g450">
<title>Matrox G450/G550 cards</title>

<para>
TV output support for these cards has only been recently introduced, and is
not yet in the mainstream kernel.
Currently the <emphasis role="bold">mga_vid</emphasis> module can't be used
AFAIK, because the G450/G550 driver works only in one configuration: the first
CRTC chip (with much more features) on the first display (on monitor),
and the second CRTC (no <emphasis role="bold">BES</emphasis> - for
explanation on BES, please see the G400 section above) on TV. So you can only
use <application>MPlayer</application>'s <emphasis>fbdev</emphasis> output
driver at the present.
</para>

<para>
The first CRTC can't be routed to the second head currently. The author of the
kernel matroxfb driver - Petr Vandrovec - will maybe make support for this, by
displaying the first CRTC's output onto both of the heads at once, as currently
recommended for G400, see the section above.
</para>

<para>
The necessary kernel patch and the detailed HOWTO is downloadable from
<ulink url="http://www.bglug.ca/matrox_tvout/"/>
</para>
</sect2>

<!-- ********** -->

<sect2 id="tvout-ati">
<title>ATI cards</title>

<formalpara><title>PREAMBLE</title>
<para>
Currently ATI doesn't want to support any of its TV-out chips under Linux,
because of their licensed Macrovision technology.
</para>
</formalpara>

<itemizedlist>
<title>ATI CARDS TV-OUT STATUS ON LINUX</title>
<listitem><para>
  <emphasis role="bold">ATI Mach64</emphasis>:
  supported by <ulink url="http://gatos.sf.net">GATOS</ulink>.
</para></listitem>
<listitem><para>
  <emphasis role="bold">ASIC Radeon VIVO</emphasis>:
  supported by <ulink url="http://gatos.sf.net">GATOS</ulink>.
</para></listitem>
<listitem><para>
  <emphasis role="bold">Radeon</emphasis> and <emphasis role="bold">Rage128</emphasis>:
  supported by <application>MPlayer</application>!
  Check <link linkend="vesa">VESA driver</link> and
  <link linkend="vidix">VIDIX</link> sections.
</para></listitem>
<listitem><para>
  <emphasis role="bold">Rage Mobility P/M, Radeon, Rage 128, Mobility M3/M4</emphasis>:
  supported by
  <ulink url="http://www.stud.uni-hamburg.de/users/lennart/projects/atitvout/">atitvout</ulink>.
</para></listitem>
</itemizedlist>

<para>
On other cards, just use the <link linkend="vesa">VESA</link> driver,
without VIDIX. Powerful CPU is needed, though.
</para>

<para>
Only thing you need to do - <emphasis role="bold">Have the TV connector
plugged in before booting your PC</emphasis> since video BIOS initializes
itself only once during POST procedure.
</para>
</sect2>

<!-- ********** -->

<sect2 id="tvout-nvidia">
<title>nVidia</title>

<para>
First, you MUST download the closed-source drivers from
<ulink url="http://nvidia.com"/>.
I will not describe the installation and configuration process because it does
not cover the scope of this documentation.
</para>

<para>
After XFree86, XVideo, and 3D acceleration is properly working, edit your
card's Device section in the <filename>XF86Config</filename> file, according
to the following example (adapt for your card/TV):

<programlisting>
Section "Device"
        Identifier      "GeForce"
        VendorName      "ASUS"
        BoardName       "nVidia GeForce2/MX 400"
        Driver          "nvidia"
        #Option         "NvAGP" "1"
        Option          "NoLogo"
        Option          "CursorShadow"  "on"

        Option          "TwinView"
        Option          "TwinViewOrientation" "Clone"
        Option          "MetaModes" "1024x768,640x480"
        Option          "ConnectedMonitor" "CRT, TV"
        Option          "TVStandard" "PAL-B"
        Option          "TVOutFormat" "Composite"
EndSection
</programlisting>
</para>

<para>
Of course the important thing is the TwinView part.
</para>
</sect2>

<!-- ********** -->

<sect2 id="tvout-neomagic">
<title>NeoMagic</title>

<para>
The NeoMagic chip is found in a variety of laptops, some of them are equipped
with a simple analog TV encoder, some have a more advanced one.
<itemizedlist>
<listitem><para>
  <emphasis role="bold">Analog encoder chip</emphasis>:
  It has been reported that reliable TV out can be obtained by using
  <option>-vo fbdev</option> or <option>-vo fbdev2</option>.
  You need to have vesafb compiled in your kernel and pass
  the following parameters on the kernel command line:
  <option>append="video=vesafb:ywrap,mtrr" vga=791</option>.
  You should start <application>X</application>, then switch to console mode
  with e.g.
  <keycombo><keycap>Ctrl</keycap><keycap>Alt</keycap><keycap>F1</keycap></keycombo>.
  If you fail to start <application>X</application> before running
  <application>MPlayer</application> from the console, the video
  becomes slow and choppy (explanations are welcome).
  Login to your console, then initiate the following command:

  <screen>clear; mplayer -vo fbdev -zoom -cache 8192 dvd://</screen>

  Now you should see the movie running in console mode filling up about
  half your laptop's LCD screen. To switch to TV hit
  <keycombo><keycap>Fn</keycap><keycap>F5</keycap></keycombo> three times.
  Tested on a Tecra 8000, 2.6.15 kernel with vesafb, ALSA v1.0.10.
</para></listitem>
<listitem>
  <para>
  <emphasis role="bold">Chrontel 70xx encoder chip</emphasis>:
  Found in IBM Thinkpad 390E and possibly other Thinkpads or notebooks.
  </para><para>
  You must use <option>-vo vesa:neotv_pal</option> for PAL or
  <option>-vo vesa:neotv_ntsc</option> for NTSC.
  It will provide TV output function in the following 16 bpp and 8 bpp modes:
  </para>
  <itemizedlist>
    <listitem><para>NTSC 320x240, 640x480 and maybe 800x600 too.</para></listitem>
    <listitem><para>PAL  320x240, 400x300, 640x480, 800x600.</para></listitem>
  </itemizedlist>
  <para>Mode 512x384 is not supported in BIOS. You must scale the image
  to a different resolution to activate TV out. If you can see an image on the
  screen in 640x480 or in 800x600 but not in 320x240 or other smaller
  resolution you need to replace two tables in <filename>vbelib.c</filename>.
  See the vbeSetTV function for details. Please contact the author in this case.
  </para>
  <para>
  Known issues: VESA-only, no other controls such as brightness, contrast,
  blacklevel, flickfilter are implemented.
  </para>
</listitem>
</itemizedlist>
</para>
</sect2>
</sect1>

</chapter>
