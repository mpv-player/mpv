/*
 * Copyright (c) 2008 Georgi Petrov (gogothebee) <gogothebee@gmail.com>
 *
 * This file is part of MPlayer.
 *
 * MPlayer is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * MPlayer is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with MPlayer; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <windows.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <stdbool.h>
#include <assert.h>
#include <d3d9.h>
#include "config.h"
#include "options.h"
#include "subopt-helper.h"
#include "talloc.h"
#include "video_out.h"
#include "libmpcodecs/vfcap.h"
// for global_vo
#include "old_vo_wrapper.h"
#include "csputils.h"
#include "libmpcodecs/mp_image.h"
#include "libmpcodecs/img_format.h"
#include "fastmemcpy.h"
#include "mp_msg.h"
#include "aspect.h"
#include "w32_common.h"
#include "libavutil/common.h"
#include "sub/font_load.h"
#include "sub/sub.h"
#include "eosd_packer.h"

// shaders generated by fxc.exe from d3d_shader_yuv.hlsl
#include "d3d_shader_yuv.h"
#include "d3d_shader_yuv_2ch.h"


// TODO: beg someone to add this (there is already IMGFMT_Y8)
// equals MAKEFOURCC('Y', '1', '6', ' ')
#define IMGFMT_Y16 0x20363159
#define IMGFMT_A8Y8 MAKEFOURCC('A', '8', 'Y', '8')

#define IMGFMT_IS_Y(x) ((x) == IMGFMT_Y8 || (x) == IMGFMT_Y16 || (x) == IMGFMT_A8Y8)
#define IMGFMT_Y_DEPTH(x) ((x) == IMGFMT_Y8 ? 8 : 16)

#define DEVTYPE D3DDEVTYPE_HAL
//#define DEVTYPE D3DDEVTYPE_REF


#define D3DFVF_OSD_VERTEX (D3DFVF_XYZ | D3DFVF_TEX1)

typedef struct {
    float x, y, z;      /* Position of vertex in 3D space */
    float tu, tv;       /* Texture coordinates */
} vertex_osd;

#define D3DFVF_EOSD_VERTEX (D3DFVF_XYZ | D3DFVF_TEX1 | D3DFVF_DIFFUSE)

typedef struct {
    float x, y, z;
    D3DCOLOR color;
    float tu, tv;
} vertex_eosd;

#define D3DFVF_VIDEO_VERTEX (D3DFVF_XYZ | D3DFVF_TEX3)

typedef struct {
    float x, y, z;
    // pairs of texture coordinates for up to 3 planes
    float t[3][2];
} vertex_video;


struct d3dtex {
    // user-requested size
    int w, h;
    // allocated texture size
    int tex_w, tex_h;
    // D3DPOOL_SYSTEMMEM (or others) texture:
    // - can be locked in order to write (and even read) data
    // - can _not_ (probably) be used as texture for rendering
    // This is always non-NULL if d3dtex_allocate succeeds.
    IDirect3DTexture9 *system;
    // D3DPOOL_DEFAULT texture:
    // - can't be locked (Probably.)
    // - must be used for rendering
    // This will be NULL on systems with device_texture_sys != 0.
    IDirect3DTexture9 *device;
};

struct texplane {
    int bytes_per_pixel;
    int bits_per_pixel;
    // chroma shifts
    // e.g. get the plane's width in pixels with (priv->src_width >> shift_x)
    int shift_x, shift_y;
    D3DFORMAT d3d_format;
    struct d3dtex texture;
    // temporary locking during uploading the frame (e.g. for draw_slice)
    D3DLOCKED_RECT locked_rect;
    // value used to clear the image with memset (YUV chroma planes do not use
    // the value 0 for this)
    uint8_t clearval;
};

/* Global variables "priv" structure. I try to keep their count low.
 */
typedef struct d3d_priv {
    int opt_prefer_stretchrect;
    int opt_disable_textures;
    int opt_disable_stretchrect;
    int opt_disable_shaders;
    int opt_only_8bit;
    int opt_disable_eosd;
    int opt_disable_texture_align;
    // debugging
    int opt_force_power_of_2;
    int opt_texture_memory;
    int opt_swap_discard;
    int opt_exact_backbuffer;
    int opt_16bit_textures;

    struct vo *vo;

    int is_clear_needed;        /**< 1 = Clear the backbuffer before StretchRect
                                0 = (default) Don't clear it */
    D3DLOCKED_RECT locked_rect; /**< The locked offscreen surface */
    RECT fs_movie_rect;         /**< Rect (upscaled) of the movie when displayed
                                in fullscreen */
    RECT fs_panscan_rect;       /**< PanScan source surface cropping in
                                fullscreen */
    int src_width;              /**< Source (movie) width */
    int src_height;             /**< Source (movie) heigth */
    int src_d_width;            /**< Source (movie) aspect corrected width */
    int src_d_height;           /**< Source (movie) aspect corrected heigth */
    int border_x;               /**< horizontal border value for OSD */
    int border_y;               /**< vertical border value for OSD */
    int image_format;           /**< mplayer image format */
    bool use_textures;          /**< use 3D texture rendering, instead of
                                StretchRect */
    bool use_shaders;           /**< use shader for YUV color conversion
                                (or possibly for RGB video equalizers) */
    bool use_2ch_hack;          /**< 2 byte YUV formats use 2 channel hack */

    int plane_count;
    struct texplane planes[3];

    IDirect3DPixelShader9 *pixel_shader;
    const BYTE *pixel_shader_data;

    D3DFORMAT movie_src_fmt;        /**< Movie colorspace format (depends on
                                    the movie's codec) */
    D3DFORMAT desktop_fmt;          /**< Desktop (screen) colorspace format.
                                    Usually XRGB */

    HANDLE d3d9_dll;                /**< d3d9 Library HANDLE */
    IDirect3D9 * (WINAPI *pDirect3DCreate9)(UINT); /**< pointer to Direct3DCreate9 function */

    LPDIRECT3D9        d3d_handle;  /**< Direct3D Handle */
    LPDIRECT3DDEVICE9  d3d_device;  /**< The Direct3D Adapter */
    bool d3d_in_scene;              /**< BeginScene was called, EndScene not */
    IDirect3DSurface9 *d3d_surface; /**< Offscreen Direct3D Surface. MPlayer
                                    renders inside it. Uses colorspace
                                    priv->movie_src_fmt */
    struct d3dtex texture_osd;      /**< RGBA */
    IDirect3DSurface9 *d3d_backbuf; /**< Video card's back buffer (used to
                                    display next frame) */
    struct d3dtex texture_eosd;     /**< A8 */
    int cur_backbuf_width;          /**< Current backbuffer width */
    int cur_backbuf_height;         /**< Current backbuffer height */
    int is_osd_populated;           /**< 1 = OSD texture has something to display,
                                    0 = OSD texture is clear */
    int device_caps_power2_only;    /**< 1 = texture sizes have to be power 2
                                    0 = texture sizes can be anything */
    int device_caps_square_only;    /**< 1 = textures have to be square
                                    0 = textures do not have to be square */
    int device_texture_sys;         /**< 1 = device can texture from system memory
                                    0 = device requires shadow */
    int max_texture_width;          /**< from the device capabilities */
    int max_texture_height;         /**< from the device capabilities */

    D3DMATRIX d3d_colormatrix;
    float d3d_depth_vector[4];
    struct mp_csp_details colorspace;
    struct mp_csp_equalizer video_eq;

    struct eosd_packer *eosd;       /**< EOSD packer (image positions etc.) */
    vertex_eosd *eosd_vb;           /**< temporary memory for D3D when rendering EOSD */
} d3d_priv;

struct fmt_entry {
    const unsigned int  mplayer_fmt;   /**< Given by MPlayer */
    const D3DFORMAT     fourcc;        /**< Required by D3D's test function */
};

/* Map table from reported MPlayer format to the required
   fourcc. This is needed to perform the format query. */

static const struct fmt_entry fmt_table[] = {
    // planar YUV
    {IMGFMT_YV12,  MAKEFOURCC('Y','V','1','2')},
    {IMGFMT_I420,  MAKEFOURCC('I','4','2','0')},
    {IMGFMT_IYUV,  MAKEFOURCC('I','Y','U','V')},
    {IMGFMT_YVU9,  MAKEFOURCC('Y','V','U','9')},
    // packed YUV
    {IMGFMT_YUY2,  D3DFMT_YUY2},
    {IMGFMT_UYVY,  D3DFMT_UYVY},
    // packed RGB
    {IMGFMT_BGR32, D3DFMT_X8R8G8B8},
    {IMGFMT_RGB32, D3DFMT_X8B8G8R8},
    {IMGFMT_BGR24, D3DFMT_R8G8B8}, //untested
    {IMGFMT_BGR16, D3DFMT_R5G6B5},
    {IMGFMT_BGR15, D3DFMT_X1R5G5B5},
    {IMGFMT_BGR8 , D3DFMT_R3G3B2}, //untested
    // grayscale (can be considered both packed and planar)
    {IMGFMT_Y8,    D3DFMT_L8},
    {IMGFMT_Y16,   D3DFMT_L16},
    {IMGFMT_A8Y8,  D3DFMT_A8L8},
    {0},
};


static void generate_eosd(d3d_priv *priv, mp_eosd_images_t *);
static void draw_eosd(d3d_priv *priv);
static void update_colorspace(d3d_priv *priv);
static void d3d_clear_video_textures(d3d_priv *priv);
static bool resize_d3d(d3d_priv *priv);
static uint32_t d3d_draw_frame(d3d_priv *priv);
static int draw_slice(struct vo *vo, uint8_t *src[], int stride[], int w, int h,
                      int x, int y);
static void uninit(struct vo *vo);
static void draw_osd(struct vo *vo, struct osd_state *osd);
static void flip_page(struct vo *vo);
static mp_image_t *get_screenshot(d3d_priv *priv);
static mp_image_t *get_window_screenshot(d3d_priv *priv);


static void d3d_matrix_identity(D3DMATRIX *m)
{
    memset(m, 0, sizeof(D3DMATRIX));
    m->_11 = m->_22 = m->_33 = m->_44 = 1.0f;
}

static void d3d_matrix_ortho(D3DMATRIX *m, float left, float right,
                             float bottom, float top)
{
    d3d_matrix_identity(m);
    m->_11 = 2.0f / (right - left);
    m->_22 = 2.0f / (top - bottom);
    m->_33 = 1.0f;
    m->_41 = -(right + left) / (right - left);
    m->_42 = -(top + bottom) / (top - bottom);
    m->_43 = 0;
    m->_44 = 1.0f;
}

/****************************************************************************
 *                                                                          *
 *                                                                          *
 *                                                                          *
 * Direct3D specific implementation functions                               *
 *                                                                          *
 *                                                                          *
 *                                                                          *
 ****************************************************************************/

static bool d3d_begin_scene(d3d_priv *priv)
{
    if (!priv->d3d_in_scene) {
        if (FAILED(IDirect3DDevice9_BeginScene(priv->d3d_device))) {
            mp_msg(MSGT_VO, MSGL_ERR, "<vo_direct3d>BeginScene failed.\n");
            return false;
        }
        priv->d3d_in_scene = true;
    }
    return true;
}

/** @brief Calculate scaled fullscreen movie rectangle with
 *  preserved aspect ratio.
 */
static void calc_fs_rect(d3d_priv *priv)
{
    struct vo_rect src_rect;
    struct vo_rect dst_rect;
    struct vo_rect borders;
    calc_src_dst_rects(priv->vo, priv->src_width, priv->src_height, &src_rect,
                       &dst_rect, &borders, NULL);

    priv->fs_movie_rect.left     = dst_rect.left;
    priv->fs_movie_rect.right    = dst_rect.right;
    priv->fs_movie_rect.top      = dst_rect.top;
    priv->fs_movie_rect.bottom   = dst_rect.bottom;
    priv->fs_panscan_rect.left   = src_rect.left;
    priv->fs_panscan_rect.right  = src_rect.right;
    priv->fs_panscan_rect.top    = src_rect.top;
    priv->fs_panscan_rect.bottom = src_rect.bottom;
    priv->border_x               = borders.left;
    priv->border_y               = borders.top;

    mp_msg(MSGT_VO, MSGL_V,
           "<vo_direct3d>Video rectangle: t: %ld, l: %ld, r: %ld, b:%ld\n",
           priv->fs_movie_rect.top,   priv->fs_movie_rect.left,
           priv->fs_movie_rect.right, priv->fs_movie_rect.bottom);

    /* The backbuffer should be cleared before next StretchRect. This is
     * necessary because our new draw area could be smaller than the
     * previous one used by StretchRect and without it, leftovers from the
     * previous frame will be left. */
    priv->is_clear_needed = 1;
}

// Adjust the texture size *width/*height to fit the requirements of the D3D
// device. The texture size is only increased.
static void d3d_fix_texture_size(d3d_priv *priv, int *width, int *height)
{
    int tex_width = *width;
    int tex_height = *height;

    // avoid nasty special cases with 0-sized textures and texture sizes
    tex_width = FFMAX(tex_width, 1);
    tex_height = FFMAX(tex_height, 1);

    if (priv->device_caps_power2_only) {
        tex_width  = 1;
        tex_height = 1;
        while (tex_width  < *width) tex_width  <<= 1;
        while (tex_height < *height) tex_height <<= 1;
    }
    if (priv->device_caps_square_only)
        /* device only supports square textures */
        tex_width = tex_height = FFMAX(tex_width, tex_height);
    // better round up to a multiple of 16
    if (!priv->opt_disable_texture_align) {
        tex_width  = (tex_width  + 15) & ~15;
        tex_height = (tex_height + 15) & ~15;
    }

    *width = tex_width;
    *height = tex_height;
}

static void d3dtex_release(d3d_priv *priv, struct d3dtex *tex)
{
    if (tex->system)
        IDirect3DTexture9_Release(tex->system);
    tex->system = NULL;

    if (tex->device)
        IDirect3DTexture9_Release(tex->device);
    tex->device = NULL;

    tex->tex_w = tex->tex_h = 0;
}

static bool d3dtex_allocate(d3d_priv *priv, struct d3dtex *tex, D3DFORMAT fmt,
                            int w, int h)
{
    d3dtex_release(priv, tex);

    tex->w = w;
    tex->h = h;

    int tw = w, th = h;
    d3d_fix_texture_size(priv, &tw, &th);

    int memtype = D3DPOOL_SYSTEMMEM;
    switch (priv->opt_texture_memory) {
    case 1: memtype = D3DPOOL_MANAGED; break;
    case 2: memtype = D3DPOOL_DEFAULT; break;
    }

    if (FAILED(IDirect3DDevice9_CreateTexture(priv->d3d_device, tw, th, 1,
        D3DUSAGE_DYNAMIC, fmt, memtype, &tex->system, NULL)))
    {
        mp_msg(MSGT_VO, MSGL_ERR,
               "<vo_direct3d>Allocating %dx%d texture in system RAM failed.\n",
               w, h);
        goto error_exit;
    }

    if (!priv->device_texture_sys && !priv->opt_texture_memory) {
        if (FAILED(IDirect3DDevice9_CreateTexture(priv->d3d_device, tw, th, 1,
            D3DUSAGE_DYNAMIC, fmt, D3DPOOL_DEFAULT, &tex->device, NULL)))
        {
            mp_msg(MSGT_VO, MSGL_ERR,
               "<vo_direct3d>Allocating %dx%d texture in video RAM failed.\n",
               w, h);
            goto error_exit;
        }
    }

    tex->tex_w = tw;
    tex->tex_h = th;

    return true;

error_exit:
    d3dtex_release(priv, tex);
    return false;
}

static IDirect3DBaseTexture9 *d3dtex_get_render_texture(d3d_priv *priv,
                                                        struct d3dtex *tex)
{
    return (IDirect3DBaseTexture9 *)(tex->device ? tex->device : tex->system);
}

// Copy system texture contents to device texture.
static bool d3dtex_update(d3d_priv *priv, struct d3dtex *tex)
{
    if (!tex->device)
        return true;
    return !FAILED(IDirect3DDevice9_UpdateTexture(priv->d3d_device,
                   (IDirect3DBaseTexture9 *)tex->system,
                   (IDirect3DBaseTexture9 *)tex->device));
}

static void d3d_unlock_video_objects(d3d_priv *priv)
{
    bool any_failed = false;

    if (priv->locked_rect.pBits) {
        if (FAILED(IDirect3DSurface9_UnlockRect(priv->d3d_surface)))
            any_failed = true;
    }
    priv->locked_rect.pBits = NULL;

    for (int n = 0; n < priv->plane_count; n++) {
        struct texplane *plane = &priv->planes[n];
        if (plane->locked_rect.pBits) {
            if (FAILED(IDirect3DTexture9_UnlockRect(plane->texture.system, 0)))
                any_failed = true;
        }
        plane->locked_rect.pBits = NULL;
    }

    if (any_failed) {
        mp_msg(MSGT_VO, MSGL_V,
               "<vo_direct3d>Unlocking video objects failed.\n");
    }
}

// Free video surface/textures, shaders, etc.
static void d3d_destroy_video_objects(d3d_priv *priv)
{
    d3d_unlock_video_objects(priv);

    if (priv->d3d_surface)
        IDirect3DSurface9_Release(priv->d3d_surface);
    priv->d3d_surface = NULL;

    for (int n = 0; n < priv->plane_count; n++) {
        d3dtex_release(priv, &priv->planes[n].texture);
    }

    if (priv->pixel_shader)
        IDirect3DPixelShader9_Release(priv->pixel_shader);
    priv->pixel_shader = NULL;
}

/** @brief Destroy D3D Offscreen and Backbuffer surfaces.
 */
static void destroy_d3d_surfaces(d3d_priv *priv)
{
    mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>destroy_d3d_surfaces called.\n");

    d3d_destroy_video_objects(priv);

    d3dtex_release(priv, &priv->texture_osd);

    if (priv->d3d_backbuf)
        IDirect3DSurface9_Release(priv->d3d_backbuf);
    priv->d3d_backbuf = NULL;

    d3dtex_release(priv, &priv->texture_eosd);

    if (priv->eosd)
        eosd_packer_reinit(priv->eosd, 0, 0);

    priv->d3d_in_scene = false;
}

// Allocate video surface or textures, and create shaders if needed.
static bool d3d_configure_video_objects(d3d_priv *priv)
{
    int n;
    bool need_clear = false;

    assert(priv->image_format != 0);

    if (priv->use_textures) {
        for (n = 0; n < priv->plane_count; n++) {
            struct texplane *plane = &priv->planes[n];

            if (!plane->texture.system) {
                if (!d3dtex_allocate(priv,
                                     &plane->texture,
                                     plane->d3d_format,
                                     priv->src_width >> plane->shift_x,
                                     priv->src_height >> plane->shift_y))
                {
                    mp_msg(MSGT_VO, MSGL_ERR, "<vo_direct3d>Allocating plane %d"
                           " failed.\n", n);
                    return false;
                }

                mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Allocated plane %d:"
                       " %d bit, shift=%d/%d size=%d/%d (%d/%d).\n", n,
                       plane->bits_per_pixel,
                       plane->shift_x, plane->shift_y,
                       plane->texture.w, plane->texture.h,
                       plane->texture.tex_w, plane->texture.tex_h);

                need_clear = true;
            }
        }

        if (need_clear)
            d3d_clear_video_textures(priv);

        if (priv->pixel_shader_data) {
            if (!priv->pixel_shader &&
                FAILED(IDirect3DDevice9_CreatePixelShader(priv->d3d_device,
                    (DWORD *)priv->pixel_shader_data, &priv->pixel_shader)))
            {
                mp_msg(MSGT_VO, MSGL_ERR, "<vo_direct3d>Failed to create "
                       "YUV conversion pixel shader.\n");
                return false;
            }
        }

    } else {

        if (!priv->d3d_surface &&
            FAILED(IDirect3DDevice9_CreateOffscreenPlainSurface(
                priv->d3d_device, priv->src_width, priv->src_height,
                priv->movie_src_fmt, D3DPOOL_DEFAULT, &priv->d3d_surface, NULL)))
        {
            mp_msg(MSGT_VO, MSGL_ERR,
                "<vo_direct3d>Allocating offscreen surface failed.\n");
            return false;
        }
    }

    return true;
}

static bool d3d_lock_video_textures(d3d_priv *priv)
{
    for (int n = 0; n < priv->plane_count; n++) {
        struct texplane *plane = &priv->planes[n];

        if (!plane->locked_rect.pBits) {
            if (FAILED(IDirect3DTexture9_LockRect(plane->texture.system, 0,
                                                  &plane->locked_rect, NULL, 0)))
            {
                mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Texture lock failure.\n");
                d3d_unlock_video_objects(priv);
                return false;
            }
        }
    }

    return true;
}

static void d3d_clear_video_textures(d3d_priv *priv)
{
    if (!d3d_lock_video_textures(priv))
        return;

    for (int n = 0; n < priv->plane_count; n++) {
        struct texplane *plane = &priv->planes[n];
        memset(plane->locked_rect.pBits, plane->clearval,
               plane->locked_rect.Pitch * plane->texture.tex_h);
    }

    d3d_unlock_video_objects(priv);
}

// Recreate and initialize D3D objects if necessary. The amount of work that
// needs to be done can be quite different: it could be that full initialization
// is required, or that some objects need to be created, or that nothing is
// done.
static bool create_d3d_surfaces(d3d_priv *priv)
{
    int osd_width = priv->vo->dwidth, osd_height = priv->vo->dheight;
    int tex_width = osd_width, tex_height = osd_height;
    mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>create_d3d_surfaces called.\n");

    if (!priv->d3d_backbuf &&
        FAILED(IDirect3DDevice9_GetBackBuffer(priv->d3d_device, 0, 0,
                                              D3DBACKBUFFER_TYPE_MONO,
                                              &priv->d3d_backbuf))) {
        mp_msg(MSGT_VO, MSGL_ERR, "<vo_direct3d>Allocating backbuffer failed.\n");
        return 0;
    }

    if (!d3d_configure_video_objects(priv))
        return 0;

    /* create OSD */

    d3d_fix_texture_size(priv, &tex_width, &tex_height);

    while (tex_width > priv->max_texture_width
           || tex_height > priv->max_texture_height)
    {
        osd_width  >>= 1;
        osd_height >>= 1;
        tex_width  >>= 1;
        tex_height >>= 1;
    }

    if (priv->texture_osd.tex_w < tex_width
        || priv->texture_osd.tex_h < tex_height)
    {
        d3dtex_release(priv, &priv->texture_osd);

        mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>OSD texture size (%dx%d),"
               " requested (%dx%d).\n", osd_width, osd_height, tex_width,
               tex_height);

        if (!d3dtex_allocate(priv, &priv->texture_osd, D3DFMT_A8L8, tex_width,
                             tex_height))
        {
            mp_msg(MSGT_VO, MSGL_ERR,
                "<vo_direct3d>Allocating OSD texture failed.\n");
            return 0;
        }
    }

    priv->texture_osd.w = osd_width;
    priv->texture_osd.h = osd_height;

    /* setup default renderstate */
    IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                    D3DRS_SRCBLEND, D3DBLEND_SRCALPHA);
    IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                    D3DRS_DESTBLEND, D3DBLEND_INVSRCALPHA);
    IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                    D3DRS_ALPHAFUNC, D3DCMP_GREATER);
    IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                    D3DRS_ALPHAREF, (DWORD)0x0);
    IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                    D3DRS_LIGHTING, FALSE);

    // we use up to 3 samplers for up to 3 YUV planes
    for (int n = 0; n < 3; n++) {
        IDirect3DDevice9_SetSamplerState(priv->d3d_device, n, D3DSAMP_MINFILTER,
                                         D3DTEXF_LINEAR);
        IDirect3DDevice9_SetSamplerState(priv->d3d_device, n, D3DSAMP_MAGFILTER,
                                         D3DTEXF_LINEAR);
        IDirect3DDevice9_SetSamplerState(priv->d3d_device, n, D3DSAMP_ADDRESSU,
                                         D3DTADDRESS_CLAMP);
        IDirect3DDevice9_SetSamplerState(priv->d3d_device, n, D3DSAMP_ADDRESSV,
                                         D3DTADDRESS_CLAMP);
    }

    if (priv->eosd && !priv->texture_eosd.system)
        eosd_packer_reinit(priv->eosd, priv->max_texture_width,
                           priv->max_texture_height);

    return 1;
}

static bool init_d3d(d3d_priv *priv)
{
    D3DDISPLAYMODE disp_mode;
    D3DCAPS9 disp_caps;
    DWORD texture_caps;
    DWORD dev_caps;

    priv->d3d_handle = priv->pDirect3DCreate9(D3D_SDK_VERSION);
    if (!priv->d3d_handle) {
        mp_msg(MSGT_VO, MSGL_ERR,
               "<vo_direct3d>Initializing Direct3D failed.\n");
        return false;
    }

    if (FAILED(IDirect3D9_GetAdapterDisplayMode(priv->d3d_handle,
                                                D3DADAPTER_DEFAULT,
                                                &disp_mode))) {
        mp_msg(MSGT_VO, MSGL_ERR,
               "<vo_direct3d>Reading display mode failed.\n");
        return false;
    }

    priv->desktop_fmt = disp_mode.Format;
    priv->cur_backbuf_width = disp_mode.Width;
    priv->cur_backbuf_height = disp_mode.Height;

    mp_msg(MSGT_VO, MSGL_V,
           "<vo_direct3d>Setting backbuffer dimensions to (%dx%d).\n",
           disp_mode.Width, disp_mode.Height);

    if (FAILED(IDirect3D9_GetDeviceCaps(priv->d3d_handle,
                                        D3DADAPTER_DEFAULT,
                                        DEVTYPE,
                                        &disp_caps)))
    {
        mp_msg(MSGT_VO, MSGL_ERR,
               "<vo_direct3d>Reading display capabilities failed.\n");
        return false;
    }

    /* Store relevant information reguarding caps of device */
    texture_caps                  = disp_caps.TextureCaps;
    dev_caps                      = disp_caps.DevCaps;
    priv->device_caps_power2_only =  (texture_caps & D3DPTEXTURECAPS_POW2) &&
                        !(texture_caps & D3DPTEXTURECAPS_NONPOW2CONDITIONAL);
    priv->device_caps_square_only = texture_caps & D3DPTEXTURECAPS_SQUAREONLY;
    priv->device_texture_sys      = dev_caps & D3DDEVCAPS_TEXTURESYSTEMMEMORY;
    priv->max_texture_width       = disp_caps.MaxTextureWidth;
    priv->max_texture_height      = disp_caps.MaxTextureHeight;

    if (priv->opt_force_power_of_2)
        priv->device_caps_power2_only = 1;

    mp_msg(MSGT_VO, MSGL_V,
           "<vo_direct3d>device_caps_power2_only %d, device_caps_square_only %d\n"
           "<vo_direct3d>device_texture_sys %d\n"
           "<vo_direct3d>max_texture_width %d, max_texture_height %d\n",
           priv->device_caps_power2_only, priv->device_caps_square_only,
           priv->device_texture_sys, priv->max_texture_width,
           priv->max_texture_height);

    return true;
}

/** @brief Fill D3D Presentation parameters
 */
static void fill_d3d_presentparams(d3d_priv *priv,
                                   D3DPRESENT_PARAMETERS *present_params)
{
    /* Prepare Direct3D initialization parameters. */
    memset(present_params, 0, sizeof(D3DPRESENT_PARAMETERS));
    present_params->Windowed               = TRUE;
    present_params->SwapEffect             =
        priv->opt_swap_discard ? D3DSWAPEFFECT_DISCARD : D3DSWAPEFFECT_COPY;
    present_params->Flags                  = D3DPRESENTFLAG_VIDEO;
    present_params->hDeviceWindow          = vo_w32_window; /* w32_common var */
    present_params->BackBufferWidth        = priv->cur_backbuf_width;
    present_params->BackBufferHeight       = priv->cur_backbuf_height;
    present_params->MultiSampleType        = D3DMULTISAMPLE_NONE;
    present_params->PresentationInterval   = D3DPRESENT_INTERVAL_ONE;
    present_params->BackBufferFormat       = priv->desktop_fmt;
    present_params->BackBufferCount        = 1;
    present_params->EnableAutoDepthStencil = FALSE;
}


// Create a new backbuffer. Create or Reset the D3D device.
static bool change_d3d_backbuffer(d3d_priv *priv)
{
    D3DPRESENT_PARAMETERS present_params;

    int window_w = priv->vo->dwidth;
    int window_h = priv->vo->dheight;

    /* Grow the backbuffer in the required dimension. */
    if (window_w > priv->cur_backbuf_width)
        priv->cur_backbuf_width = window_w;

    if (window_h > priv->cur_backbuf_height)
        priv->cur_backbuf_height = window_h;

    if (priv->opt_exact_backbuffer) {
        priv->cur_backbuf_width = window_w;
        priv->cur_backbuf_height = window_h;
    }

    /* The grown backbuffer dimensions are ready and fill_d3d_presentparams
     * will use them, so we can reset the device.
     */
    fill_d3d_presentparams(priv, &present_params);

    if (!priv->d3d_device) {
        if (FAILED(IDirect3D9_CreateDevice(priv->d3d_handle,
                                           D3DADAPTER_DEFAULT,
                                           DEVTYPE, vo_w32_window,
                                           D3DCREATE_SOFTWARE_VERTEXPROCESSING,
                                           &present_params, &priv->d3d_device)))
        {
            mp_msg(MSGT_VO, MSGL_V,
                   "<vo_direct3d>Creating Direct3D device failed.\n");
            return 0;
        }
    } else {
        if (FAILED(IDirect3DDevice9_Reset(priv->d3d_device, &present_params))) {
            mp_msg(MSGT_VO, MSGL_ERR,
                   "<vo_direct3d>Reseting Direct3D device failed.\n");
            return 0;
        }
    }

    mp_msg(MSGT_VO, MSGL_V,
           "<vo_direct3d>New backbuffer (%dx%d), VO (%dx%d)\n",
           present_params.BackBufferWidth, present_params.BackBufferHeight,
           window_w, window_h);

    return 1;
}

/** @brief Reconfigure the whole Direct3D. Called only
 *  when the video adapter becomes uncooperative. ("Lost" devices)
 *  @return 1 on success, 0 on failure
 */
static int reconfigure_d3d(d3d_priv *priv)
{
    mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>reconfigure_d3d called.\n");

    destroy_d3d_surfaces(priv);

    IDirect3DDevice9_Release(priv->d3d_device);
    priv->d3d_device = NULL;

    // Force complete destruction of the D3D state.
    // Note: this step could be omitted. The resize_d3d call below would detect
    // that d3d_device is NULL, and would properly recreate it. I'm not sure why
    // the following code to release and recreate the d3d_handle exists.
    IDirect3D9_Release(priv->d3d_handle);
    priv->d3d_handle = NULL;
    if (!init_d3d(priv))
        return 0;

    // Proper re-initialization.
    if (!resize_d3d(priv))
        return 0;

    return 1;
}

// Resize Direct3D context on window resize.
// This function also is called when major initializations need to be done.
static bool resize_d3d(d3d_priv *priv)
{
    D3DVIEWPORT9 vp = {0, 0, priv->vo->dwidth, priv->vo->dheight, 0, 1};

    mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>resize_d3d called.\n");

    /* Make sure that backbuffer is large enough to accomodate the new
       viewport dimensions. Grow it if necessary. */

    bool backbuf_resize = priv->vo->dwidth > priv->cur_backbuf_width ||
                          priv->vo->dheight > priv->cur_backbuf_height;

    if (priv->opt_exact_backbuffer) {
        backbuf_resize = priv->vo->dwidth != priv->cur_backbuf_width ||
                         priv->vo->dheight != priv->cur_backbuf_height;
    }

    if (backbuf_resize || !priv->d3d_device)
    {
        destroy_d3d_surfaces(priv);
        if (!change_d3d_backbuffer(priv))
            return 0;
    }

    if (!priv->d3d_device)
        return 1;

    if (!create_d3d_surfaces(priv))
        return 0;

    if (FAILED(IDirect3DDevice9_SetViewport(priv->d3d_device, &vp))) {
        mp_msg(MSGT_VO, MSGL_ERR, "<vo_direct3d>Setting viewport failed.\n");
        return 0;
    }

    // so that screen coordinates map to D3D ones
    D3DMATRIX view;
    d3d_matrix_ortho(&view, 0.5f, vp.Width + 0.5f, vp.Height + 0.5f, 0.5f);
    IDirect3DDevice9_SetTransform(priv->d3d_device, D3DTS_VIEW, &view);

    calc_fs_rect(priv);

#ifdef CONFIG_FREETYPE
    // font needs to be adjusted
    force_load_font = 1;
#endif
    // OSD needs to be drawn fresh for new size
    vo_osd_changed(OSDTYPE_OSD);

    priv->vo->want_redraw = true;

    return 1;
}

/** @brief Uninitialize Direct3D and close the window.
 */
static void uninit_d3d(d3d_priv *priv)
{
    mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>uninit_d3d called.\n");

    destroy_d3d_surfaces(priv);

    if (priv->d3d_device)
        IDirect3DDevice9_Release(priv->d3d_device);
    priv->d3d_device = NULL;

    if (priv->d3d_handle) {
        mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Stopping Direct3D.\n");
        IDirect3D9_Release(priv->d3d_handle);
    }
    priv->d3d_handle = NULL;
}

static uint32_t d3d_upload_and_render_frame_texture(d3d_priv *priv,
                                                    mp_image_t *mpi)
{
    if (!(mpi->flags & MP_IMGFLAG_DRAW_CALLBACK))
        draw_slice(priv->vo, mpi->planes, mpi->stride, mpi->w, mpi->h, 0, 0);

    d3d_unlock_video_objects(priv);

    for (int n = 0; n < priv->plane_count; n++) {
        d3dtex_update(priv, &priv->planes[n].texture);
    }

    return d3d_draw_frame(priv);
}

/** @brief Render a frame on the screen.
 *  @param mpi mpi structure with the decoded frame inside
 *  @return VO_TRUE on success, VO_ERROR on failure
 */
static uint32_t d3d_upload_and_render_frame(d3d_priv *priv, mp_image_t *mpi)
{
    if (!priv->d3d_device)
        return VO_TRUE;

    if (priv->use_textures)
        return d3d_upload_and_render_frame_texture(priv, mpi);

    if (mpi->flags & MP_IMGFLAG_DRAW_CALLBACK)
        goto skip_upload;

    if (mpi->flags & MP_IMGFLAG_PLANAR) { /* Copy a planar frame. */
        draw_slice(priv->vo, mpi->planes, mpi->stride, mpi->w, mpi->h, 0, 0);
        goto skip_upload;
    }

    /* If we're here, then we should lock the rect and copy a packed frame */
    if (!priv->locked_rect.pBits) {
        if (FAILED(IDirect3DSurface9_LockRect(priv->d3d_surface,
                                              &priv->locked_rect, NULL, 0))) {
            mp_msg(MSGT_VO, MSGL_ERR, "<vo_direct3d>Surface lock failed.\n");
            return VO_ERROR;
        }
    }

    memcpy_pic(priv->locked_rect.pBits, mpi->planes[0], mpi->stride[0],
               mpi->height, priv->locked_rect.Pitch, mpi->stride[0]);

skip_upload:
    d3d_unlock_video_objects(priv);

    return d3d_draw_frame(priv);
}

static uint32_t d3d_draw_frame(d3d_priv *priv)
{
    int n;

    if (!priv->d3d_device)
        return VO_TRUE;

    if (!d3d_begin_scene(priv))
        return VO_ERROR;

    if (priv->is_clear_needed || priv->opt_swap_discard) {
        IDirect3DDevice9_Clear(priv->d3d_device, 0, NULL,
                               D3DCLEAR_TARGET, 0, 0, 0);
        priv->is_clear_needed = 0;
    }

    if (priv->use_textures) {

        for (n = 0; n < priv->plane_count; n++) {
            IDirect3DDevice9_SetTexture(priv->d3d_device, n,
                d3dtex_get_render_texture(priv, &priv->planes[n].texture));
        }

        RECT rm = priv->fs_movie_rect;
        RECT rs = priv->fs_panscan_rect;

        vertex_video vb[] = {
            { rm.left,  rm.top,    0.0f},
            { rm.right, rm.top,    0.0f},
            { rm.left,  rm.bottom, 0.0f},
            { rm.right, rm.bottom, 0.0f}
        };

        float texc[4][2] = {
            { rs.left,  rs.top},
            { rs.right, rs.top},
            { rs.left,  rs.bottom},
            { rs.right, rs.bottom}
        };

        for (n = 0; n < priv->plane_count; n++) {
            float s_x = (1.0f / (1 << priv->planes[n].shift_x))
                        / priv->planes[n].texture.tex_w;
            float s_y = (1.0f / (1 << priv->planes[n].shift_y))
                        / priv->planes[n].texture.tex_h;
            for (int i = 0; i < 4; i++) {
                vb[i].t[n][0] = texc[i][0] * s_x;
                vb[i].t[n][1] = texc[i][1] * s_y;
            }
        }

        if (priv->pixel_shader) {
            IDirect3DDevice9_SetPixelShader(priv->d3d_device, priv->pixel_shader);
            IDirect3DDevice9_SetPixelShaderConstantF(priv->d3d_device, 0,
                                                     &priv->d3d_colormatrix._11,
                                                     4);
            IDirect3DDevice9_SetPixelShaderConstantF(priv->d3d_device, 5,
                                                     priv->d3d_depth_vector,
                                                     1);
        }

        IDirect3DDevice9_SetFVF(priv->d3d_device, D3DFVF_VIDEO_VERTEX);
        IDirect3DDevice9_DrawPrimitiveUP(priv->d3d_device, D3DPT_TRIANGLESTRIP,
                                         2, &vb[0], sizeof(vertex_video));

        IDirect3DDevice9_SetPixelShader(priv->d3d_device, NULL);

        for (n = 0; n < priv->plane_count; n++) {
            IDirect3DDevice9_SetTexture(priv->d3d_device, n, NULL);
        }

    } else {
        if (FAILED(IDirect3DDevice9_StretchRect(priv->d3d_device,
                                                priv->d3d_surface,
                                                &priv->fs_panscan_rect,
                                                priv->d3d_backbuf,
                                                &priv->fs_movie_rect,
                                                D3DTEXF_LINEAR))) {
            mp_msg(MSGT_VO, MSGL_ERR,
                "<vo_direct3d>Copying frame to the backbuffer failed.\n");
            return VO_ERROR;
        }
    }

    return VO_TRUE;
}

// Return the high byte of the value that represents white in chroma (U/V)
static int get_chroma_clear_val(int bit_depth)
{
    return 1 << (bit_depth - 1 & 7);
}

// this macro is supposed to work on all formats supported by 3D rendering, and
// that produce "reasonable" output (i.e. no mixed up colors)
#define IMGFMT_IS_ANY_RND(x) \
    (IMGFMT_IS_BGR(x) || IMGFMT_IS_RGB(x) || IMGFMT_IS_Y(x))

// pixel size in bit for any IMGFMT_IS_ANY_RND(x)==true
// we assume that the actual pixel strides are always aligned on bytes
static int imgfmt_any_rnd_depth(int fmt)
{
    if (IMGFMT_IS_BGR(fmt))
        return IMGFMT_BGR_DEPTH(fmt);
    if (IMGFMT_IS_RGB(fmt))
        return IMGFMT_RGB_DEPTH(fmt);
    if (IMGFMT_IS_Y(fmt))
        return IMGFMT_Y_DEPTH(fmt);
    assert(false);
    return 0;
}

static D3DFORMAT check_format(d3d_priv *priv, uint32_t movie_fmt,
                              bool as_texture)
{
    const char *type = as_texture ? "texture rendering" : "StretchRect";
    const struct fmt_entry *cur = &fmt_table[0];

    // Don't try to handle weird packed texture formats (although I don't know
    // if D3D9 would even accept any such format for 3D rendering; and we
    // certainly don't try any tricks like matching it to RGB formats and
    // applying a YUV conversion matrix)
    if (as_texture && !IMGFMT_IS_ANY_RND(movie_fmt))
        return 0;

    while (cur->mplayer_fmt) {
        if (cur->mplayer_fmt == movie_fmt) {
            HRESULT res;
            if (as_texture) {
                res = IDirect3D9_CheckDeviceFormat(priv->d3d_handle,
                            D3DADAPTER_DEFAULT,
                            DEVTYPE,
                            priv->desktop_fmt,
                            D3DUSAGE_DYNAMIC | D3DUSAGE_QUERY_FILTER,
                            D3DRTYPE_TEXTURE,
                            cur->fourcc);
            } else {
                /* Test conversion from Movie colorspace to
                * display's target colorspace. */
                res = IDirect3D9_CheckDeviceFormatConversion(priv->d3d_handle,
                            D3DADAPTER_DEFAULT,
                            DEVTYPE,
                            cur->fourcc,
                            priv->desktop_fmt);
            }
            if (FAILED(res)) {
                mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Rejected image format "
                       "(%s): %s\n", type, vo_format_name(cur->mplayer_fmt));
                return 0;
            }

            mp_msg(MSGT_VO, MSGL_DBG2, "<vo_direct3d>Accepted image format "
                   "(%s): %s\n", type, vo_format_name(cur->mplayer_fmt));

            return cur->fourcc;
        }
        cur++;
    }

    return 0;
}

// Check whether YUV conversion with shaders can be done.
// Returns the format the individual planes should use (or 0 on failure)
static D3DFORMAT check_shader_conversion(d3d_priv *priv, uint32_t fmt)
{
    if (priv->opt_disable_shaders)
        return 0;
    int component_bits;
    if (!mp_get_chroma_shift(fmt, NULL, NULL, &component_bits))
        return 0;
    if (component_bits < 8 || component_bits > 16)
        return 0;
    bool is_8bit = component_bits == 8;
    if (!is_8bit && priv->opt_only_8bit)
        return 0;
    int texfmt = IMGFMT_Y8;
    if (!is_8bit) {
        if (priv->opt_16bit_textures)
            texfmt = IMGFMT_Y16;
        else
            texfmt = IMGFMT_A8Y8;
    }
    return check_format(priv, texfmt, true);
}

// Return if the image format can be used. If it can, decide which rendering
// and conversion mode to use.
// If initialize is true, actually setup all variables to use the picked
// rendering mode.
static bool init_rendering_mode(d3d_priv *priv, uint32_t fmt, bool initialize)
{
    int n;
    int blit_d3dfmt = check_format(priv, fmt, false);
    int texture_d3dfmt = check_format(priv, fmt, true);
    int shader_d3dfmt = check_shader_conversion(priv, fmt);

    if (priv->opt_disable_textures)
        texture_d3dfmt = 0;
    if (priv->opt_disable_shaders)
        shader_d3dfmt = 0;
    if (priv->opt_disable_stretchrect)
        blit_d3dfmt = 0;

    if (!(blit_d3dfmt || shader_d3dfmt || texture_d3dfmt))
        return false;

    mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Accepted rendering methods for "
           "format='%s': StretchRect=%#x, Texture=%#x, Texture+Shader=%#x.\n",
           vo_format_name(fmt), blit_d3dfmt, texture_d3dfmt, shader_d3dfmt);

    if (!initialize)
        return true;

    // initialization doesn't fail beyond this point

    priv->use_shaders = false;
    priv->use_textures = false;
    priv->use_2ch_hack = false;
    priv->movie_src_fmt = 0;
    priv->pixel_shader_data = NULL;
    priv->plane_count = 0;
    priv->image_format = fmt;

    if (blit_d3dfmt && priv->opt_prefer_stretchrect)
        texture_d3dfmt = shader_d3dfmt = 0;

    if (texture_d3dfmt) {
        priv->use_textures = true;
    } else if (shader_d3dfmt) {
        priv->use_textures = true;
        priv->use_shaders = true;
    } else {
        assert(!!blit_d3dfmt);
    }

    if (priv->use_textures) {
        mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Using 3D rendering.\n");

        struct texplane *planes = &priv->planes[0];
        planes[0].shift_x = planes[0].shift_y = 0;
        planes[0].clearval = 0;

        if (!priv->use_shaders) {
            assert(IMGFMT_IS_ANY_RND(priv->image_format));
            priv->plane_count = 1;
            planes[0].bits_per_pixel = imgfmt_any_rnd_depth(priv->image_format);
            planes[0].d3d_format = texture_d3dfmt;
        } else {
            mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Using YUV shaders.\n");

            int sx, sy, component_bits;
            mp_get_chroma_shift(priv->image_format, &sx, &sy, &component_bits);
            priv->plane_count = 3;
            for (n = 0; n < 3; n++) {
                planes[n].d3d_format = shader_d3dfmt;
                planes[n].bits_per_pixel = component_bits;
                if (n > 0) {
                    planes[n].shift_x = sx;
                    planes[n].shift_y = sy;
                    planes[n].clearval = get_chroma_clear_val(component_bits);
                }
            }
            if (shader_d3dfmt != D3DFMT_A8L8) {
                priv->pixel_shader_data = d3d_shader_yuv;
            } else {
                mp_msg(MSGT_VO, MSGL_WARN, "<vo_direct3d>Using YUV 2ch hack.\n");

                priv->pixel_shader_data = d3d_shader_yuv_2ch;
                priv->use_2ch_hack = true;
            }
        }

        for (n = 0; n < priv->plane_count; n++) {
            planes[n].bytes_per_pixel = (planes[n].bits_per_pixel + 7) / 8;
        }

    } else {
        mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Using StretchRect.\n");

        priv->movie_src_fmt = blit_d3dfmt;
    }

    update_colorspace(priv);

    return true;
}

/** @brief Query if movie colorspace is supported by the HW.
 *  @return 0 on failure, device capabilities (not probed
 *          currently) on success.
 */
static int query_format(d3d_priv *priv, uint32_t movie_fmt)
{
    if (!init_rendering_mode(priv, movie_fmt, false))
        return 0;

    int eosd_caps = VFCAP_CSP_SUPPORTED | VFCAP_CSP_SUPPORTED_BY_HW
                    | VFCAP_OSD | VFCAP_HWSCALE_UP | VFCAP_HWSCALE_DOWN;
    if (priv->eosd)
        eosd_caps |= VFCAP_EOSD | VFCAP_EOSD_UNSCALED;
    return eosd_caps;
}

/****************************************************************************
 *                                                                          *
 *                                                                          *
 *                                                                          *
 * libvo Control / Callback functions                                       *
 *                                                                          *
 *                                                                          *
 *                                                                          *
 ****************************************************************************/

static void get_2ch_depth_multiplier(int depth, float *out_f1, float *out_f2) {
    // How to get these values:
    //  The suffix i8 and i16 is for values with 8/16 bit fixed point numbers.
    //  The suffix f is for float, ideally in the range 0.0-1.0.
    //  c_i8 is a two component vector, sampled from a two channel texture.
    //  (c_i8.x is the low byte, c_i8.y is the high byte)
    //  r_f is the resulting color scalar value.
    //
    //  c_i8 = c_f * (2^8-1)
    //  r_i16 = c_i8.x + c_i8.y * 2^8
    //  r_f = r_i16 / (2^16-1)
    //      = c_f.x * (2^8-1) / (2^16-1) + c_f.y * (2^8-1) * 2^8 / (2^16-1)
    //      = c_f.x * ((2^8-1) / (2^16-1)) + c_f.y * (2^8 * ((2^8-1) / (2^16-1)))
    // out = ((2^8-1) / (2^16-1),  2^8 * ((2^8-1) / (2^16-1)))
    // The result color is r_f = dot(c_f, out).
    // Same goes for other bit depth, such as 10 bit. Assuming (2^depth-1) is
    // the maximum possible value at that depth, you have to scale the value
    // r_i16 with it, the factor (2^16-1) in the formula above has to be
    // replaced with (2^depth-1).
    float factor = (float)((1 << 8) - 1) / (float)((1 << depth) - 1);
    *out_f1 = factor;
    *out_f2 = 256.0 * factor;
}

static void update_colorspace(d3d_priv *priv)
{
    float coeff[3][4];
    struct mp_csp_params csp = { .colorspace = priv->colorspace };
    mp_csp_copy_equalizer_values(&csp, &priv->video_eq);

    if (priv->use_shaders) {
        if (!priv->use_2ch_hack) {
            csp.input_bits = priv->planes[0].bits_per_pixel;
            csp.texture_bits = (csp.input_bits + 7) & ~7;
        } else {
            float f1, f2;
            get_2ch_depth_multiplier(priv->planes[0].bits_per_pixel, &f1, &f2);
            priv->d3d_depth_vector[0] = f1;
            priv->d3d_depth_vector[1] = f2;
            priv->d3d_depth_vector[2] = priv->d3d_depth_vector[3] = 0;
            // no change
            csp.input_bits = 8;
            csp.texture_bits = 8;
        }
    }

    mp_get_yuv2rgb_coeffs(&csp, coeff);
    for (int row = 0; row < 3; row++) {
        for (int col = 0; col < 4; col++) {
            priv->d3d_colormatrix.m[row][col] = coeff[row][col];
        }
    }
}

const char *options_help_text = "-vo direct3d command line help:\n"
"Example: -vo direct3d:disable-eosd:disable-textures\n"
"Options:\n"
"    prefer-stretchrect\n"
"        Use IDirect3DDevice9::StretchRect over other methods if possible.\n"
"    disable-stretchrect\n"
"        Never render the video using IDirect3DDevice9::StretchRect.\n"
"    disable-textures\n"
"        Never render the video using D3D texture rendering. (Rendering with\n"
"        textures + shader will still be allowed. Add disable-shaders to\n"
"        completely disable video rendering with textures.)\n"
"    disable-shaders\n"
"        Never use shaders when rendering video.\n"
"    only-8bit\n"
"        Never render YUV video with more than 8 bits per component.\n"
"        (Using this flag will force software conversion to 8 bit.)\n"
"    disable-eosd\n"
"        Disable EOSD rendering for subtitles.\n"
"        (Using this flag might force the insertion of the 'ass' video filter,\n"
"         which will render the subtitles in software.)\n"
"    disable-texture-align\n"
"        Normally texture sizes are always aligned to 16. With this option\n"
"        enabled, the video texture will always have exactly the same size as\n"
"        the video itself.\n"
"Debug options. These might be incorrect, might be removed in the future, might\n"
"crash, might cause slow downs, etc. Contact the developers if you actually need\n"
"any of these for performance or proper operation.\n"
"    force-power-of-2\n"
"        Always force textures to power of 2, even if the device reports\n"
"        non-power-of-2 texture sizes as supported.\n"
"    texture-memory=N\n"
"        Only affects operation with shaders/texturing enabled, and (E)OSD.\n"
"        Values for N:\n"
"           0 default, will often use an additional shadow texture + copy\n"
"           1 use D3DPOOL_MANAGED\n"
"           2 use D3DPOOL_DEFAULT\n"
"           3 use D3DPOOL_SYSTEMMEM, but without shadow texture\n"
"    swap-discard\n"
"        Use D3DSWAPEFFECT_DISCARD, which might be faster.\n"
"        Might be slower too, as it must (?) clear every frame.\n"
"    exact-backbuffer\n"
"        Always resize the backbuffer to window size.\n"
"    no16bit-textures\n"
"        Don't use textures with a 16 bit color channel for YUV formats that\n"
"        use more than 8 bits per component. Instead, use D3DFMT_A8L8 textures\n"
"        and compute the values sampled from the 2 channels back into one.\n"
"        Might be slower, since the shader becomes slightly more complicated.\n"
"        Might work better, if your drivers either don't support D3DFMT_L16,\n"
"        or if either the texture unit or the shaders don't operate in at least\n"
"        16 bit precision.\n"
"";

/** @brief libvo Callback: Preinitialize the video card.
 *  Preinit the hardware just enough to be queried about
 *  supported formats.
 *
 *  @return 0 on success, -1 on failure
 */

static int preinit_internal(struct vo *vo, const char *arg, bool allow_shaders)
{
    d3d_priv *priv = talloc_zero(vo, d3d_priv);
    vo->priv = priv;

    *priv = (d3d_priv) {
        .vo = vo,

        .opt_16bit_textures = true,

        .colorspace = MP_CSP_DETAILS_DEFAULTS,
        .video_eq = { MP_CSP_EQ_CAPS_COLORMATRIX },
    };

    if (!allow_shaders) {
        priv->opt_disable_shaders = priv->opt_disable_textures = true;
    }

    const opt_t subopts[] = {
        {"prefer-stretchrect", OPT_ARG_BOOL, &priv->opt_prefer_stretchrect},
        {"disable-textures", OPT_ARG_BOOL, &priv->opt_disable_textures},
        {"disable-stretchrect", OPT_ARG_BOOL, &priv->opt_disable_stretchrect},
        {"disable-shaders", OPT_ARG_BOOL, &priv->opt_disable_shaders},
        {"only-8bit", OPT_ARG_BOOL, &priv->opt_only_8bit},
        {"disable-eosd", OPT_ARG_BOOL, &priv->opt_disable_eosd},
        {"force-power-of-2", OPT_ARG_BOOL, &priv->opt_force_power_of_2},
        {"disable-texture-align", OPT_ARG_BOOL, &priv->opt_disable_texture_align},
        {"texture-memory", OPT_ARG_INT, &priv->opt_texture_memory},
        {"swap-discard", OPT_ARG_BOOL, &priv->opt_swap_discard},
        {"exact-backbuffer", OPT_ARG_BOOL, &priv->opt_exact_backbuffer},
        {"16bit-textures", OPT_ARG_BOOL, &priv->opt_16bit_textures},
        {NULL}
    };
    if (subopt_parse(arg, subopts) != 0) {
        mp_msg(MSGT_VO, MSGL_FATAL, options_help_text);
        return -1;
    }

    if (!priv->opt_disable_eosd)
        priv->eosd = eosd_packer_create(priv);

    priv->d3d9_dll = LoadLibraryA("d3d9.dll");
    if (!priv->d3d9_dll) {
        mp_msg(MSGT_VO, MSGL_ERR,
               "<vo_direct3d>Unable to dynamically load d3d9.dll\n");
        goto err_out;
    }

    priv->pDirect3DCreate9 = (void *)GetProcAddress(priv->d3d9_dll,
                                                    "Direct3DCreate9");
    if (!priv->pDirect3DCreate9) {
        mp_msg(MSGT_VO, MSGL_ERR,
               "<vo_direct3d>Unable to find entry point of Direct3DCreate9\n");
        goto err_out;
    }

    if (!init_d3d(priv))
        goto err_out;

    /* w32_common framework call. Configures window on the screen, gets
     * fullscreen dimensions and does other useful stuff.
     */
    global_vo = vo;
    if (!vo_w32_init()) {
        mp_msg(MSGT_VO, MSGL_V,
               "<vo_direct3d>Configuring onscreen window failed.\n");
        goto err_out;
    }

    return 0;

err_out:
    uninit(vo);
    return -1;
}

static int preinit_standard(struct vo *vo, const char *arg)
{
    return preinit_internal(vo, arg, false);
}

static int preinit_shaders(struct vo *vo, const char *arg)
{
    return preinit_internal(vo, arg, true);
}

/** @brief libvo Callback: Handle control requests.
 *  @return VO_TRUE on success, VO_NOTIMPL when not implemented
 */
static int control(struct vo *vo, uint32_t request, void *data)
{
    d3d_priv *priv = vo->priv;

    switch (request) {
    case VOCTRL_QUERY_FORMAT:
        return query_format(priv, *(uint32_t*) data);
    case VOCTRL_GET_IMAGE:
        mp_msg(MSGT_VO, MSGL_V,
               "<vo_direct3d>Direct Rendering request. Not implemented yet.\n");
        return VO_NOTIMPL;
    case VOCTRL_DRAW_IMAGE:
        return d3d_upload_and_render_frame(priv, data);
    case VOCTRL_FULLSCREEN:
        vo_w32_fullscreen();
        resize_d3d(priv);
        return VO_TRUE;
    case VOCTRL_RESET:
        return VO_NOTIMPL;
    case VOCTRL_REDRAW_FRAME:
        priv->is_clear_needed = 1;
        d3d_draw_frame(priv);
        return VO_TRUE;
    case VOCTRL_SET_YUV_COLORSPACE:
        priv->colorspace = *(struct mp_csp_details *)data;
        update_colorspace(priv);
        vo->want_redraw = true;
        return VO_TRUE;
    case VOCTRL_GET_YUV_COLORSPACE:
        if (!priv->use_shaders)
            break; // no idea what the heck D3D YUV uses
        *(struct mp_csp_details *)data = priv->colorspace;
        return VO_TRUE;
    case VOCTRL_SET_EQUALIZER: {
        if (!priv->use_shaders)
            break;
        struct voctrl_set_equalizer_args *args = data;
        if (mp_csp_equalizer_set(&priv->video_eq, args->name, args->value) < 0)
            return VO_NOTIMPL;
        update_colorspace(priv);
        vo->want_redraw = true;
        return VO_TRUE;
    }
    case VOCTRL_GET_EQUALIZER: {
        if (!priv->use_shaders)
            break;
        struct voctrl_get_equalizer_args *args = data;
        return mp_csp_equalizer_get(&priv->video_eq, args->name, args->valueptr)
               >= 0 ? VO_TRUE : VO_NOTIMPL;
    }
    case VOCTRL_ONTOP:
        vo_w32_ontop();
        return VO_TRUE;
    case VOCTRL_BORDER:
        vo_w32_border();
        return VO_TRUE;
    case VOCTRL_UPDATE_SCREENINFO:
        w32_update_xinerama_info();
        return VO_TRUE;
    case VOCTRL_SET_PANSCAN:
        calc_fs_rect(priv);
        return VO_TRUE;
    case VOCTRL_GET_PANSCAN:
        return VO_TRUE;
    case VOCTRL_DRAW_EOSD:
        if (!data)
            return VO_FALSE;
        assert(priv->eosd);
        generate_eosd(priv, data);
        draw_eosd(priv);
        return VO_TRUE;
    case VOCTRL_GET_EOSD_RES: {
        assert(priv->eosd);
        struct mp_eosd_res *r = data;
        r->w = vo->dwidth;
        r->h = vo->dheight;
        r->ml = r->mr = priv->border_x;
        r->mt = r->mb = priv->border_y;
        return VO_TRUE;
    }
    case VOCTRL_SCREENSHOT: {
        struct voctrl_screenshot_args *args = data;
        if (args->full_window)
            args->out_image = get_window_screenshot(priv);
        else
            args->out_image = get_screenshot(priv);
        return !!args->out_image;
    }
    }
    return VO_NOTIMPL;
}

/** @brief libvo Callback: Configre the Direct3D adapter.
 *  @param width    Movie source width
 *  @param height   Movie source height
 *  @param d_width  Screen (destination) width
 *  @param d_height Screen (destination) height
 *  @param options  Options bitmap
 *  @param format   Movie colorspace format (using MPlayer's
 *                  defines, e.g. IMGFMT_YUY2)
 *  @return 0 on success, VO_ERROR on failure
 */
static int config(struct vo *vo, uint32_t width, uint32_t height,
                  uint32_t d_width, uint32_t d_height, uint32_t options,
                  uint32_t format)
{
    d3d_priv *priv = vo->priv;

    /* w32_common framework call. Creates window on the screen with
     * the given coordinates.
     */
    if (!vo_w32_config(d_width, d_height, options)) {
        mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Creating window failed.\n");
        return VO_ERROR;
    }

    priv->src_d_width = d_width;
    priv->src_d_height = d_height;

    if ((priv->image_format != format)
        || (priv->src_width != width)
        || (priv->src_height != height))
    {
        d3d_destroy_video_objects(priv);

        priv->src_width = width;
        priv->src_height = height;
        init_rendering_mode(priv, format, true);
    }

    if (!resize_d3d(priv))
        return VO_ERROR;

    return 0; /* Success */
}

/** @brief libvo Callback: Flip next already drawn frame on the
 *         screen.
 */
static void flip_page(struct vo *vo)
{
    d3d_priv *priv = vo->priv;

    if (priv->d3d_device && priv->d3d_in_scene) {
        if (FAILED(IDirect3DDevice9_EndScene(priv->d3d_device))) {
            mp_msg(MSGT_VO, MSGL_ERR, "<vo_direct3d>EndScene failed.\n");
        }
    }
    priv->d3d_in_scene = false;

    RECT rect = {0, 0, vo->dwidth, vo->dheight};
    if (!priv->d3d_device ||
        FAILED(IDirect3DDevice9_Present(priv->d3d_device, &rect, 0, 0, 0))) {
        mp_msg(MSGT_VO, MSGL_V,
               "<vo_direct3d>Trying to reinitialize uncooperative video adapter.\n");
        if (!reconfigure_d3d(priv)) {
            mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Reinitialization failed.\n");
            return;
        } else {
            mp_msg(MSGT_VO, MSGL_V,
                   "<vo_direct3d>Video adapter reinitialized.\n");
        }
    }
}

/** @brief libvo Callback: Uninitializes all pointers and closes
 *         all D3D related stuff,
 */
static void uninit(struct vo *vo)
{
    d3d_priv *priv = vo->priv;

    mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>uninit called.\n");

    uninit_d3d(priv);
    vo_w32_uninit(); /* w32_common framework call */
    if (priv->d3d9_dll)
        FreeLibrary(priv->d3d9_dll);
    priv->d3d9_dll = NULL;
}

/** @brief libvo Callback: Handles video window events.
 */
static void check_events(struct vo *vo)
{
    d3d_priv *priv = vo->priv;

    int flags;
    /* w32_common framework call. Handles video window events.
     * Updates global libvo's vo_dwidth/vo_dheight upon resize
     * with the new window width/height.
     */
    flags = vo_w32_check_events();
    if (flags & VO_EVENT_RESIZE)
        resize_d3d(priv);

    if (flags & VO_EVENT_EXPOSE)
        vo->want_redraw = true;
}

static int draw_slice_textures(d3d_priv *priv, uint8_t *src[], int stride[],
                               int w, int h, int x, int y)
{
    if (!d3d_lock_video_textures(priv))
        return VO_FALSE;

    for (int n = 0; n < priv->plane_count; n++) {
        struct texplane *plane = &priv->planes[n];

        int dst_stride = plane->locked_rect.Pitch;
        uint8_t *pdst = (uint8_t*)plane->locked_rect.pBits
                        + (y >> plane->shift_y) * dst_stride
                        + (x >> plane->shift_x) * plane->bytes_per_pixel;

        memcpy_pic(pdst, src[n], (w >> plane->shift_x) * plane->bytes_per_pixel,
                   h >> plane->shift_y, dst_stride, stride[n]);
    }

    return 0;
}

/** @brief libvo Callback: Draw slice
 *  @return 0 on success
 */
static int draw_slice(struct vo *vo, uint8_t *src[], int stride[], int w, int h,
                      int x, int y)
{
    d3d_priv *priv = vo->priv;

    if (!priv->d3d_device)
        return 0;

    char *my_src;   /**< Pointer to the source image */
    char *dst;      /**< Pointer to the destination image */
    int  uv_stride; /**< Stride of the U/V planes */

    if (priv->use_textures)
        return draw_slice_textures(priv, src, stride, w, h, x, y);

    /* Lock the offscreen surface if it's not already locked. */
    if (!priv->locked_rect.pBits) {
        if (FAILED(IDirect3DSurface9_LockRect(priv->d3d_surface,
                                              &priv->locked_rect, NULL, 0))) {
            mp_msg(MSGT_VO, MSGL_V, "<vo_direct3d>Surface lock failure.\n");
            return VO_FALSE;
        }
    }

    uv_stride = priv->locked_rect.Pitch / 2;

    /* Copy Y */
    dst = priv->locked_rect.pBits;
    dst = dst + priv->locked_rect.Pitch * y + x;
    my_src = src[0];
    memcpy_pic(dst, my_src, w, h, priv->locked_rect.Pitch, stride[0]);

    w /= 2;
    h /= 2;
    x /= 2;
    y /= 2;

    /* Copy U */
    dst = priv->locked_rect.pBits;
    dst = dst + priv->locked_rect.Pitch * priv->src_height
          + uv_stride * y + x;
    if (priv->movie_src_fmt == MAKEFOURCC('Y','V','1','2'))
        my_src = src[2];
    else
        my_src = src[1];

    memcpy_pic(dst, my_src, w, h, uv_stride, stride[1]);

    /* Copy V */
    dst = priv->locked_rect.pBits;
    dst = dst + priv->locked_rect.Pitch * priv->src_height
          + uv_stride * (priv->src_height / 2) + uv_stride * y + x;
    if (priv->movie_src_fmt == MAKEFOURCC('Y','V','1','2'))
        my_src=src[1];
    else
        my_src=src[2];

    memcpy_pic(dst, my_src, w, h, uv_stride, stride[2]);

    return 0; /* Success */
}

static bool get_screenshot_from_surface(d3d_priv *priv, mp_image_t *image)
{
    if (!priv->locked_rect.pBits) {
        if (FAILED(IDirect3DSurface9_LockRect(priv->d3d_surface,
                                              &priv->locked_rect, NULL, 0))) {
            mp_msg(MSGT_VO, MSGL_ERR, "<vo_direct3d>Surface lock failed.\n");
            return false;
        }
    }

    if (image->flags & MP_IMGFLAG_PLANAR) {
        char *src;
        int w = priv->src_width;
        int h = priv->src_height;
        int swapped = priv->movie_src_fmt == MAKEFOURCC('Y','V','1','2');
        int plane1 = swapped ? 2 : 1;
        int plane2 = swapped ? 1 : 2;

        int uv_stride = priv->locked_rect.Pitch / 2;

        /* Copy Y */
        src = priv->locked_rect.pBits;
        memcpy_pic(image->planes[0], src, w, h, priv->locked_rect.Pitch,
                   image->stride[0]);

        w /= 2;
        h /= 2;

        /* Copy U */
        src = priv->locked_rect.pBits;
        src = src + priv->locked_rect.Pitch * priv->src_height;

        memcpy_pic(image->planes[plane1], src, w, h, uv_stride,
                   image->stride[1]);

        /* Copy V */
        src = priv->locked_rect.pBits;
        src = src + priv->locked_rect.Pitch * priv->src_height
            + uv_stride * (priv->src_height / 2);

        memcpy_pic(image->planes[plane2], src, w, h, uv_stride,
                   image->stride[2]);
    } else {
        // packed YUV or RGB
        memcpy_pic(image->planes[0], priv->locked_rect.pBits, image->stride[0],
                   image->height, priv->locked_rect.Pitch, image->stride[0]);
    }

    d3d_unlock_video_objects(priv);
    return true;
}

static bool get_screenshot_from_texture(d3d_priv *priv, mp_image_t *image)
{
    if (!d3d_lock_video_textures(priv)) {
        d3d_unlock_video_objects(priv);
        return false;
    }

    assert(image->num_planes == priv->plane_count);

    for (int n = 0; n < priv->plane_count; n++) {
        struct texplane *plane = &priv->planes[n];

        int width = priv->src_width >> plane->shift_x;
        int height = priv->src_height >> plane->shift_x;

        memcpy_pic(image->planes[n], plane->locked_rect.pBits,
                   width * plane->bytes_per_pixel, height,
                   image->stride[n], plane->locked_rect.Pitch);
    }

    return true;
}

static mp_image_t *get_screenshot(d3d_priv *priv)
{
    if (!priv->d3d_device)
        return NULL;

    mp_image_t *image = alloc_mpi(priv->src_width, priv->src_height,
                                  priv->image_format);

    bool res;

    if (priv->use_textures)
        res = get_screenshot_from_texture(priv, image);
    else
        res = get_screenshot_from_surface(priv, image);

    if (!res) {
        free_mp_image(image);
        return NULL;
    }

    image->w = priv->src_d_width;
    image->h = priv->src_d_height;

    return image;
}

static mp_image_t *get_window_screenshot(d3d_priv *priv)
{
    D3DDISPLAYMODE mode;
    mp_image_t *image = NULL;
    RECT window_rc;
    RECT screen_rc;
    RECT visible;
    POINT pt;
    D3DLOCKED_RECT locked_rect;
    int width, height;

    if (FAILED(IDirect3DDevice9_GetDisplayMode(priv->d3d_device, 0, &mode))) {
        mp_msg(MSGT_VO,MSGL_ERR, "<vo_direct3d>GetDisplayMode failed.\n");
        goto error_exit;
    }

    IDirect3DSurface9 *surface = NULL;
    if (FAILED(IDirect3DDevice9_CreateOffscreenPlainSurface(priv->d3d_device,
        mode.Width, mode.Height, D3DFMT_A8R8G8B8, D3DPOOL_SYSTEMMEM, &surface,
        NULL)))
    {
        mp_msg(MSGT_VO,MSGL_ERR, "<vo_direct3d>Couldn't create surface.\n");
        goto error_exit;
    }

    if (FAILED(IDirect3DDevice9_GetFrontBufferData(priv->d3d_device, 0,
        surface)))
    {
        mp_msg(MSGT_VO,MSGL_ERR, "<vo_direct3d>Couldn't copy frontbuffer.\n");
        goto error_exit;
    }

    GetClientRect(vo_w32_window, &window_rc);
    pt = (POINT) { 0, 0 };
    ClientToScreen(vo_w32_window, &pt);
    window_rc.left = pt.x;
    window_rc.top = pt.y;
    window_rc.right += window_rc.left;
    window_rc.bottom += window_rc.top;

    screen_rc = (RECT) { 0, 0, mode.Width, mode.Height };

    if (!IntersectRect(&visible, &screen_rc, &window_rc))
        goto error_exit;
    width = visible.right - visible.left;
    height = visible.bottom - visible.top;
    if (width < 1 || height < 1)
        goto error_exit;

    image = alloc_mpi(width, height, IMGFMT_BGR32);

    IDirect3DSurface9_LockRect(surface, &locked_rect, NULL, 0);

    memcpy_pic(image->planes[0], (char*)locked_rect.pBits + visible.top *
               locked_rect.Pitch + visible.left * 4, width * 4, height,
               image->stride[0], locked_rect.Pitch);

    IDirect3DSurface9_UnlockRect(surface);
    IDirect3DSurface9_Release(surface);

    return image;

error_exit:
    if (image)
        free_mp_image(image);
    if (surface)
        IDirect3DSurface9_Release(surface);
    return NULL;
}

/** @brief Maps MPlayer alpha to D3D
 *         0x0 -> transparent and discarded by alpha test
 *         0x1 -> 0xFF to become opaque
 *         other alpha values are inverted +1 (2 = -2)
 *         These values are then inverted again with
           the texture filter D3DBLEND_INVSRCALPHA
 */
static void vo_draw_alpha_l8a8(int w, int h, unsigned char* src,
                               unsigned char *srca, int srcstride,
                               unsigned char* dstbase, int dststride)
{
    int y;
    for (y = 0; y < h; y++) {
        unsigned short *dst = (unsigned short*)dstbase;
        int x;
        for (x = 0; x < w; x++) {
            dst[x] = (-srca[x] << 8) | src[x];
        }
        src     += srcstride;
        srca    += srcstride;
        dstbase += dststride;
    }
}

struct draw_osd_closure {
    d3d_priv *priv;
    D3DLOCKED_RECT locked_rect;
};

/** @brief Callback function to render the OSD to the texture
 */
static void draw_alpha(void *pctx, int x0, int y0, int w, int h,
                       unsigned char *src, unsigned char *srca, int stride)
{
    struct draw_osd_closure *ctx = pctx;
    D3DLOCKED_RECT locked_rect = ctx->locked_rect;

    vo_draw_alpha_l8a8(w, h, src, srca, stride,
        (unsigned char *)locked_rect.pBits + locked_rect.Pitch * y0 + 2 * x0,
        locked_rect.Pitch);

    ctx->priv->is_osd_populated = 1;
}

/** @brief libvo Callback: Draw OSD/Subtitles,
 */
static void draw_osd(struct vo *vo, struct osd_state *osd)
{
    d3d_priv *priv = vo->priv;

    if (!priv->d3d_device)
        return;

    if (vo_osd_changed(0)) {
        struct draw_osd_closure ctx = { priv };

        /* clear the OSD */
        if (FAILED(IDirect3DTexture9_LockRect(priv->texture_osd.system, 0,
                                              &ctx.locked_rect, NULL, 0))) {
            mp_msg(MSGT_VO,MSGL_ERR, "<vo_direct3d>OSD texture lock failed.\n");
            return;
        }

        /* clear the whole texture to avoid issues due to interpolation */
        memset(ctx.locked_rect.pBits, 0,
               ctx.locked_rect.Pitch * priv->texture_osd.tex_h);

        priv->is_osd_populated = 0;
        /* required for if subs are in the boarder region */
        priv->is_clear_needed = 1;

        osd_draw_text_ext(osd, priv->texture_osd.w, priv->texture_osd.h,
                          priv->border_x, priv->border_y,
                          priv->border_x, priv->border_y,
                          priv->src_width, priv->src_height, draw_alpha, &ctx);

        if (FAILED(IDirect3DTexture9_UnlockRect(priv->texture_osd.system, 0))) {
            mp_msg(MSGT_VO,MSGL_ERR,
                   "<vo_direct3d>OSD texture unlock failed.\n");
            return;
        }

        d3dtex_update(priv, &priv->texture_osd);
    }

    if (priv->is_osd_populated) {
        float tw = (float)priv->texture_osd.w  / priv->texture_osd.tex_w;
        float th = (float)priv->texture_osd.h  / priv->texture_osd.tex_h;

        vertex_osd osd_quad_vb[] = {
            { 0,          0,           0.0f, 0,  0  },
            { vo->dwidth, 0,           0.0f, tw, 0  },
            { 0,          vo->dheight, 0.0f, 0,  th },
            { vo->dwidth, vo->dheight, 0.0f, tw, th }
        };

        d3d_begin_scene(priv);

        IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                        D3DRS_ALPHABLENDENABLE, TRUE);
        IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                        D3DRS_ALPHATESTENABLE, TRUE);

        IDirect3DDevice9_SetTexture(priv->d3d_device, 0,
                        d3dtex_get_render_texture(priv, &priv->texture_osd));

        IDirect3DDevice9_SetFVF(priv->d3d_device, D3DFVF_OSD_VERTEX);
        IDirect3DDevice9_DrawPrimitiveUP(priv->d3d_device, D3DPT_TRIANGLESTRIP,
                                         2, osd_quad_vb, sizeof(vertex_osd));

        IDirect3DDevice9_SetTexture(priv->d3d_device, 0, NULL);

        IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                        D3DRS_ALPHATESTENABLE, FALSE);
        IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                        D3DRS_ALPHABLENDENABLE, FALSE);
    }
}

static void d3d_realloc_eosd_texture(d3d_priv *priv)
{
    int new_w = priv->eosd->surface.w;
    int new_h = priv->eosd->surface.h;

    d3d_fix_texture_size(priv, &new_w, &new_h);

    if (new_w == priv->texture_eosd.tex_w && new_h == priv->texture_eosd.tex_h)
        return;

    mp_msg(MSGT_VO, MSGL_DBG2, "<vo_direct3d>reallocate EOSD surface.\n");

    // fortunately, we don't need to keep the old image data
    // we can always free it
    d3dtex_release(priv, &priv->texture_eosd);

    d3dtex_allocate(priv, &priv->texture_eosd, D3DFMT_A8, new_w, new_h);
}

static D3DCOLOR ass_to_d3d_color(uint32_t color)
{
    uint32_t r = (color >> 24) & 0xff;
    uint32_t g = (color >> 16) & 0xff;
    uint32_t b = (color >> 8) & 0xff;
    uint32_t a = 0xff - (color & 0xff);
    return D3DCOLOR_ARGB(a, r, g, b);
}

static void generate_eosd(d3d_priv *priv, mp_eosd_images_t *imgs)
{
    if (!priv->d3d_device)
        return;

    bool need_reposition, need_upload, need_resize;
    eosd_packer_generate(priv->eosd, imgs, &need_reposition, &need_upload,
                         &need_resize);

    if (!need_upload)
        return;
    // even if the texture size is unchanged, the texture might have been free'd
    d3d_realloc_eosd_texture(priv);
    if (!priv->texture_eosd.system)
        return; // failed to allocate

    // reupload all EOSD images

    // we need 2 primitives per quad which makes 6 vertices (we could reduce the
    // number of vertices by using an indexed vertex array, but it's probably
    // not worth doing)
    priv->eosd_vb = talloc_realloc_size(priv->eosd, priv->eosd_vb,
                                        priv->eosd->targets_count
                                        * sizeof(vertex_eosd) * 6);

    struct eosd_rect rc;
    eosd_packer_calculate_source_bb(priv->eosd, &rc);
    RECT dirty_rc = { rc.x0, rc.y0, rc.x1, rc.y1 };

    D3DLOCKED_RECT locked_rect;

    if (FAILED(IDirect3DTexture9_LockRect(priv->texture_eosd.system, 0,
                                          &locked_rect, &dirty_rc, 0)))
    {
        mp_msg(MSGT_VO,MSGL_ERR, "<vo_direct3d>EOSD texture lock failed.\n");
        return;
    }

    //memset(locked_rect.pBits, 0, locked_rect.Pitch * priv->texture_eosd.tex_h);

    float eosd_w = priv->texture_eosd.tex_w;
    float eosd_h = priv->texture_eosd.tex_h;

    for (int i = 0; i < priv->eosd->targets_count; i++) {
        struct eosd_target *target = &priv->eosd->targets[i];
        ASS_Image *img = target->ass_img;
        char *src = img->bitmap;
        char *dst = (char*)locked_rect.pBits + target->source.x0
                    + locked_rect.Pitch * target->source.y0;
        for (int y = 0; y < img->h; y++) {
            memcpy(dst, src, img->w);
            src += img->stride;
            dst += locked_rect.Pitch;
        }

        D3DCOLOR color = ass_to_d3d_color(img->color);

        float x0 = target->dest.x0;
        float y0 = target->dest.y0;
        float x1 = target->dest.x1;
        float y1 = target->dest.y1;
        float tx0 = target->source.x0 / eosd_w;
        float ty0 = target->source.y0 / eosd_h;
        float tx1 = target->source.x1 / eosd_w;
        float ty1 = target->source.y1 / eosd_h;

        vertex_eosd *v = &priv->eosd_vb[i*6];
        v[0] = (vertex_eosd) { x0, y0, 0, color, tx0, ty0 };
        v[1] = (vertex_eosd) { x1, y0, 0, color, tx1, ty0 };
        v[2] = (vertex_eosd) { x0, y1, 0, color, tx0, ty1 };
        v[3] = (vertex_eosd) { x1, y1, 0, color, tx1, ty1 };
        v[4] = v[2];
        v[5] = v[1];
    }

    if (FAILED(IDirect3DTexture9_UnlockRect(priv->texture_eosd.system, 0))) {
        mp_msg(MSGT_VO,MSGL_ERR, "<vo_direct3d>EOSD texture unlock failed.\n");
        return;
    }

    d3dtex_update(priv, &priv->texture_eosd);
}

static void draw_eosd(d3d_priv *priv)
{
    if (!priv->d3d_device)
        return;

    if (!priv->eosd->targets_count)
        return;

    d3d_begin_scene(priv);

    IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                    D3DRS_ALPHABLENDENABLE, TRUE);

    IDirect3DDevice9_SetTexture(priv->d3d_device, 0,
                        d3dtex_get_render_texture(priv, &priv->texture_eosd));

    // do not use the color value from the A8 texture, because that is black
    IDirect3DDevice9_SetRenderState(priv->d3d_device,D3DRS_TEXTUREFACTOR,
                                    0xFFFFFFFF);
    IDirect3DDevice9_SetTextureStageState(priv->d3d_device,0,
                                          D3DTSS_COLORARG1, D3DTA_TFACTOR);

    IDirect3DDevice9_SetTextureStageState(priv->d3d_device, 0,
                                          D3DTSS_ALPHAOP, D3DTOP_MODULATE);

    IDirect3DDevice9_SetFVF(priv->d3d_device, D3DFVF_EOSD_VERTEX);
    IDirect3DDevice9_DrawPrimitiveUP(priv->d3d_device, D3DPT_TRIANGLELIST,
                                     priv->eosd->targets_count * 2,
                                     priv->eosd_vb, sizeof(vertex_eosd));

    IDirect3DDevice9_SetTextureStageState(priv->d3d_device,0,
                                          D3DTSS_COLORARG1, D3DTA_TEXTURE);
    IDirect3DDevice9_SetTextureStageState(priv->d3d_device, 0,
                                          D3DTSS_ALPHAOP, D3DTOP_SELECTARG1);

    IDirect3DDevice9_SetTexture(priv->d3d_device, 0, NULL);

    IDirect3DDevice9_SetRenderState(priv->d3d_device,
                                    D3DRS_ALPHABLENDENABLE, FALSE);
}

#define AUTHOR "Georgi Petrov (gogothebee) <gogothebee@gmail.com> and others"

const struct vo_driver video_out_direct3d = {
    .is_new = true,
    .info = &(const vo_info_t) {
        "Direct3D 9 Renderer",
        "direct3d",
        AUTHOR,
        ""
    },
    .preinit = preinit_standard,
    .config = config,
    .control = control,
    .draw_slice = draw_slice,
    .draw_osd = draw_osd,
    .flip_page = flip_page,
    .check_events = check_events,
    .uninit = uninit,
};

const struct vo_driver video_out_direct3d_shaders = {
    .is_new = true,
    .info = &(const vo_info_t) {
        "Direct3D 9 Renderer (using shaders for YUV conversion)",
        "direct3d_shaders",
        AUTHOR,
        ""
    },
    .preinit = preinit_shaders,
    .config = config,
    .control = control,
    .draw_slice = draw_slice,
    .draw_osd = draw_osd,
    .flip_page = flip_page,
    .check_events = check_events,
    .uninit = uninit,
};
